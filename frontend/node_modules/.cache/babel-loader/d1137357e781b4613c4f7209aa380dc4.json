{"ast":null,"code":"import { mixNumber } from '../../utils/mix/number.mjs';\nimport { complex } from '../../value/types/complex/index.mjs';\nconst correctBoxShadow = {\n  correct: (latest, _ref) => {\n    let {\n      treeScale,\n      projectionDelta\n    } = _ref;\n    const original = latest;\n    const shadow = complex.parse(latest); // TODO: Doesn't support multiple shadows\n\n    if (shadow.length > 5) return original;\n    const template = complex.createTransformer(latest);\n    const offset = typeof shadow[0] !== \"number\" ? 1 : 0; // Calculate the overall context scale\n\n    const xScale = projectionDelta.x.scale * treeScale.x;\n    const yScale = projectionDelta.y.scale * treeScale.y;\n    shadow[0 + offset] /= xScale;\n    shadow[1 + offset] /= yScale;\n    /**\r\n     * Ideally we'd correct x and y scales individually, but because blur and\r\n     * spread apply to both we have to take a scale average and apply that instead.\r\n     * We could potentially improve the outcome of this by incorporating the ratio between\r\n     * the two scales.\r\n     */\n\n    const averageScale = mixNumber(xScale, yScale, 0.5); // Blur\n\n    if (typeof shadow[2 + offset] === \"number\") shadow[2 + offset] /= averageScale; // Spread\n\n    if (typeof shadow[3 + offset] === \"number\") shadow[3 + offset] /= averageScale;\n    return template(shadow);\n  }\n};\nexport { correctBoxShadow };","map":{"version":3,"sources":["C:/Users/PC/Documents/PROGRAMMING/New folder/MERN-BF/frontend/node_modules/framer-motion/dist/es/projection/styles/scale-box-shadow.mjs"],"names":["mixNumber","complex","correctBoxShadow","correct","latest","treeScale","projectionDelta","original","shadow","parse","length","template","createTransformer","offset","xScale","x","scale","yScale","y","averageScale"],"mappings":"AAAA,SAASA,SAAT,QAA0B,4BAA1B;AACA,SAASC,OAAT,QAAwB,qCAAxB;AAEA,MAAMC,gBAAgB,GAAG;AACrBC,EAAAA,OAAO,EAAE,CAACC,MAAD,WAA4C;AAAA,QAAnC;AAAEC,MAAAA,SAAF;AAAaC,MAAAA;AAAb,KAAmC;AACjD,UAAMC,QAAQ,GAAGH,MAAjB;AACA,UAAMI,MAAM,GAAGP,OAAO,CAACQ,KAAR,CAAcL,MAAd,CAAf,CAFiD,CAGjD;;AACA,QAAII,MAAM,CAACE,MAAP,GAAgB,CAApB,EACI,OAAOH,QAAP;AACJ,UAAMI,QAAQ,GAAGV,OAAO,CAACW,iBAAR,CAA0BR,MAA1B,CAAjB;AACA,UAAMS,MAAM,GAAG,OAAOL,MAAM,CAAC,CAAD,CAAb,KAAqB,QAArB,GAAgC,CAAhC,GAAoC,CAAnD,CAPiD,CAQjD;;AACA,UAAMM,MAAM,GAAGR,eAAe,CAACS,CAAhB,CAAkBC,KAAlB,GAA0BX,SAAS,CAACU,CAAnD;AACA,UAAME,MAAM,GAAGX,eAAe,CAACY,CAAhB,CAAkBF,KAAlB,GAA0BX,SAAS,CAACa,CAAnD;AACAV,IAAAA,MAAM,CAAC,IAAIK,MAAL,CAAN,IAAsBC,MAAtB;AACAN,IAAAA,MAAM,CAAC,IAAIK,MAAL,CAAN,IAAsBI,MAAtB;AACA;AACR;AACA;AACA;AACA;AACA;;AACQ,UAAME,YAAY,GAAGnB,SAAS,CAACc,MAAD,EAASG,MAAT,EAAiB,GAAjB,CAA9B,CAnBiD,CAoBjD;;AACA,QAAI,OAAOT,MAAM,CAAC,IAAIK,MAAL,CAAb,KAA8B,QAAlC,EACIL,MAAM,CAAC,IAAIK,MAAL,CAAN,IAAsBM,YAAtB,CAtB6C,CAuBjD;;AACA,QAAI,OAAOX,MAAM,CAAC,IAAIK,MAAL,CAAb,KAA8B,QAAlC,EACIL,MAAM,CAAC,IAAIK,MAAL,CAAN,IAAsBM,YAAtB;AACJ,WAAOR,QAAQ,CAACH,MAAD,CAAf;AACH;AA5BoB,CAAzB;AA+BA,SAASN,gBAAT","sourcesContent":["import { mixNumber } from '../../utils/mix/number.mjs';\r\nimport { complex } from '../../value/types/complex/index.mjs';\r\n\r\nconst correctBoxShadow = {\r\n    correct: (latest, { treeScale, projectionDelta }) => {\r\n        const original = latest;\r\n        const shadow = complex.parse(latest);\r\n        // TODO: Doesn't support multiple shadows\r\n        if (shadow.length > 5)\r\n            return original;\r\n        const template = complex.createTransformer(latest);\r\n        const offset = typeof shadow[0] !== \"number\" ? 1 : 0;\r\n        // Calculate the overall context scale\r\n        const xScale = projectionDelta.x.scale * treeScale.x;\r\n        const yScale = projectionDelta.y.scale * treeScale.y;\r\n        shadow[0 + offset] /= xScale;\r\n        shadow[1 + offset] /= yScale;\r\n        /**\r\n         * Ideally we'd correct x and y scales individually, but because blur and\r\n         * spread apply to both we have to take a scale average and apply that instead.\r\n         * We could potentially improve the outcome of this by incorporating the ratio between\r\n         * the two scales.\r\n         */\r\n        const averageScale = mixNumber(xScale, yScale, 0.5);\r\n        // Blur\r\n        if (typeof shadow[2 + offset] === \"number\")\r\n            shadow[2 + offset] /= averageScale;\r\n        // Spread\r\n        if (typeof shadow[3 + offset] === \"number\")\r\n            shadow[3 + offset] /= averageScale;\r\n        return template(shadow);\r\n    },\r\n};\r\n\r\nexport { correctBoxShadow };\r\n"]},"metadata":{},"sourceType":"module"}