{"ast":null,"code":"import { isGenerator, calcGeneratorDuration, activeAnimations } from 'motion-dom';\nimport { invariant, millisecondsToSeconds, secondsToMilliseconds } from 'motion-utils';\nimport { KeyframeResolver } from '../../render/utils/KeyframesResolver.mjs';\nimport { clamp } from '../../utils/clamp.mjs';\nimport { mix } from '../../utils/mix/index.mjs';\nimport { pipe } from '../../utils/pipe.mjs';\nimport { inertia } from '../generators/inertia.mjs';\nimport { keyframes } from '../generators/keyframes.mjs';\nimport { spring } from '../generators/spring/index.mjs';\nimport { BaseAnimation } from './BaseAnimation.mjs';\nimport { frameloopDriver } from './drivers/driver-frameloop.mjs';\nimport { getFinalKeyframe } from './waapi/utils/get-final-keyframe.mjs';\nconst generators = {\n  decay: inertia,\n  inertia,\n  tween: keyframes,\n  keyframes: keyframes,\n  spring\n};\n\nconst percentToProgress = percent => percent / 100;\n/**\r\n * Animation that runs on the main thread. Designed to be WAAPI-spec in the subset of\r\n * features we expose publically. Mostly the compatibility is to ensure visual identity\r\n * between both WAAPI and main thread animations.\r\n */\n\n\nclass MainThreadAnimation extends BaseAnimation {\n  constructor(options) {\n    super(options);\n    /**\r\n     * The time at which the animation was paused.\r\n     */\n\n    this.holdTime = null;\n    /**\r\n     * The time at which the animation was cancelled.\r\n     */\n\n    this.cancelTime = null;\n    /**\r\n     * The current time of the animation.\r\n     */\n\n    this.currentTime = 0;\n    /**\r\n     * Playback speed as a factor. 0 would be stopped, -1 reverse and 2 double speed.\r\n     */\n\n    this.playbackSpeed = 1;\n    /**\r\n     * The state of the animation to apply when the animation is resolved. This\r\n     * allows calls to the public API to control the animation before it is resolved,\r\n     * without us having to resolve it first.\r\n     */\n\n    this.pendingPlayState = \"running\";\n    /**\r\n     * The time at which the animation was started.\r\n     */\n\n    this.startTime = null;\n    this.state = \"idle\";\n    /**\r\n     * This method is bound to the instance to fix a pattern where\r\n     * animation.stop is returned as a reference from a useEffect.\r\n     */\n\n    this.stop = () => {\n      this.resolver.cancel();\n      this.isStopped = true;\n      if (this.state === \"idle\") return;\n      this.teardown();\n      const {\n        onStop\n      } = this.options;\n      onStop && onStop();\n    };\n\n    const {\n      name,\n      motionValue,\n      element,\n      keyframes\n    } = this.options;\n    const KeyframeResolver$1 = (element === null || element === void 0 ? void 0 : element.KeyframeResolver) || KeyframeResolver;\n\n    const onResolved = (resolvedKeyframes, finalKeyframe) => this.onKeyframesResolved(resolvedKeyframes, finalKeyframe);\n\n    this.resolver = new KeyframeResolver$1(keyframes, onResolved, name, motionValue, element);\n    this.resolver.scheduleResolve();\n  }\n\n  flatten() {\n    super.flatten(); // If we've already resolved the animation, re-initialise it\n\n    if (this._resolved) {\n      Object.assign(this._resolved, this.initPlayback(this._resolved.keyframes));\n    }\n  }\n\n  initPlayback(keyframes$1) {\n    const {\n      type = \"keyframes\",\n      repeat = 0,\n      repeatDelay = 0,\n      repeatType,\n      velocity = 0\n    } = this.options;\n    const generatorFactory = isGenerator(type) ? type : generators[type] || keyframes;\n    /**\r\n     * If our generator doesn't support mixing numbers, we need to replace keyframes with\r\n     * [0, 100] and then make a function that maps that to the actual keyframes.\r\n     *\r\n     * 100 is chosen instead of 1 as it works nicer with spring animations.\r\n     */\n\n    let mapPercentToKeyframes;\n    let mirroredGenerator;\n\n    if (process.env.NODE_ENV !== \"production\" && generatorFactory !== keyframes) {\n      invariant(keyframes$1.length <= 2, `Only two keyframes currently supported with spring and inertia animations. Trying to animate ${keyframes$1}`);\n    }\n\n    if (generatorFactory !== keyframes && typeof keyframes$1[0] !== \"number\") {\n      mapPercentToKeyframes = pipe(percentToProgress, mix(keyframes$1[0], keyframes$1[1]));\n      keyframes$1 = [0, 100];\n    }\n\n    const generator = generatorFactory({ ...this.options,\n      keyframes: keyframes$1\n    });\n    /**\r\n     * If we have a mirror repeat type we need to create a second generator that outputs the\r\n     * mirrored (not reversed) animation and later ping pong between the two generators.\r\n     */\n\n    if (repeatType === \"mirror\") {\n      mirroredGenerator = generatorFactory({ ...this.options,\n        keyframes: [...keyframes$1].reverse(),\n        velocity: -velocity\n      });\n    }\n    /**\r\n     * If duration is undefined and we have repeat options,\r\n     * we need to calculate a duration from the generator.\r\n     *\r\n     * We set it to the generator itself to cache the duration.\r\n     * Any timeline resolver will need to have already precalculated\r\n     * the duration by this step.\r\n     */\n\n\n    if (generator.calculatedDuration === null) {\n      generator.calculatedDuration = calcGeneratorDuration(generator);\n    }\n\n    const {\n      calculatedDuration\n    } = generator;\n    const resolvedDuration = calculatedDuration + repeatDelay;\n    const totalDuration = resolvedDuration * (repeat + 1) - repeatDelay;\n    return {\n      generator,\n      mirroredGenerator,\n      mapPercentToKeyframes,\n      calculatedDuration,\n      resolvedDuration,\n      totalDuration\n    };\n  }\n\n  onPostResolved() {\n    const {\n      autoplay = true\n    } = this.options;\n    activeAnimations.mainThread++;\n    this.play();\n\n    if (this.pendingPlayState === \"paused\" || !autoplay) {\n      this.pause();\n    } else {\n      this.state = this.pendingPlayState;\n    }\n  }\n\n  tick(timestamp) {\n    let sample = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    const {\n      resolved\n    } = this; // If the animations has failed to resolve, return the final keyframe.\n\n    if (!resolved) {\n      const {\n        keyframes\n      } = this.options;\n      return {\n        done: true,\n        value: keyframes[keyframes.length - 1]\n      };\n    }\n\n    const {\n      finalKeyframe,\n      generator,\n      mirroredGenerator,\n      mapPercentToKeyframes,\n      keyframes,\n      calculatedDuration,\n      totalDuration,\n      resolvedDuration\n    } = resolved;\n    if (this.startTime === null) return generator.next(0);\n    const {\n      delay,\n      repeat,\n      repeatType,\n      repeatDelay,\n      onUpdate\n    } = this.options;\n    /**\r\n     * requestAnimationFrame timestamps can come through as lower than\r\n     * the startTime as set by performance.now(). Here we prevent this,\r\n     * though in the future it could be possible to make setting startTime\r\n     * a pending operation that gets resolved here.\r\n     */\n\n    if (this.speed > 0) {\n      this.startTime = Math.min(this.startTime, timestamp);\n    } else if (this.speed < 0) {\n      this.startTime = Math.min(timestamp - totalDuration / this.speed, this.startTime);\n    } // Update currentTime\n\n\n    if (sample) {\n      this.currentTime = timestamp;\n    } else if (this.holdTime !== null) {\n      this.currentTime = this.holdTime;\n    } else {\n      // Rounding the time because floating point arithmetic is not always accurate, e.g. 3000.367 - 1000.367 =\n      // 2000.0000000000002. This is a problem when we are comparing the currentTime with the duration, for\n      // example.\n      this.currentTime = Math.round(timestamp - this.startTime) * this.speed;\n    } // Rebase on delay\n\n\n    const timeWithoutDelay = this.currentTime - delay * (this.speed >= 0 ? 1 : -1);\n    const isInDelayPhase = this.speed >= 0 ? timeWithoutDelay < 0 : timeWithoutDelay > totalDuration;\n    this.currentTime = Math.max(timeWithoutDelay, 0); // If this animation has finished, set the current time  to the total duration.\n\n    if (this.state === \"finished\" && this.holdTime === null) {\n      this.currentTime = totalDuration;\n    }\n\n    let elapsed = this.currentTime;\n    let frameGenerator = generator;\n\n    if (repeat) {\n      /**\r\n       * Get the current progress (0-1) of the animation. If t is >\r\n       * than duration we'll get values like 2.5 (midway through the\r\n       * third iteration)\r\n       */\n      const progress = Math.min(this.currentTime, totalDuration) / resolvedDuration;\n      /**\r\n       * Get the current iteration (0 indexed). For instance the floor of\r\n       * 2.5 is 2.\r\n       */\n\n      let currentIteration = Math.floor(progress);\n      /**\r\n       * Get the current progress of the iteration by taking the remainder\r\n       * so 2.5 is 0.5 through iteration 2\r\n       */\n\n      let iterationProgress = progress % 1.0;\n      /**\r\n       * If iteration progress is 1 we count that as the end\r\n       * of the previous iteration.\r\n       */\n\n      if (!iterationProgress && progress >= 1) {\n        iterationProgress = 1;\n      }\n\n      iterationProgress === 1 && currentIteration--;\n      currentIteration = Math.min(currentIteration, repeat + 1);\n      /**\r\n       * Reverse progress if we're not running in \"normal\" direction\r\n       */\n\n      const isOddIteration = Boolean(currentIteration % 2);\n\n      if (isOddIteration) {\n        if (repeatType === \"reverse\") {\n          iterationProgress = 1 - iterationProgress;\n\n          if (repeatDelay) {\n            iterationProgress -= repeatDelay / resolvedDuration;\n          }\n        } else if (repeatType === \"mirror\") {\n          frameGenerator = mirroredGenerator;\n        }\n      }\n\n      elapsed = clamp(0, 1, iterationProgress) * resolvedDuration;\n    }\n    /**\r\n     * If we're in negative time, set state as the initial keyframe.\r\n     * This prevents delay: x, duration: 0 animations from finishing\r\n     * instantly.\r\n     */\n\n\n    const state = isInDelayPhase ? {\n      done: false,\n      value: keyframes[0]\n    } : frameGenerator.next(elapsed);\n\n    if (mapPercentToKeyframes) {\n      state.value = mapPercentToKeyframes(state.value);\n    }\n\n    let {\n      done\n    } = state;\n\n    if (!isInDelayPhase && calculatedDuration !== null) {\n      done = this.speed >= 0 ? this.currentTime >= totalDuration : this.currentTime <= 0;\n    }\n\n    const isAnimationFinished = this.holdTime === null && (this.state === \"finished\" || this.state === \"running\" && done);\n\n    if (isAnimationFinished && finalKeyframe !== undefined) {\n      state.value = getFinalKeyframe(keyframes, this.options, finalKeyframe);\n    }\n\n    if (onUpdate) {\n      onUpdate(state.value);\n    }\n\n    if (isAnimationFinished) {\n      this.finish();\n    }\n\n    return state;\n  }\n\n  get duration() {\n    const {\n      resolved\n    } = this;\n    return resolved ? millisecondsToSeconds(resolved.calculatedDuration) : 0;\n  }\n\n  get time() {\n    return millisecondsToSeconds(this.currentTime);\n  }\n\n  set time(newTime) {\n    newTime = secondsToMilliseconds(newTime);\n    this.currentTime = newTime;\n\n    if (this.holdTime !== null || this.speed === 0) {\n      this.holdTime = newTime;\n    } else if (this.driver) {\n      this.startTime = this.driver.now() - newTime / this.speed;\n    }\n  }\n\n  get speed() {\n    return this.playbackSpeed;\n  }\n\n  set speed(newSpeed) {\n    const hasChanged = this.playbackSpeed !== newSpeed;\n    this.playbackSpeed = newSpeed;\n\n    if (hasChanged) {\n      this.time = millisecondsToSeconds(this.currentTime);\n    }\n  }\n\n  play() {\n    if (!this.resolver.isScheduled) {\n      this.resolver.resume();\n    }\n\n    if (!this._resolved) {\n      this.pendingPlayState = \"running\";\n      return;\n    }\n\n    if (this.isStopped) return;\n    const {\n      driver = frameloopDriver,\n      onPlay,\n      startTime\n    } = this.options;\n\n    if (!this.driver) {\n      this.driver = driver(timestamp => this.tick(timestamp));\n    }\n\n    onPlay && onPlay();\n    const now = this.driver.now();\n\n    if (this.holdTime !== null) {\n      this.startTime = now - this.holdTime;\n    } else if (!this.startTime) {\n      this.startTime = startTime !== null && startTime !== void 0 ? startTime : this.calcStartTime();\n    } else if (this.state === \"finished\") {\n      this.startTime = now;\n    }\n\n    if (this.state === \"finished\") {\n      this.updateFinishedPromise();\n    }\n\n    this.cancelTime = this.startTime;\n    this.holdTime = null;\n    /**\r\n     * Set playState to running only after we've used it in\r\n     * the previous logic.\r\n     */\n\n    this.state = \"running\";\n    this.driver.start();\n  }\n\n  pause() {\n    var _a;\n\n    if (!this._resolved) {\n      this.pendingPlayState = \"paused\";\n      return;\n    }\n\n    this.state = \"paused\";\n    this.holdTime = (_a = this.currentTime) !== null && _a !== void 0 ? _a : 0;\n  }\n\n  complete() {\n    if (this.state !== \"running\") {\n      this.play();\n    }\n\n    this.pendingPlayState = this.state = \"finished\";\n    this.holdTime = null;\n  }\n\n  finish() {\n    this.teardown();\n    this.state = \"finished\";\n    const {\n      onComplete\n    } = this.options;\n    onComplete && onComplete();\n  }\n\n  cancel() {\n    if (this.cancelTime !== null) {\n      this.tick(this.cancelTime);\n    }\n\n    this.teardown();\n    this.updateFinishedPromise();\n  }\n\n  teardown() {\n    this.state = \"idle\";\n    this.stopDriver();\n    this.resolveFinishedPromise();\n    this.updateFinishedPromise();\n    this.startTime = this.cancelTime = null;\n    this.resolver.cancel();\n    activeAnimations.mainThread--;\n  }\n\n  stopDriver() {\n    if (!this.driver) return;\n    this.driver.stop();\n    this.driver = undefined;\n  }\n\n  sample(time) {\n    this.startTime = 0;\n    return this.tick(time, true);\n  }\n\n} // Legacy interface\n\n\nfunction animateValue(options) {\n  return new MainThreadAnimation(options);\n}\n\nexport { MainThreadAnimation, animateValue };","map":{"version":3,"sources":["C:/Users/PC/Documents/PROGRAMMING/New folder/MERN-BF/frontend/node_modules/framer-motion/dist/es/animation/animators/MainThreadAnimation.mjs"],"names":["isGenerator","calcGeneratorDuration","activeAnimations","invariant","millisecondsToSeconds","secondsToMilliseconds","KeyframeResolver","clamp","mix","pipe","inertia","keyframes","spring","BaseAnimation","frameloopDriver","getFinalKeyframe","generators","decay","tween","percentToProgress","percent","MainThreadAnimation","constructor","options","holdTime","cancelTime","currentTime","playbackSpeed","pendingPlayState","startTime","state","stop","resolver","cancel","isStopped","teardown","onStop","name","motionValue","element","KeyframeResolver$1","onResolved","resolvedKeyframes","finalKeyframe","onKeyframesResolved","scheduleResolve","flatten","_resolved","Object","assign","initPlayback","keyframes$1","type","repeat","repeatDelay","repeatType","velocity","generatorFactory","mapPercentToKeyframes","mirroredGenerator","process","env","NODE_ENV","length","generator","reverse","calculatedDuration","resolvedDuration","totalDuration","onPostResolved","autoplay","mainThread","play","pause","tick","timestamp","sample","resolved","done","value","next","delay","onUpdate","speed","Math","min","round","timeWithoutDelay","isInDelayPhase","max","elapsed","frameGenerator","progress","currentIteration","floor","iterationProgress","isOddIteration","Boolean","isAnimationFinished","undefined","finish","duration","time","newTime","driver","now","newSpeed","hasChanged","isScheduled","resume","onPlay","calcStartTime","updateFinishedPromise","start","_a","complete","onComplete","stopDriver","resolveFinishedPromise","animateValue"],"mappings":"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","sourcesContent":["import { isGenerator, calcGeneratorDuration, activeAnimations } from 'motion-dom';\r\nimport { invariant, millisecondsToSeconds, secondsToMilliseconds } from 'motion-utils';\r\nimport { KeyframeResolver } from '../../render/utils/KeyframesResolver.mjs';\r\nimport { clamp } from '../../utils/clamp.mjs';\r\nimport { mix } from '../../utils/mix/index.mjs';\r\nimport { pipe } from '../../utils/pipe.mjs';\r\nimport { inertia } from '../generators/inertia.mjs';\r\nimport { keyframes } from '../generators/keyframes.mjs';\r\nimport { spring } from '../generators/spring/index.mjs';\r\nimport { BaseAnimation } from './BaseAnimation.mjs';\r\nimport { frameloopDriver } from './drivers/driver-frameloop.mjs';\r\nimport { getFinalKeyframe } from './waapi/utils/get-final-keyframe.mjs';\r\n\r\nconst generators = {\r\n    decay: inertia,\r\n    inertia,\r\n    tween: keyframes,\r\n    keyframes: keyframes,\r\n    spring,\r\n};\r\nconst percentToProgress = (percent) => percent / 100;\r\n/**\r\n * Animation that runs on the main thread. Designed to be WAAPI-spec in the subset of\r\n * features we expose publically. Mostly the compatibility is to ensure visual identity\r\n * between both WAAPI and main thread animations.\r\n */\r\nclass MainThreadAnimation extends BaseAnimation {\r\n    constructor(options) {\r\n        super(options);\r\n        /**\r\n         * The time at which the animation was paused.\r\n         */\r\n        this.holdTime = null;\r\n        /**\r\n         * The time at which the animation was cancelled.\r\n         */\r\n        this.cancelTime = null;\r\n        /**\r\n         * The current time of the animation.\r\n         */\r\n        this.currentTime = 0;\r\n        /**\r\n         * Playback speed as a factor. 0 would be stopped, -1 reverse and 2 double speed.\r\n         */\r\n        this.playbackSpeed = 1;\r\n        /**\r\n         * The state of the animation to apply when the animation is resolved. This\r\n         * allows calls to the public API to control the animation before it is resolved,\r\n         * without us having to resolve it first.\r\n         */\r\n        this.pendingPlayState = \"running\";\r\n        /**\r\n         * The time at which the animation was started.\r\n         */\r\n        this.startTime = null;\r\n        this.state = \"idle\";\r\n        /**\r\n         * This method is bound to the instance to fix a pattern where\r\n         * animation.stop is returned as a reference from a useEffect.\r\n         */\r\n        this.stop = () => {\r\n            this.resolver.cancel();\r\n            this.isStopped = true;\r\n            if (this.state === \"idle\")\r\n                return;\r\n            this.teardown();\r\n            const { onStop } = this.options;\r\n            onStop && onStop();\r\n        };\r\n        const { name, motionValue, element, keyframes } = this.options;\r\n        const KeyframeResolver$1 = (element === null || element === void 0 ? void 0 : element.KeyframeResolver) || KeyframeResolver;\r\n        const onResolved = (resolvedKeyframes, finalKeyframe) => this.onKeyframesResolved(resolvedKeyframes, finalKeyframe);\r\n        this.resolver = new KeyframeResolver$1(keyframes, onResolved, name, motionValue, element);\r\n        this.resolver.scheduleResolve();\r\n    }\r\n    flatten() {\r\n        super.flatten();\r\n        // If we've already resolved the animation, re-initialise it\r\n        if (this._resolved) {\r\n            Object.assign(this._resolved, this.initPlayback(this._resolved.keyframes));\r\n        }\r\n    }\r\n    initPlayback(keyframes$1) {\r\n        const { type = \"keyframes\", repeat = 0, repeatDelay = 0, repeatType, velocity = 0, } = this.options;\r\n        const generatorFactory = isGenerator(type)\r\n            ? type\r\n            : generators[type] || keyframes;\r\n        /**\r\n         * If our generator doesn't support mixing numbers, we need to replace keyframes with\r\n         * [0, 100] and then make a function that maps that to the actual keyframes.\r\n         *\r\n         * 100 is chosen instead of 1 as it works nicer with spring animations.\r\n         */\r\n        let mapPercentToKeyframes;\r\n        let mirroredGenerator;\r\n        if (process.env.NODE_ENV !== \"production\" &&\r\n            generatorFactory !== keyframes) {\r\n            invariant(keyframes$1.length <= 2, `Only two keyframes currently supported with spring and inertia animations. Trying to animate ${keyframes$1}`);\r\n        }\r\n        if (generatorFactory !== keyframes &&\r\n            typeof keyframes$1[0] !== \"number\") {\r\n            mapPercentToKeyframes = pipe(percentToProgress, mix(keyframes$1[0], keyframes$1[1]));\r\n            keyframes$1 = [0, 100];\r\n        }\r\n        const generator = generatorFactory({ ...this.options, keyframes: keyframes$1 });\r\n        /**\r\n         * If we have a mirror repeat type we need to create a second generator that outputs the\r\n         * mirrored (not reversed) animation and later ping pong between the two generators.\r\n         */\r\n        if (repeatType === \"mirror\") {\r\n            mirroredGenerator = generatorFactory({\r\n                ...this.options,\r\n                keyframes: [...keyframes$1].reverse(),\r\n                velocity: -velocity,\r\n            });\r\n        }\r\n        /**\r\n         * If duration is undefined and we have repeat options,\r\n         * we need to calculate a duration from the generator.\r\n         *\r\n         * We set it to the generator itself to cache the duration.\r\n         * Any timeline resolver will need to have already precalculated\r\n         * the duration by this step.\r\n         */\r\n        if (generator.calculatedDuration === null) {\r\n            generator.calculatedDuration = calcGeneratorDuration(generator);\r\n        }\r\n        const { calculatedDuration } = generator;\r\n        const resolvedDuration = calculatedDuration + repeatDelay;\r\n        const totalDuration = resolvedDuration * (repeat + 1) - repeatDelay;\r\n        return {\r\n            generator,\r\n            mirroredGenerator,\r\n            mapPercentToKeyframes,\r\n            calculatedDuration,\r\n            resolvedDuration,\r\n            totalDuration,\r\n        };\r\n    }\r\n    onPostResolved() {\r\n        const { autoplay = true } = this.options;\r\n        activeAnimations.mainThread++;\r\n        this.play();\r\n        if (this.pendingPlayState === \"paused\" || !autoplay) {\r\n            this.pause();\r\n        }\r\n        else {\r\n            this.state = this.pendingPlayState;\r\n        }\r\n    }\r\n    tick(timestamp, sample = false) {\r\n        const { resolved } = this;\r\n        // If the animations has failed to resolve, return the final keyframe.\r\n        if (!resolved) {\r\n            const { keyframes } = this.options;\r\n            return { done: true, value: keyframes[keyframes.length - 1] };\r\n        }\r\n        const { finalKeyframe, generator, mirroredGenerator, mapPercentToKeyframes, keyframes, calculatedDuration, totalDuration, resolvedDuration, } = resolved;\r\n        if (this.startTime === null)\r\n            return generator.next(0);\r\n        const { delay, repeat, repeatType, repeatDelay, onUpdate } = this.options;\r\n        /**\r\n         * requestAnimationFrame timestamps can come through as lower than\r\n         * the startTime as set by performance.now(). Here we prevent this,\r\n         * though in the future it could be possible to make setting startTime\r\n         * a pending operation that gets resolved here.\r\n         */\r\n        if (this.speed > 0) {\r\n            this.startTime = Math.min(this.startTime, timestamp);\r\n        }\r\n        else if (this.speed < 0) {\r\n            this.startTime = Math.min(timestamp - totalDuration / this.speed, this.startTime);\r\n        }\r\n        // Update currentTime\r\n        if (sample) {\r\n            this.currentTime = timestamp;\r\n        }\r\n        else if (this.holdTime !== null) {\r\n            this.currentTime = this.holdTime;\r\n        }\r\n        else {\r\n            // Rounding the time because floating point arithmetic is not always accurate, e.g. 3000.367 - 1000.367 =\r\n            // 2000.0000000000002. This is a problem when we are comparing the currentTime with the duration, for\r\n            // example.\r\n            this.currentTime =\r\n                Math.round(timestamp - this.startTime) * this.speed;\r\n        }\r\n        // Rebase on delay\r\n        const timeWithoutDelay = this.currentTime - delay * (this.speed >= 0 ? 1 : -1);\r\n        const isInDelayPhase = this.speed >= 0\r\n            ? timeWithoutDelay < 0\r\n            : timeWithoutDelay > totalDuration;\r\n        this.currentTime = Math.max(timeWithoutDelay, 0);\r\n        // If this animation has finished, set the current time  to the total duration.\r\n        if (this.state === \"finished\" && this.holdTime === null) {\r\n            this.currentTime = totalDuration;\r\n        }\r\n        let elapsed = this.currentTime;\r\n        let frameGenerator = generator;\r\n        if (repeat) {\r\n            /**\r\n             * Get the current progress (0-1) of the animation. If t is >\r\n             * than duration we'll get values like 2.5 (midway through the\r\n             * third iteration)\r\n             */\r\n            const progress = Math.min(this.currentTime, totalDuration) / resolvedDuration;\r\n            /**\r\n             * Get the current iteration (0 indexed). For instance the floor of\r\n             * 2.5 is 2.\r\n             */\r\n            let currentIteration = Math.floor(progress);\r\n            /**\r\n             * Get the current progress of the iteration by taking the remainder\r\n             * so 2.5 is 0.5 through iteration 2\r\n             */\r\n            let iterationProgress = progress % 1.0;\r\n            /**\r\n             * If iteration progress is 1 we count that as the end\r\n             * of the previous iteration.\r\n             */\r\n            if (!iterationProgress && progress >= 1) {\r\n                iterationProgress = 1;\r\n            }\r\n            iterationProgress === 1 && currentIteration--;\r\n            currentIteration = Math.min(currentIteration, repeat + 1);\r\n            /**\r\n             * Reverse progress if we're not running in \"normal\" direction\r\n             */\r\n            const isOddIteration = Boolean(currentIteration % 2);\r\n            if (isOddIteration) {\r\n                if (repeatType === \"reverse\") {\r\n                    iterationProgress = 1 - iterationProgress;\r\n                    if (repeatDelay) {\r\n                        iterationProgress -= repeatDelay / resolvedDuration;\r\n                    }\r\n                }\r\n                else if (repeatType === \"mirror\") {\r\n                    frameGenerator = mirroredGenerator;\r\n                }\r\n            }\r\n            elapsed = clamp(0, 1, iterationProgress) * resolvedDuration;\r\n        }\r\n        /**\r\n         * If we're in negative time, set state as the initial keyframe.\r\n         * This prevents delay: x, duration: 0 animations from finishing\r\n         * instantly.\r\n         */\r\n        const state = isInDelayPhase\r\n            ? { done: false, value: keyframes[0] }\r\n            : frameGenerator.next(elapsed);\r\n        if (mapPercentToKeyframes) {\r\n            state.value = mapPercentToKeyframes(state.value);\r\n        }\r\n        let { done } = state;\r\n        if (!isInDelayPhase && calculatedDuration !== null) {\r\n            done =\r\n                this.speed >= 0\r\n                    ? this.currentTime >= totalDuration\r\n                    : this.currentTime <= 0;\r\n        }\r\n        const isAnimationFinished = this.holdTime === null &&\r\n            (this.state === \"finished\" || (this.state === \"running\" && done));\r\n        if (isAnimationFinished && finalKeyframe !== undefined) {\r\n            state.value = getFinalKeyframe(keyframes, this.options, finalKeyframe);\r\n        }\r\n        if (onUpdate) {\r\n            onUpdate(state.value);\r\n        }\r\n        if (isAnimationFinished) {\r\n            this.finish();\r\n        }\r\n        return state;\r\n    }\r\n    get duration() {\r\n        const { resolved } = this;\r\n        return resolved ? millisecondsToSeconds(resolved.calculatedDuration) : 0;\r\n    }\r\n    get time() {\r\n        return millisecondsToSeconds(this.currentTime);\r\n    }\r\n    set time(newTime) {\r\n        newTime = secondsToMilliseconds(newTime);\r\n        this.currentTime = newTime;\r\n        if (this.holdTime !== null || this.speed === 0) {\r\n            this.holdTime = newTime;\r\n        }\r\n        else if (this.driver) {\r\n            this.startTime = this.driver.now() - newTime / this.speed;\r\n        }\r\n    }\r\n    get speed() {\r\n        return this.playbackSpeed;\r\n    }\r\n    set speed(newSpeed) {\r\n        const hasChanged = this.playbackSpeed !== newSpeed;\r\n        this.playbackSpeed = newSpeed;\r\n        if (hasChanged) {\r\n            this.time = millisecondsToSeconds(this.currentTime);\r\n        }\r\n    }\r\n    play() {\r\n        if (!this.resolver.isScheduled) {\r\n            this.resolver.resume();\r\n        }\r\n        if (!this._resolved) {\r\n            this.pendingPlayState = \"running\";\r\n            return;\r\n        }\r\n        if (this.isStopped)\r\n            return;\r\n        const { driver = frameloopDriver, onPlay, startTime } = this.options;\r\n        if (!this.driver) {\r\n            this.driver = driver((timestamp) => this.tick(timestamp));\r\n        }\r\n        onPlay && onPlay();\r\n        const now = this.driver.now();\r\n        if (this.holdTime !== null) {\r\n            this.startTime = now - this.holdTime;\r\n        }\r\n        else if (!this.startTime) {\r\n            this.startTime = startTime !== null && startTime !== void 0 ? startTime : this.calcStartTime();\r\n        }\r\n        else if (this.state === \"finished\") {\r\n            this.startTime = now;\r\n        }\r\n        if (this.state === \"finished\") {\r\n            this.updateFinishedPromise();\r\n        }\r\n        this.cancelTime = this.startTime;\r\n        this.holdTime = null;\r\n        /**\r\n         * Set playState to running only after we've used it in\r\n         * the previous logic.\r\n         */\r\n        this.state = \"running\";\r\n        this.driver.start();\r\n    }\r\n    pause() {\r\n        var _a;\r\n        if (!this._resolved) {\r\n            this.pendingPlayState = \"paused\";\r\n            return;\r\n        }\r\n        this.state = \"paused\";\r\n        this.holdTime = (_a = this.currentTime) !== null && _a !== void 0 ? _a : 0;\r\n    }\r\n    complete() {\r\n        if (this.state !== \"running\") {\r\n            this.play();\r\n        }\r\n        this.pendingPlayState = this.state = \"finished\";\r\n        this.holdTime = null;\r\n    }\r\n    finish() {\r\n        this.teardown();\r\n        this.state = \"finished\";\r\n        const { onComplete } = this.options;\r\n        onComplete && onComplete();\r\n    }\r\n    cancel() {\r\n        if (this.cancelTime !== null) {\r\n            this.tick(this.cancelTime);\r\n        }\r\n        this.teardown();\r\n        this.updateFinishedPromise();\r\n    }\r\n    teardown() {\r\n        this.state = \"idle\";\r\n        this.stopDriver();\r\n        this.resolveFinishedPromise();\r\n        this.updateFinishedPromise();\r\n        this.startTime = this.cancelTime = null;\r\n        this.resolver.cancel();\r\n        activeAnimations.mainThread--;\r\n    }\r\n    stopDriver() {\r\n        if (!this.driver)\r\n            return;\r\n        this.driver.stop();\r\n        this.driver = undefined;\r\n    }\r\n    sample(time) {\r\n        this.startTime = 0;\r\n        return this.tick(time, true);\r\n    }\r\n}\r\n// Legacy interface\r\nfunction animateValue(options) {\r\n    return new MainThreadAnimation(options);\r\n}\r\n\r\nexport { MainThreadAnimation, animateValue };\r\n"]},"metadata":{},"sourceType":"module"}