{"ast":null,"code":"import { noop } from 'motion-utils';\nimport { startWaapiAnimation } from '../animators/waapi/index.mjs';\nimport { optimizedAppearDataId } from './data-id.mjs';\nimport { getOptimisedAppearId } from './get-appear-id.mjs';\nimport { handoffOptimizedAppearAnimation } from './handoff.mjs';\nimport { appearAnimationStore, appearComplete } from './store.mjs';\nimport { appearStoreId } from './store-id.mjs';\n/**\r\n * A single time to use across all animations to manually set startTime\r\n * and ensure they're all in sync.\r\n */\n\nlet startFrameTime;\n/**\r\n * A dummy animation to detect when Chrome is ready to start\r\n * painting the page and hold off from triggering the real animation\r\n * until then. We only need one animation to detect paint ready.\r\n *\r\n * https://bugs.chromium.org/p/chromium/issues/detail?id=1406850\r\n */\n\nlet readyAnimation;\n/**\r\n * Keep track of animations that were suspended vs cancelled so we\r\n * can easily resume them when we're done measuring layout.\r\n */\n\nconst suspendedAnimations = new Set();\n\nfunction resumeSuspendedAnimations() {\n  suspendedAnimations.forEach(data => {\n    data.animation.play();\n    data.animation.startTime = data.startTime;\n  });\n  suspendedAnimations.clear();\n}\n\nfunction startOptimizedAppearAnimation(element, name, keyframes, options, onReady) {\n  // Prevent optimised appear animations if Motion has already started animating.\n  if (window.MotionIsMounted) {\n    return;\n  }\n\n  const id = element.dataset[optimizedAppearDataId];\n  if (!id) return;\n  window.MotionHandoffAnimation = handoffOptimizedAppearAnimation;\n  const storeId = appearStoreId(id, name);\n\n  if (!readyAnimation) {\n    readyAnimation = startWaapiAnimation(element, name, [keyframes[0], keyframes[0]],\n    /**\r\n     * 10 secs is basically just a super-safe duration to give Chrome\r\n     * long enough to get the animation ready.\r\n     */\n    {\n      duration: 10000,\n      ease: \"linear\"\n    });\n    appearAnimationStore.set(storeId, {\n      animation: readyAnimation,\n      startTime: null\n    });\n    /**\r\n     * If there's no readyAnimation then there's been no instantiation\r\n     * of handoff animations.\r\n     */\n\n    window.MotionHandoffAnimation = handoffOptimizedAppearAnimation;\n\n    window.MotionHasOptimisedAnimation = (elementId, valueName) => {\n      if (!elementId) return false;\n      /**\r\n       * Keep a map of elementIds that have started animating. We check\r\n       * via ID instead of Element because of hydration errors and\r\n       * pre-hydration checks. We also actively record IDs as they start\r\n       * animating rather than simply checking for data-appear-id as\r\n       * this attrbute might be present but not lead to an animation, for\r\n       * instance if the element's appear animation is on a different\r\n       * breakpoint.\r\n       */\n\n      if (!valueName) {\n        return appearComplete.has(elementId);\n      }\n\n      const animationId = appearStoreId(elementId, valueName);\n      return Boolean(appearAnimationStore.get(animationId));\n    };\n\n    window.MotionHandoffMarkAsComplete = elementId => {\n      if (appearComplete.has(elementId)) {\n        appearComplete.set(elementId, true);\n      }\n    };\n\n    window.MotionHandoffIsComplete = elementId => {\n      return appearComplete.get(elementId) === true;\n    };\n    /**\r\n     * We only need to cancel transform animations as\r\n     * they're the ones that will interfere with the\r\n     * layout animation measurements.\r\n     */\n\n\n    window.MotionCancelOptimisedAnimation = (elementId, valueName, frame, canResume) => {\n      const animationId = appearStoreId(elementId, valueName);\n      const data = appearAnimationStore.get(animationId);\n      if (!data) return;\n\n      if (frame && canResume === undefined) {\n        /**\r\n         * Wait until the end of the subsequent frame to cancel the animation\r\n         * to ensure we don't remove the animation before the main thread has\r\n         * had a chance to resolve keyframes and render.\r\n         */\n        frame.postRender(() => {\n          frame.postRender(() => {\n            data.animation.cancel();\n          });\n        });\n      } else {\n        data.animation.cancel();\n      }\n\n      if (frame && canResume) {\n        suspendedAnimations.add(data);\n        frame.render(resumeSuspendedAnimations);\n      } else {\n        appearAnimationStore.delete(animationId);\n        /**\r\n         * If there are no more animations left, we can remove the cancel function.\r\n         * This will let us know when we can stop checking for conflicting layout animations.\r\n         */\n\n        if (!appearAnimationStore.size) {\n          window.MotionCancelOptimisedAnimation = undefined;\n        }\n      }\n    };\n\n    window.MotionCheckAppearSync = (visualElement, valueName, value) => {\n      var _a, _b;\n\n      const appearId = getOptimisedAppearId(visualElement);\n      if (!appearId) return;\n      const valueIsOptimised = (_a = window.MotionHasOptimisedAnimation) === null || _a === void 0 ? void 0 : _a.call(window, appearId, valueName);\n      const externalAnimationValue = (_b = visualElement.props.values) === null || _b === void 0 ? void 0 : _b[valueName];\n      if (!valueIsOptimised || !externalAnimationValue) return;\n      const removeSyncCheck = value.on(\"change\", latestValue => {\n        var _a;\n\n        if (externalAnimationValue.get() !== latestValue) {\n          (_a = window.MotionCancelOptimisedAnimation) === null || _a === void 0 ? void 0 : _a.call(window, appearId, valueName);\n          removeSyncCheck();\n        }\n      });\n      return removeSyncCheck;\n    };\n  }\n\n  const startAnimation = () => {\n    readyAnimation.cancel();\n    const appearAnimation = startWaapiAnimation(element, name, keyframes, options);\n    /**\r\n     * Record the time of the first started animation. We call performance.now() once\r\n     * here and once in handoff to ensure we're getting\r\n     * close to a frame-locked time. This keeps all animations in sync.\r\n     */\n\n    if (startFrameTime === undefined) {\n      startFrameTime = performance.now();\n    }\n\n    appearAnimation.startTime = startFrameTime;\n    appearAnimationStore.set(storeId, {\n      animation: appearAnimation,\n      startTime: startFrameTime\n    });\n    if (onReady) onReady(appearAnimation);\n  };\n\n  appearComplete.set(id, false);\n\n  if (readyAnimation.ready) {\n    readyAnimation.ready.then(startAnimation).catch(noop);\n  } else {\n    startAnimation();\n  }\n}\n\nexport { startOptimizedAppearAnimation };","map":{"version":3,"sources":["C:/Users/PC/Documents/PROGRAMMING/New folder/MERN-BF/frontend/node_modules/framer-motion/dist/es/animation/optimized-appear/start.mjs"],"names":["noop","startWaapiAnimation","optimizedAppearDataId","getOptimisedAppearId","handoffOptimizedAppearAnimation","appearAnimationStore","appearComplete","appearStoreId","startFrameTime","readyAnimation","suspendedAnimations","Set","resumeSuspendedAnimations","forEach","data","animation","play","startTime","clear","startOptimizedAppearAnimation","element","name","keyframes","options","onReady","window","MotionIsMounted","id","dataset","MotionHandoffAnimation","storeId","duration","ease","set","MotionHasOptimisedAnimation","elementId","valueName","has","animationId","Boolean","get","MotionHandoffMarkAsComplete","MotionHandoffIsComplete","MotionCancelOptimisedAnimation","frame","canResume","undefined","postRender","cancel","add","render","delete","size","MotionCheckAppearSync","visualElement","value","_a","_b","appearId","valueIsOptimised","call","externalAnimationValue","props","values","removeSyncCheck","on","latestValue","startAnimation","appearAnimation","performance","now","ready","then","catch"],"mappings":"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","sourcesContent":["import { noop } from 'motion-utils';\r\nimport { startWaapiAnimation } from '../animators/waapi/index.mjs';\r\nimport { optimizedAppearDataId } from './data-id.mjs';\r\nimport { getOptimisedAppearId } from './get-appear-id.mjs';\r\nimport { handoffOptimizedAppearAnimation } from './handoff.mjs';\r\nimport { appearAnimationStore, appearComplete } from './store.mjs';\r\nimport { appearStoreId } from './store-id.mjs';\r\n\r\n/**\r\n * A single time to use across all animations to manually set startTime\r\n * and ensure they're all in sync.\r\n */\r\nlet startFrameTime;\r\n/**\r\n * A dummy animation to detect when Chrome is ready to start\r\n * painting the page and hold off from triggering the real animation\r\n * until then. We only need one animation to detect paint ready.\r\n *\r\n * https://bugs.chromium.org/p/chromium/issues/detail?id=1406850\r\n */\r\nlet readyAnimation;\r\n/**\r\n * Keep track of animations that were suspended vs cancelled so we\r\n * can easily resume them when we're done measuring layout.\r\n */\r\nconst suspendedAnimations = new Set();\r\nfunction resumeSuspendedAnimations() {\r\n    suspendedAnimations.forEach((data) => {\r\n        data.animation.play();\r\n        data.animation.startTime = data.startTime;\r\n    });\r\n    suspendedAnimations.clear();\r\n}\r\nfunction startOptimizedAppearAnimation(element, name, keyframes, options, onReady) {\r\n    // Prevent optimised appear animations if Motion has already started animating.\r\n    if (window.MotionIsMounted) {\r\n        return;\r\n    }\r\n    const id = element.dataset[optimizedAppearDataId];\r\n    if (!id)\r\n        return;\r\n    window.MotionHandoffAnimation = handoffOptimizedAppearAnimation;\r\n    const storeId = appearStoreId(id, name);\r\n    if (!readyAnimation) {\r\n        readyAnimation = startWaapiAnimation(element, name, [keyframes[0], keyframes[0]], \r\n        /**\r\n         * 10 secs is basically just a super-safe duration to give Chrome\r\n         * long enough to get the animation ready.\r\n         */\r\n        { duration: 10000, ease: \"linear\" });\r\n        appearAnimationStore.set(storeId, {\r\n            animation: readyAnimation,\r\n            startTime: null,\r\n        });\r\n        /**\r\n         * If there's no readyAnimation then there's been no instantiation\r\n         * of handoff animations.\r\n         */\r\n        window.MotionHandoffAnimation = handoffOptimizedAppearAnimation;\r\n        window.MotionHasOptimisedAnimation = (elementId, valueName) => {\r\n            if (!elementId)\r\n                return false;\r\n            /**\r\n             * Keep a map of elementIds that have started animating. We check\r\n             * via ID instead of Element because of hydration errors and\r\n             * pre-hydration checks. We also actively record IDs as they start\r\n             * animating rather than simply checking for data-appear-id as\r\n             * this attrbute might be present but not lead to an animation, for\r\n             * instance if the element's appear animation is on a different\r\n             * breakpoint.\r\n             */\r\n            if (!valueName) {\r\n                return appearComplete.has(elementId);\r\n            }\r\n            const animationId = appearStoreId(elementId, valueName);\r\n            return Boolean(appearAnimationStore.get(animationId));\r\n        };\r\n        window.MotionHandoffMarkAsComplete = (elementId) => {\r\n            if (appearComplete.has(elementId)) {\r\n                appearComplete.set(elementId, true);\r\n            }\r\n        };\r\n        window.MotionHandoffIsComplete = (elementId) => {\r\n            return appearComplete.get(elementId) === true;\r\n        };\r\n        /**\r\n         * We only need to cancel transform animations as\r\n         * they're the ones that will interfere with the\r\n         * layout animation measurements.\r\n         */\r\n        window.MotionCancelOptimisedAnimation = (elementId, valueName, frame, canResume) => {\r\n            const animationId = appearStoreId(elementId, valueName);\r\n            const data = appearAnimationStore.get(animationId);\r\n            if (!data)\r\n                return;\r\n            if (frame && canResume === undefined) {\r\n                /**\r\n                 * Wait until the end of the subsequent frame to cancel the animation\r\n                 * to ensure we don't remove the animation before the main thread has\r\n                 * had a chance to resolve keyframes and render.\r\n                 */\r\n                frame.postRender(() => {\r\n                    frame.postRender(() => {\r\n                        data.animation.cancel();\r\n                    });\r\n                });\r\n            }\r\n            else {\r\n                data.animation.cancel();\r\n            }\r\n            if (frame && canResume) {\r\n                suspendedAnimations.add(data);\r\n                frame.render(resumeSuspendedAnimations);\r\n            }\r\n            else {\r\n                appearAnimationStore.delete(animationId);\r\n                /**\r\n                 * If there are no more animations left, we can remove the cancel function.\r\n                 * This will let us know when we can stop checking for conflicting layout animations.\r\n                 */\r\n                if (!appearAnimationStore.size) {\r\n                    window.MotionCancelOptimisedAnimation = undefined;\r\n                }\r\n            }\r\n        };\r\n        window.MotionCheckAppearSync = (visualElement, valueName, value) => {\r\n            var _a, _b;\r\n            const appearId = getOptimisedAppearId(visualElement);\r\n            if (!appearId)\r\n                return;\r\n            const valueIsOptimised = (_a = window.MotionHasOptimisedAnimation) === null || _a === void 0 ? void 0 : _a.call(window, appearId, valueName);\r\n            const externalAnimationValue = (_b = visualElement.props.values) === null || _b === void 0 ? void 0 : _b[valueName];\r\n            if (!valueIsOptimised || !externalAnimationValue)\r\n                return;\r\n            const removeSyncCheck = value.on(\"change\", (latestValue) => {\r\n                var _a;\r\n                if (externalAnimationValue.get() !== latestValue) {\r\n                    (_a = window.MotionCancelOptimisedAnimation) === null || _a === void 0 ? void 0 : _a.call(window, appearId, valueName);\r\n                    removeSyncCheck();\r\n                }\r\n            });\r\n            return removeSyncCheck;\r\n        };\r\n    }\r\n    const startAnimation = () => {\r\n        readyAnimation.cancel();\r\n        const appearAnimation = startWaapiAnimation(element, name, keyframes, options);\r\n        /**\r\n         * Record the time of the first started animation. We call performance.now() once\r\n         * here and once in handoff to ensure we're getting\r\n         * close to a frame-locked time. This keeps all animations in sync.\r\n         */\r\n        if (startFrameTime === undefined) {\r\n            startFrameTime = performance.now();\r\n        }\r\n        appearAnimation.startTime = startFrameTime;\r\n        appearAnimationStore.set(storeId, {\r\n            animation: appearAnimation,\r\n            startTime: startFrameTime,\r\n        });\r\n        if (onReady)\r\n            onReady(appearAnimation);\r\n    };\r\n    appearComplete.set(id, false);\r\n    if (readyAnimation.ready) {\r\n        readyAnimation.ready.then(startAnimation).catch(noop);\r\n    }\r\n    else {\r\n        startAnimation();\r\n    }\r\n}\r\n\r\nexport { startOptimizedAppearAnimation };\r\n"]},"metadata":{},"sourceType":"module"}