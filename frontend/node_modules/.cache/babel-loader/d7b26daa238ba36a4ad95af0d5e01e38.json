{"ast":null,"code":"import { color } from '../color/index.mjs';\nimport { colorRegex } from '../utils/color-regex.mjs';\nimport { floatRegex } from '../utils/float-regex.mjs';\nimport { sanitize } from '../utils/sanitize.mjs';\n\nfunction test(v) {\n  var _a, _b;\n\n  return isNaN(v) && typeof v === \"string\" && (((_a = v.match(floatRegex)) === null || _a === void 0 ? void 0 : _a.length) || 0) + (((_b = v.match(colorRegex)) === null || _b === void 0 ? void 0 : _b.length) || 0) > 0;\n}\n\nconst NUMBER_TOKEN = \"number\";\nconst COLOR_TOKEN = \"color\";\nconst VAR_TOKEN = \"var\";\nconst VAR_FUNCTION_TOKEN = \"var(\";\nconst SPLIT_TOKEN = \"${}\"; // this regex consists of the `singleCssVariableRegex|rgbHSLValueRegex|digitRegex`\n\nconst complexRegex = /var\\s*\\(\\s*--(?:[\\w-]+\\s*|[\\w-]+\\s*,(?:\\s*[^)(\\s]|\\s*\\((?:[^)(]|\\([^)(]*\\))*\\))+\\s*)\\)|#[\\da-f]{3,8}|(?:rgb|hsl)a?\\((?:-?[\\d.]+%?[,\\s]+){2}-?[\\d.]+%?\\s*(?:[,/]\\s*)?(?:\\b\\d+(?:\\.\\d+)?|\\.\\d+)?%?\\)|-?(?:\\d+(?:\\.\\d+)?|\\.\\d+)/giu;\n\nfunction analyseComplexValue(value) {\n  const originalValue = value.toString();\n  const values = [];\n  const indexes = {\n    color: [],\n    number: [],\n    var: []\n  };\n  const types = [];\n  let i = 0;\n  const tokenised = originalValue.replace(complexRegex, parsedValue => {\n    if (color.test(parsedValue)) {\n      indexes.color.push(i);\n      types.push(COLOR_TOKEN);\n      values.push(color.parse(parsedValue));\n    } else if (parsedValue.startsWith(VAR_FUNCTION_TOKEN)) {\n      indexes.var.push(i);\n      types.push(VAR_TOKEN);\n      values.push(parsedValue);\n    } else {\n      indexes.number.push(i);\n      types.push(NUMBER_TOKEN);\n      values.push(parseFloat(parsedValue));\n    }\n\n    ++i;\n    return SPLIT_TOKEN;\n  });\n  const split = tokenised.split(SPLIT_TOKEN);\n  return {\n    values,\n    split,\n    indexes,\n    types\n  };\n}\n\nfunction parseComplexValue(v) {\n  return analyseComplexValue(v).values;\n}\n\nfunction createTransformer(source) {\n  const {\n    split,\n    types\n  } = analyseComplexValue(source);\n  const numSections = split.length;\n  return v => {\n    let output = \"\";\n\n    for (let i = 0; i < numSections; i++) {\n      output += split[i];\n\n      if (v[i] !== undefined) {\n        const type = types[i];\n\n        if (type === NUMBER_TOKEN) {\n          output += sanitize(v[i]);\n        } else if (type === COLOR_TOKEN) {\n          output += color.transform(v[i]);\n        } else {\n          output += v[i];\n        }\n      }\n    }\n\n    return output;\n  };\n}\n\nconst convertNumbersToZero = v => typeof v === \"number\" ? 0 : v;\n\nfunction getAnimatableNone(v) {\n  const parsed = parseComplexValue(v);\n  const transformer = createTransformer(v);\n  return transformer(parsed.map(convertNumbersToZero));\n}\n\nconst complex = {\n  test,\n  parse: parseComplexValue,\n  createTransformer,\n  getAnimatableNone\n};\nexport { analyseComplexValue, complex };","map":{"version":3,"sources":["C:/Users/PC/Documents/PROGRAMMING/New folder/MERN-BF/frontend/node_modules/framer-motion/dist/es/value/types/complex/index.mjs"],"names":["color","colorRegex","floatRegex","sanitize","test","v","_a","_b","isNaN","match","length","NUMBER_TOKEN","COLOR_TOKEN","VAR_TOKEN","VAR_FUNCTION_TOKEN","SPLIT_TOKEN","complexRegex","analyseComplexValue","value","originalValue","toString","values","indexes","number","var","types","i","tokenised","replace","parsedValue","push","parse","startsWith","parseFloat","split","parseComplexValue","createTransformer","source","numSections","output","undefined","type","transform","convertNumbersToZero","getAnimatableNone","parsed","transformer","map","complex"],"mappings":"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","sourcesContent":["import { color } from '../color/index.mjs';\r\nimport { colorRegex } from '../utils/color-regex.mjs';\r\nimport { floatRegex } from '../utils/float-regex.mjs';\r\nimport { sanitize } from '../utils/sanitize.mjs';\r\n\r\nfunction test(v) {\r\n    var _a, _b;\r\n    return (isNaN(v) &&\r\n        typeof v === \"string\" &&\r\n        (((_a = v.match(floatRegex)) === null || _a === void 0 ? void 0 : _a.length) || 0) +\r\n            (((_b = v.match(colorRegex)) === null || _b === void 0 ? void 0 : _b.length) || 0) >\r\n            0);\r\n}\r\nconst NUMBER_TOKEN = \"number\";\r\nconst COLOR_TOKEN = \"color\";\r\nconst VAR_TOKEN = \"var\";\r\nconst VAR_FUNCTION_TOKEN = \"var(\";\r\nconst SPLIT_TOKEN = \"${}\";\r\n// this regex consists of the `singleCssVariableRegex|rgbHSLValueRegex|digitRegex`\r\nconst complexRegex = /var\\s*\\(\\s*--(?:[\\w-]+\\s*|[\\w-]+\\s*,(?:\\s*[^)(\\s]|\\s*\\((?:[^)(]|\\([^)(]*\\))*\\))+\\s*)\\)|#[\\da-f]{3,8}|(?:rgb|hsl)a?\\((?:-?[\\d.]+%?[,\\s]+){2}-?[\\d.]+%?\\s*(?:[,/]\\s*)?(?:\\b\\d+(?:\\.\\d+)?|\\.\\d+)?%?\\)|-?(?:\\d+(?:\\.\\d+)?|\\.\\d+)/giu;\r\nfunction analyseComplexValue(value) {\r\n    const originalValue = value.toString();\r\n    const values = [];\r\n    const indexes = {\r\n        color: [],\r\n        number: [],\r\n        var: [],\r\n    };\r\n    const types = [];\r\n    let i = 0;\r\n    const tokenised = originalValue.replace(complexRegex, (parsedValue) => {\r\n        if (color.test(parsedValue)) {\r\n            indexes.color.push(i);\r\n            types.push(COLOR_TOKEN);\r\n            values.push(color.parse(parsedValue));\r\n        }\r\n        else if (parsedValue.startsWith(VAR_FUNCTION_TOKEN)) {\r\n            indexes.var.push(i);\r\n            types.push(VAR_TOKEN);\r\n            values.push(parsedValue);\r\n        }\r\n        else {\r\n            indexes.number.push(i);\r\n            types.push(NUMBER_TOKEN);\r\n            values.push(parseFloat(parsedValue));\r\n        }\r\n        ++i;\r\n        return SPLIT_TOKEN;\r\n    });\r\n    const split = tokenised.split(SPLIT_TOKEN);\r\n    return { values, split, indexes, types };\r\n}\r\nfunction parseComplexValue(v) {\r\n    return analyseComplexValue(v).values;\r\n}\r\nfunction createTransformer(source) {\r\n    const { split, types } = analyseComplexValue(source);\r\n    const numSections = split.length;\r\n    return (v) => {\r\n        let output = \"\";\r\n        for (let i = 0; i < numSections; i++) {\r\n            output += split[i];\r\n            if (v[i] !== undefined) {\r\n                const type = types[i];\r\n                if (type === NUMBER_TOKEN) {\r\n                    output += sanitize(v[i]);\r\n                }\r\n                else if (type === COLOR_TOKEN) {\r\n                    output += color.transform(v[i]);\r\n                }\r\n                else {\r\n                    output += v[i];\r\n                }\r\n            }\r\n        }\r\n        return output;\r\n    };\r\n}\r\nconst convertNumbersToZero = (v) => typeof v === \"number\" ? 0 : v;\r\nfunction getAnimatableNone(v) {\r\n    const parsed = parseComplexValue(v);\r\n    const transformer = createTransformer(v);\r\n    return transformer(parsed.map(convertNumbersToZero));\r\n}\r\nconst complex = {\r\n    test,\r\n    parse: parseComplexValue,\r\n    createTransformer,\r\n    getAnimatableNone,\r\n};\r\n\r\nexport { analyseComplexValue, complex };\r\n"]},"metadata":{},"sourceType":"module"}