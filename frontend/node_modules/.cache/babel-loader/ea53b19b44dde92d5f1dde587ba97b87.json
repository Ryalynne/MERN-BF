{"ast":null,"code":"import { statsBuffer } from '../stats/buffer.mjs';\n\nfunction createRenderStep(runNextFrame, stepName) {\n  /**\r\n   * We create and reuse two queues, one to queue jobs for the current frame\r\n   * and one for the next. We reuse to avoid triggering GC after x frames.\r\n   */\n  let thisFrame = new Set();\n  let nextFrame = new Set();\n  /**\r\n   * Track whether we're currently processing jobs in this step. This way\r\n   * we can decide whether to schedule new jobs for this frame or next.\r\n   */\n\n  let isProcessing = false;\n  let flushNextFrame = false;\n  /**\r\n   * A set of processes which were marked keepAlive when scheduled.\r\n   */\n\n  const toKeepAlive = new WeakSet();\n  let latestFrameData = {\n    delta: 0.0,\n    timestamp: 0.0,\n    isProcessing: false\n  };\n  let numCalls = 0;\n\n  function triggerCallback(callback) {\n    if (toKeepAlive.has(callback)) {\n      step.schedule(callback);\n      runNextFrame();\n    }\n\n    numCalls++;\n    callback(latestFrameData);\n  }\n\n  const step = {\n    /**\r\n     * Schedule a process to run on the next frame.\r\n     */\n    schedule: function (callback) {\n      let keepAlive = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      let immediate = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n      const addToCurrentFrame = immediate && isProcessing;\n      const queue = addToCurrentFrame ? thisFrame : nextFrame;\n      if (keepAlive) toKeepAlive.add(callback);\n      if (!queue.has(callback)) queue.add(callback);\n      return callback;\n    },\n\n    /**\r\n     * Cancel the provided callback from running on the next frame.\r\n     */\n    cancel: callback => {\n      nextFrame.delete(callback);\n      toKeepAlive.delete(callback);\n    },\n\n    /**\r\n     * Execute all schedule callbacks.\r\n     */\n    process: frameData => {\n      latestFrameData = frameData;\n      /**\r\n       * If we're already processing we've probably been triggered by a flushSync\r\n       * inside an existing process. Instead of executing, mark flushNextFrame\r\n       * as true and ensure we flush the following frame at the end of this one.\r\n       */\n\n      if (isProcessing) {\n        flushNextFrame = true;\n        return;\n      }\n\n      isProcessing = true;\n      [thisFrame, nextFrame] = [nextFrame, thisFrame]; // Execute this frame\n\n      thisFrame.forEach(triggerCallback);\n      /**\r\n       * If we're recording stats then\r\n       */\n\n      if (stepName && statsBuffer.value) {\n        statsBuffer.value.frameloop[stepName].push(numCalls);\n      }\n\n      numCalls = 0; // Clear the frame so no callbacks remain. This is to avoid\n      // memory leaks should this render step not run for a while.\n\n      thisFrame.clear();\n      isProcessing = false;\n\n      if (flushNextFrame) {\n        flushNextFrame = false;\n        step.process(frameData);\n      }\n    }\n  };\n  return step;\n}\n\nexport { createRenderStep };","map":{"version":3,"sources":["C:/Users/PC/Documents/PROGRAMMING/New folder/MERN-BF/frontend/node_modules/motion-dom/dist/es/frameloop/render-step.mjs"],"names":["statsBuffer","createRenderStep","runNextFrame","stepName","thisFrame","Set","nextFrame","isProcessing","flushNextFrame","toKeepAlive","WeakSet","latestFrameData","delta","timestamp","numCalls","triggerCallback","callback","has","step","schedule","keepAlive","immediate","addToCurrentFrame","queue","add","cancel","delete","process","frameData","forEach","value","frameloop","push","clear"],"mappings":"AAAA,SAASA,WAAT,QAA4B,qBAA5B;;AAEA,SAASC,gBAAT,CAA0BC,YAA1B,EAAwCC,QAAxC,EAAkD;AAC9C;AACJ;AACA;AACA;AACI,MAAIC,SAAS,GAAG,IAAIC,GAAJ,EAAhB;AACA,MAAIC,SAAS,GAAG,IAAID,GAAJ,EAAhB;AACA;AACJ;AACA;AACA;;AACI,MAAIE,YAAY,GAAG,KAAnB;AACA,MAAIC,cAAc,GAAG,KAArB;AACA;AACJ;AACA;;AACI,QAAMC,WAAW,GAAG,IAAIC,OAAJ,EAApB;AACA,MAAIC,eAAe,GAAG;AAClBC,IAAAA,KAAK,EAAE,GADW;AAElBC,IAAAA,SAAS,EAAE,GAFO;AAGlBN,IAAAA,YAAY,EAAE;AAHI,GAAtB;AAKA,MAAIO,QAAQ,GAAG,CAAf;;AACA,WAASC,eAAT,CAAyBC,QAAzB,EAAmC;AAC/B,QAAIP,WAAW,CAACQ,GAAZ,CAAgBD,QAAhB,CAAJ,EAA+B;AAC3BE,MAAAA,IAAI,CAACC,QAAL,CAAcH,QAAd;AACAd,MAAAA,YAAY;AACf;;AACDY,IAAAA,QAAQ;AACRE,IAAAA,QAAQ,CAACL,eAAD,CAAR;AACH;;AACD,QAAMO,IAAI,GAAG;AACT;AACR;AACA;AACQC,IAAAA,QAAQ,EAAE,UAACH,QAAD,EAAoD;AAAA,UAAzCI,SAAyC,uEAA7B,KAA6B;AAAA,UAAtBC,SAAsB,uEAAV,KAAU;AAC1D,YAAMC,iBAAiB,GAAGD,SAAS,IAAId,YAAvC;AACA,YAAMgB,KAAK,GAAGD,iBAAiB,GAAGlB,SAAH,GAAeE,SAA9C;AACA,UAAIc,SAAJ,EACIX,WAAW,CAACe,GAAZ,CAAgBR,QAAhB;AACJ,UAAI,CAACO,KAAK,CAACN,GAAN,CAAUD,QAAV,CAAL,EACIO,KAAK,CAACC,GAAN,CAAUR,QAAV;AACJ,aAAOA,QAAP;AACH,KAZQ;;AAaT;AACR;AACA;AACQS,IAAAA,MAAM,EAAGT,QAAD,IAAc;AAClBV,MAAAA,SAAS,CAACoB,MAAV,CAAiBV,QAAjB;AACAP,MAAAA,WAAW,CAACiB,MAAZ,CAAmBV,QAAnB;AACH,KAnBQ;;AAoBT;AACR;AACA;AACQW,IAAAA,OAAO,EAAGC,SAAD,IAAe;AACpBjB,MAAAA,eAAe,GAAGiB,SAAlB;AACA;AACZ;AACA;AACA;AACA;;AACY,UAAIrB,YAAJ,EAAkB;AACdC,QAAAA,cAAc,GAAG,IAAjB;AACA;AACH;;AACDD,MAAAA,YAAY,GAAG,IAAf;AACA,OAACH,SAAD,EAAYE,SAAZ,IAAyB,CAACA,SAAD,EAAYF,SAAZ,CAAzB,CAZoB,CAapB;;AACAA,MAAAA,SAAS,CAACyB,OAAV,CAAkBd,eAAlB;AACA;AACZ;AACA;;AACY,UAAIZ,QAAQ,IAAIH,WAAW,CAAC8B,KAA5B,EAAmC;AAC/B9B,QAAAA,WAAW,CAAC8B,KAAZ,CAAkBC,SAAlB,CAA4B5B,QAA5B,EAAsC6B,IAAtC,CAA2ClB,QAA3C;AACH;;AACDA,MAAAA,QAAQ,GAAG,CAAX,CArBoB,CAsBpB;AACA;;AACAV,MAAAA,SAAS,CAAC6B,KAAV;AACA1B,MAAAA,YAAY,GAAG,KAAf;;AACA,UAAIC,cAAJ,EAAoB;AAChBA,QAAAA,cAAc,GAAG,KAAjB;AACAU,QAAAA,IAAI,CAACS,OAAL,CAAaC,SAAb;AACH;AACJ;AArDQ,GAAb;AAuDA,SAAOV,IAAP;AACH;;AAED,SAASjB,gBAAT","sourcesContent":["import { statsBuffer } from '../stats/buffer.mjs';\r\n\r\nfunction createRenderStep(runNextFrame, stepName) {\r\n    /**\r\n     * We create and reuse two queues, one to queue jobs for the current frame\r\n     * and one for the next. We reuse to avoid triggering GC after x frames.\r\n     */\r\n    let thisFrame = new Set();\r\n    let nextFrame = new Set();\r\n    /**\r\n     * Track whether we're currently processing jobs in this step. This way\r\n     * we can decide whether to schedule new jobs for this frame or next.\r\n     */\r\n    let isProcessing = false;\r\n    let flushNextFrame = false;\r\n    /**\r\n     * A set of processes which were marked keepAlive when scheduled.\r\n     */\r\n    const toKeepAlive = new WeakSet();\r\n    let latestFrameData = {\r\n        delta: 0.0,\r\n        timestamp: 0.0,\r\n        isProcessing: false,\r\n    };\r\n    let numCalls = 0;\r\n    function triggerCallback(callback) {\r\n        if (toKeepAlive.has(callback)) {\r\n            step.schedule(callback);\r\n            runNextFrame();\r\n        }\r\n        numCalls++;\r\n        callback(latestFrameData);\r\n    }\r\n    const step = {\r\n        /**\r\n         * Schedule a process to run on the next frame.\r\n         */\r\n        schedule: (callback, keepAlive = false, immediate = false) => {\r\n            const addToCurrentFrame = immediate && isProcessing;\r\n            const queue = addToCurrentFrame ? thisFrame : nextFrame;\r\n            if (keepAlive)\r\n                toKeepAlive.add(callback);\r\n            if (!queue.has(callback))\r\n                queue.add(callback);\r\n            return callback;\r\n        },\r\n        /**\r\n         * Cancel the provided callback from running on the next frame.\r\n         */\r\n        cancel: (callback) => {\r\n            nextFrame.delete(callback);\r\n            toKeepAlive.delete(callback);\r\n        },\r\n        /**\r\n         * Execute all schedule callbacks.\r\n         */\r\n        process: (frameData) => {\r\n            latestFrameData = frameData;\r\n            /**\r\n             * If we're already processing we've probably been triggered by a flushSync\r\n             * inside an existing process. Instead of executing, mark flushNextFrame\r\n             * as true and ensure we flush the following frame at the end of this one.\r\n             */\r\n            if (isProcessing) {\r\n                flushNextFrame = true;\r\n                return;\r\n            }\r\n            isProcessing = true;\r\n            [thisFrame, nextFrame] = [nextFrame, thisFrame];\r\n            // Execute this frame\r\n            thisFrame.forEach(triggerCallback);\r\n            /**\r\n             * If we're recording stats then\r\n             */\r\n            if (stepName && statsBuffer.value) {\r\n                statsBuffer.value.frameloop[stepName].push(numCalls);\r\n            }\r\n            numCalls = 0;\r\n            // Clear the frame so no callbacks remain. This is to avoid\r\n            // memory leaks should this render step not run for a while.\r\n            thisFrame.clear();\r\n            isProcessing = false;\r\n            if (flushNextFrame) {\r\n                flushNextFrame = false;\r\n                step.process(frameData);\r\n            }\r\n        },\r\n    };\r\n    return step;\r\n}\r\n\r\nexport { createRenderStep };\r\n"]},"metadata":{},"sourceType":"module"}