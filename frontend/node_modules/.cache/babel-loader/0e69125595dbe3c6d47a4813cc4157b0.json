{"ast":null,"code":"import { isNone } from '../../animation/utils/is-none.mjs';\nimport { positionalKeys } from '../html/utils/keys-position.mjs';\nimport { makeNoneKeyframesAnimatable } from '../html/utils/make-none-animatable.mjs';\nimport { KeyframeResolver } from '../utils/KeyframesResolver.mjs';\nimport { getVariableValue } from './utils/css-variables-conversion.mjs';\nimport { isCSSVariableToken } from './utils/is-css-variable.mjs';\nimport { isNumOrPxType, positionalValues } from './utils/unit-conversion.mjs';\nimport { findDimensionValueType } from './value-types/dimensions.mjs';\n\nclass DOMKeyframesResolver extends KeyframeResolver {\n  constructor(unresolvedKeyframes, onComplete, name, motionValue, element) {\n    super(unresolvedKeyframes, onComplete, name, motionValue, element, true);\n  }\n\n  readKeyframes() {\n    const {\n      unresolvedKeyframes,\n      element,\n      name\n    } = this;\n    if (!element || !element.current) return;\n    super.readKeyframes();\n    /**\r\n     * If any keyframe is a CSS variable, we need to find its value by sampling the element\r\n     */\n\n    for (let i = 0; i < unresolvedKeyframes.length; i++) {\n      let keyframe = unresolvedKeyframes[i];\n\n      if (typeof keyframe === \"string\") {\n        keyframe = keyframe.trim();\n\n        if (isCSSVariableToken(keyframe)) {\n          const resolved = getVariableValue(keyframe, element.current);\n\n          if (resolved !== undefined) {\n            unresolvedKeyframes[i] = resolved;\n          }\n\n          if (i === unresolvedKeyframes.length - 1) {\n            this.finalKeyframe = keyframe;\n          }\n        }\n      }\n    }\n    /**\r\n     * Resolve \"none\" values. We do this potentially twice - once before and once after measuring keyframes.\r\n     * This could be seen as inefficient but it's a trade-off to avoid measurements in more situations, which\r\n     * have a far bigger performance impact.\r\n     */\n\n\n    this.resolveNoneKeyframes();\n    /**\r\n     * Check to see if unit type has changed. If so schedule jobs that will\r\n     * temporarily set styles to the destination keyframes.\r\n     * Skip if we have more than two keyframes or this isn't a positional value.\r\n     * TODO: We can throw if there are multiple keyframes and the value type changes.\r\n     */\n\n    if (!positionalKeys.has(name) || unresolvedKeyframes.length !== 2) {\n      return;\n    }\n\n    const [origin, target] = unresolvedKeyframes;\n    const originType = findDimensionValueType(origin);\n    const targetType = findDimensionValueType(target);\n    /**\r\n     * Either we don't recognise these value types or we can animate between them.\r\n     */\n\n    if (originType === targetType) return;\n    /**\r\n     * If both values are numbers or pixels, we can animate between them by\r\n     * converting them to numbers.\r\n     */\n\n    if (isNumOrPxType(originType) && isNumOrPxType(targetType)) {\n      for (let i = 0; i < unresolvedKeyframes.length; i++) {\n        const value = unresolvedKeyframes[i];\n\n        if (typeof value === \"string\") {\n          unresolvedKeyframes[i] = parseFloat(value);\n        }\n      }\n    } else {\n      /**\r\n       * Else, the only way to resolve this is by measuring the element.\r\n       */\n      this.needsMeasurement = true;\n    }\n  }\n\n  resolveNoneKeyframes() {\n    const {\n      unresolvedKeyframes,\n      name\n    } = this;\n    const noneKeyframeIndexes = [];\n\n    for (let i = 0; i < unresolvedKeyframes.length; i++) {\n      if (isNone(unresolvedKeyframes[i])) {\n        noneKeyframeIndexes.push(i);\n      }\n    }\n\n    if (noneKeyframeIndexes.length) {\n      makeNoneKeyframesAnimatable(unresolvedKeyframes, noneKeyframeIndexes, name);\n    }\n  }\n\n  measureInitialState() {\n    const {\n      element,\n      unresolvedKeyframes,\n      name\n    } = this;\n    if (!element || !element.current) return;\n\n    if (name === \"height\") {\n      this.suspendedScrollY = window.pageYOffset;\n    }\n\n    this.measuredOrigin = positionalValues[name](element.measureViewportBox(), window.getComputedStyle(element.current));\n    unresolvedKeyframes[0] = this.measuredOrigin; // Set final key frame to measure after next render\n\n    const measureKeyframe = unresolvedKeyframes[unresolvedKeyframes.length - 1];\n\n    if (measureKeyframe !== undefined) {\n      element.getValue(name, measureKeyframe).jump(measureKeyframe, false);\n    }\n  }\n\n  measureEndState() {\n    var _a;\n\n    const {\n      element,\n      name,\n      unresolvedKeyframes\n    } = this;\n    if (!element || !element.current) return;\n    const value = element.getValue(name);\n    value && value.jump(this.measuredOrigin, false);\n    const finalKeyframeIndex = unresolvedKeyframes.length - 1;\n    const finalKeyframe = unresolvedKeyframes[finalKeyframeIndex];\n    unresolvedKeyframes[finalKeyframeIndex] = positionalValues[name](element.measureViewportBox(), window.getComputedStyle(element.current));\n\n    if (finalKeyframe !== null && this.finalKeyframe === undefined) {\n      this.finalKeyframe = finalKeyframe;\n    } // If we removed transform values, reapply them before the next render\n\n\n    if ((_a = this.removedTransforms) === null || _a === void 0 ? void 0 : _a.length) {\n      this.removedTransforms.forEach(_ref => {\n        let [unsetTransformName, unsetTransformValue] = _ref;\n        element.getValue(unsetTransformName).set(unsetTransformValue);\n      });\n    }\n\n    this.resolveNoneKeyframes();\n  }\n\n}\n\nexport { DOMKeyframesResolver };","map":{"version":3,"sources":["C:/Users/PC/Documents/PROGRAMMING/New folder/MERN-BF/frontend/node_modules/framer-motion/dist/es/render/dom/DOMKeyframesResolver.mjs"],"names":["isNone","positionalKeys","makeNoneKeyframesAnimatable","KeyframeResolver","getVariableValue","isCSSVariableToken","isNumOrPxType","positionalValues","findDimensionValueType","DOMKeyframesResolver","constructor","unresolvedKeyframes","onComplete","name","motionValue","element","readKeyframes","current","i","length","keyframe","trim","resolved","undefined","finalKeyframe","resolveNoneKeyframes","has","origin","target","originType","targetType","value","parseFloat","needsMeasurement","noneKeyframeIndexes","push","measureInitialState","suspendedScrollY","window","pageYOffset","measuredOrigin","measureViewportBox","getComputedStyle","measureKeyframe","getValue","jump","measureEndState","_a","finalKeyframeIndex","removedTransforms","forEach","unsetTransformName","unsetTransformValue","set"],"mappings":"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","sourcesContent":["import { isNone } from '../../animation/utils/is-none.mjs';\r\nimport { positionalKeys } from '../html/utils/keys-position.mjs';\r\nimport { makeNoneKeyframesAnimatable } from '../html/utils/make-none-animatable.mjs';\r\nimport { KeyframeResolver } from '../utils/KeyframesResolver.mjs';\r\nimport { getVariableValue } from './utils/css-variables-conversion.mjs';\r\nimport { isCSSVariableToken } from './utils/is-css-variable.mjs';\r\nimport { isNumOrPxType, positionalValues } from './utils/unit-conversion.mjs';\r\nimport { findDimensionValueType } from './value-types/dimensions.mjs';\r\n\r\nclass DOMKeyframesResolver extends KeyframeResolver {\r\n    constructor(unresolvedKeyframes, onComplete, name, motionValue, element) {\r\n        super(unresolvedKeyframes, onComplete, name, motionValue, element, true);\r\n    }\r\n    readKeyframes() {\r\n        const { unresolvedKeyframes, element, name } = this;\r\n        if (!element || !element.current)\r\n            return;\r\n        super.readKeyframes();\r\n        /**\r\n         * If any keyframe is a CSS variable, we need to find its value by sampling the element\r\n         */\r\n        for (let i = 0; i < unresolvedKeyframes.length; i++) {\r\n            let keyframe = unresolvedKeyframes[i];\r\n            if (typeof keyframe === \"string\") {\r\n                keyframe = keyframe.trim();\r\n                if (isCSSVariableToken(keyframe)) {\r\n                    const resolved = getVariableValue(keyframe, element.current);\r\n                    if (resolved !== undefined) {\r\n                        unresolvedKeyframes[i] = resolved;\r\n                    }\r\n                    if (i === unresolvedKeyframes.length - 1) {\r\n                        this.finalKeyframe = keyframe;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        /**\r\n         * Resolve \"none\" values. We do this potentially twice - once before and once after measuring keyframes.\r\n         * This could be seen as inefficient but it's a trade-off to avoid measurements in more situations, which\r\n         * have a far bigger performance impact.\r\n         */\r\n        this.resolveNoneKeyframes();\r\n        /**\r\n         * Check to see if unit type has changed. If so schedule jobs that will\r\n         * temporarily set styles to the destination keyframes.\r\n         * Skip if we have more than two keyframes or this isn't a positional value.\r\n         * TODO: We can throw if there are multiple keyframes and the value type changes.\r\n         */\r\n        if (!positionalKeys.has(name) || unresolvedKeyframes.length !== 2) {\r\n            return;\r\n        }\r\n        const [origin, target] = unresolvedKeyframes;\r\n        const originType = findDimensionValueType(origin);\r\n        const targetType = findDimensionValueType(target);\r\n        /**\r\n         * Either we don't recognise these value types or we can animate between them.\r\n         */\r\n        if (originType === targetType)\r\n            return;\r\n        /**\r\n         * If both values are numbers or pixels, we can animate between them by\r\n         * converting them to numbers.\r\n         */\r\n        if (isNumOrPxType(originType) && isNumOrPxType(targetType)) {\r\n            for (let i = 0; i < unresolvedKeyframes.length; i++) {\r\n                const value = unresolvedKeyframes[i];\r\n                if (typeof value === \"string\") {\r\n                    unresolvedKeyframes[i] = parseFloat(value);\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            /**\r\n             * Else, the only way to resolve this is by measuring the element.\r\n             */\r\n            this.needsMeasurement = true;\r\n        }\r\n    }\r\n    resolveNoneKeyframes() {\r\n        const { unresolvedKeyframes, name } = this;\r\n        const noneKeyframeIndexes = [];\r\n        for (let i = 0; i < unresolvedKeyframes.length; i++) {\r\n            if (isNone(unresolvedKeyframes[i])) {\r\n                noneKeyframeIndexes.push(i);\r\n            }\r\n        }\r\n        if (noneKeyframeIndexes.length) {\r\n            makeNoneKeyframesAnimatable(unresolvedKeyframes, noneKeyframeIndexes, name);\r\n        }\r\n    }\r\n    measureInitialState() {\r\n        const { element, unresolvedKeyframes, name } = this;\r\n        if (!element || !element.current)\r\n            return;\r\n        if (name === \"height\") {\r\n            this.suspendedScrollY = window.pageYOffset;\r\n        }\r\n        this.measuredOrigin = positionalValues[name](element.measureViewportBox(), window.getComputedStyle(element.current));\r\n        unresolvedKeyframes[0] = this.measuredOrigin;\r\n        // Set final key frame to measure after next render\r\n        const measureKeyframe = unresolvedKeyframes[unresolvedKeyframes.length - 1];\r\n        if (measureKeyframe !== undefined) {\r\n            element.getValue(name, measureKeyframe).jump(measureKeyframe, false);\r\n        }\r\n    }\r\n    measureEndState() {\r\n        var _a;\r\n        const { element, name, unresolvedKeyframes } = this;\r\n        if (!element || !element.current)\r\n            return;\r\n        const value = element.getValue(name);\r\n        value && value.jump(this.measuredOrigin, false);\r\n        const finalKeyframeIndex = unresolvedKeyframes.length - 1;\r\n        const finalKeyframe = unresolvedKeyframes[finalKeyframeIndex];\r\n        unresolvedKeyframes[finalKeyframeIndex] = positionalValues[name](element.measureViewportBox(), window.getComputedStyle(element.current));\r\n        if (finalKeyframe !== null && this.finalKeyframe === undefined) {\r\n            this.finalKeyframe = finalKeyframe;\r\n        }\r\n        // If we removed transform values, reapply them before the next render\r\n        if ((_a = this.removedTransforms) === null || _a === void 0 ? void 0 : _a.length) {\r\n            this.removedTransforms.forEach(([unsetTransformName, unsetTransformValue]) => {\r\n                element\r\n                    .getValue(unsetTransformName)\r\n                    .set(unsetTransformValue);\r\n            });\r\n        }\r\n        this.resolveNoneKeyframes();\r\n    }\r\n}\r\n\r\nexport { DOMKeyframesResolver };\r\n"]},"metadata":{},"sourceType":"module"}