{"ast":null,"code":"function calcInset(element, container) {\n  const inset = {\n    x: 0,\n    y: 0\n  };\n  let current = element;\n\n  while (current && current !== container) {\n    if (current instanceof HTMLElement) {\n      inset.x += current.offsetLeft;\n      inset.y += current.offsetTop;\n      current = current.offsetParent;\n    } else if (current.tagName === \"svg\") {\n      /**\r\n       * This isn't an ideal approach to measuring the offset of <svg /> tags.\r\n       * It would be preferable, given they behave like HTMLElements in most ways\r\n       * to use offsetLeft/Top. But these don't exist on <svg />. Likewise we\r\n       * can't use .getBBox() like most SVG elements as these provide the offset\r\n       * relative to the SVG itself, which for <svg /> is usually 0x0.\r\n       */\n      const svgBoundingBox = current.getBoundingClientRect();\n      current = current.parentElement;\n      const parentBoundingBox = current.getBoundingClientRect();\n      inset.x += svgBoundingBox.left - parentBoundingBox.left;\n      inset.y += svgBoundingBox.top - parentBoundingBox.top;\n    } else if (current instanceof SVGGraphicsElement) {\n      const {\n        x,\n        y\n      } = current.getBBox();\n      inset.x += x;\n      inset.y += y;\n      let svg = null;\n      let parent = current.parentNode;\n\n      while (!svg) {\n        if (parent.tagName === \"svg\") {\n          svg = parent;\n        }\n\n        parent = current.parentNode;\n      }\n\n      current = svg;\n    } else {\n      break;\n    }\n  }\n\n  return inset;\n}\n\nexport { calcInset };","map":{"version":3,"sources":["C:/Users/PC/Documents/PROGRAMMING/New folder/MERN-BF/frontend/node_modules/framer-motion/dist/es/render/dom/scroll/offsets/inset.mjs"],"names":["calcInset","element","container","inset","x","y","current","HTMLElement","offsetLeft","offsetTop","offsetParent","tagName","svgBoundingBox","getBoundingClientRect","parentElement","parentBoundingBox","left","top","SVGGraphicsElement","getBBox","svg","parent","parentNode"],"mappings":"AAAA,SAASA,SAAT,CAAmBC,OAAnB,EAA4BC,SAA5B,EAAuC;AACnC,QAAMC,KAAK,GAAG;AAAEC,IAAAA,CAAC,EAAE,CAAL;AAAQC,IAAAA,CAAC,EAAE;AAAX,GAAd;AACA,MAAIC,OAAO,GAAGL,OAAd;;AACA,SAAOK,OAAO,IAAIA,OAAO,KAAKJ,SAA9B,EAAyC;AACrC,QAAII,OAAO,YAAYC,WAAvB,EAAoC;AAChCJ,MAAAA,KAAK,CAACC,CAAN,IAAWE,OAAO,CAACE,UAAnB;AACAL,MAAAA,KAAK,CAACE,CAAN,IAAWC,OAAO,CAACG,SAAnB;AACAH,MAAAA,OAAO,GAAGA,OAAO,CAACI,YAAlB;AACH,KAJD,MAKK,IAAIJ,OAAO,CAACK,OAAR,KAAoB,KAAxB,EAA+B;AAChC;AACZ;AACA;AACA;AACA;AACA;AACA;AACY,YAAMC,cAAc,GAAGN,OAAO,CAACO,qBAAR,EAAvB;AACAP,MAAAA,OAAO,GAAGA,OAAO,CAACQ,aAAlB;AACA,YAAMC,iBAAiB,GAAGT,OAAO,CAACO,qBAAR,EAA1B;AACAV,MAAAA,KAAK,CAACC,CAAN,IAAWQ,cAAc,CAACI,IAAf,GAAsBD,iBAAiB,CAACC,IAAnD;AACAb,MAAAA,KAAK,CAACE,CAAN,IAAWO,cAAc,CAACK,GAAf,GAAqBF,iBAAiB,CAACE,GAAlD;AACH,KAbI,MAcA,IAAIX,OAAO,YAAYY,kBAAvB,EAA2C;AAC5C,YAAM;AAAEd,QAAAA,CAAF;AAAKC,QAAAA;AAAL,UAAWC,OAAO,CAACa,OAAR,EAAjB;AACAhB,MAAAA,KAAK,CAACC,CAAN,IAAWA,CAAX;AACAD,MAAAA,KAAK,CAACE,CAAN,IAAWA,CAAX;AACA,UAAIe,GAAG,GAAG,IAAV;AACA,UAAIC,MAAM,GAAGf,OAAO,CAACgB,UAArB;;AACA,aAAO,CAACF,GAAR,EAAa;AACT,YAAIC,MAAM,CAACV,OAAP,KAAmB,KAAvB,EAA8B;AAC1BS,UAAAA,GAAG,GAAGC,MAAN;AACH;;AACDA,QAAAA,MAAM,GAAGf,OAAO,CAACgB,UAAjB;AACH;;AACDhB,MAAAA,OAAO,GAAGc,GAAV;AACH,KAbI,MAcA;AACD;AACH;AACJ;;AACD,SAAOjB,KAAP;AACH;;AAED,SAASH,SAAT","sourcesContent":["function calcInset(element, container) {\r\n    const inset = { x: 0, y: 0 };\r\n    let current = element;\r\n    while (current && current !== container) {\r\n        if (current instanceof HTMLElement) {\r\n            inset.x += current.offsetLeft;\r\n            inset.y += current.offsetTop;\r\n            current = current.offsetParent;\r\n        }\r\n        else if (current.tagName === \"svg\") {\r\n            /**\r\n             * This isn't an ideal approach to measuring the offset of <svg /> tags.\r\n             * It would be preferable, given they behave like HTMLElements in most ways\r\n             * to use offsetLeft/Top. But these don't exist on <svg />. Likewise we\r\n             * can't use .getBBox() like most SVG elements as these provide the offset\r\n             * relative to the SVG itself, which for <svg /> is usually 0x0.\r\n             */\r\n            const svgBoundingBox = current.getBoundingClientRect();\r\n            current = current.parentElement;\r\n            const parentBoundingBox = current.getBoundingClientRect();\r\n            inset.x += svgBoundingBox.left - parentBoundingBox.left;\r\n            inset.y += svgBoundingBox.top - parentBoundingBox.top;\r\n        }\r\n        else if (current instanceof SVGGraphicsElement) {\r\n            const { x, y } = current.getBBox();\r\n            inset.x += x;\r\n            inset.y += y;\r\n            let svg = null;\r\n            let parent = current.parentNode;\r\n            while (!svg) {\r\n                if (parent.tagName === \"svg\") {\r\n                    svg = parent;\r\n                }\r\n                parent = current.parentNode;\r\n            }\r\n            current = svg;\r\n        }\r\n        else {\r\n            break;\r\n        }\r\n    }\r\n    return inset;\r\n}\r\n\r\nexport { calcInset };\r\n"]},"metadata":{},"sourceType":"module"}