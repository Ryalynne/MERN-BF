{"ast":null,"code":"import { animateVisualElement } from '../../animation/interfaces/visual-element.mjs';\nimport { isAnimationControls } from '../../animation/utils/is-animation-controls.mjs';\nimport { isKeyframesTarget } from '../../animation/utils/is-keyframes-target.mjs';\nimport { shallowCompare } from '../../utils/shallow-compare.mjs';\nimport { getVariantContext } from './get-variant-context.mjs';\nimport { isVariantLabel } from './is-variant-label.mjs';\nimport { resolveVariant } from './resolve-dynamic-variants.mjs';\nimport { variantPriorityOrder } from './variant-props.mjs';\nconst reversePriorityOrder = [...variantPriorityOrder].reverse();\nconst numAnimationTypes = variantPriorityOrder.length;\n\nfunction animateList(visualElement) {\n  return animations => Promise.all(animations.map(_ref => {\n    let {\n      animation,\n      options\n    } = _ref;\n    return animateVisualElement(visualElement, animation, options);\n  }));\n}\n\nfunction createAnimationState(visualElement) {\n  let animate = animateList(visualElement);\n  let state = createState();\n  let isInitialRender = true;\n  /**\r\n   * This function will be used to reduce the animation definitions for\r\n   * each active animation type into an object of resolved values for it.\r\n   */\n\n  const buildResolvedTypeValues = type => (acc, definition) => {\n    var _a;\n\n    const resolved = resolveVariant(visualElement, definition, type === \"exit\" ? (_a = visualElement.presenceContext) === null || _a === void 0 ? void 0 : _a.custom : undefined);\n\n    if (resolved) {\n      const {\n        transition,\n        transitionEnd,\n        ...target\n      } = resolved;\n      acc = { ...acc,\n        ...target,\n        ...transitionEnd\n      };\n    }\n\n    return acc;\n  };\n  /**\r\n   * This just allows us to inject mocked animation functions\r\n   * @internal\r\n   */\n\n\n  function setAnimateFunction(makeAnimator) {\n    animate = makeAnimator(visualElement);\n  }\n  /**\r\n   * When we receive new props, we need to:\r\n   * 1. Create a list of protected keys for each type. This is a directory of\r\n   *    value keys that are currently being \"handled\" by types of a higher priority\r\n   *    so that whenever an animation is played of a given type, these values are\r\n   *    protected from being animated.\r\n   * 2. Determine if an animation type needs animating.\r\n   * 3. Determine if any values have been removed from a type and figure out\r\n   *    what to animate those to.\r\n   */\n\n\n  function animateChanges(changedActiveType) {\n    const {\n      props\n    } = visualElement;\n    const context = getVariantContext(visualElement.parent) || {};\n    /**\r\n     * A list of animations that we'll build into as we iterate through the animation\r\n     * types. This will get executed at the end of the function.\r\n     */\n\n    const animations = [];\n    /**\r\n     * Keep track of which values have been removed. Then, as we hit lower priority\r\n     * animation types, we can check if they contain removed values and animate to that.\r\n     */\n\n    const removedKeys = new Set();\n    /**\r\n     * A dictionary of all encountered keys. This is an object to let us build into and\r\n     * copy it without iteration. Each time we hit an animation type we set its protected\r\n     * keys - the keys its not allowed to animate - to the latest version of this object.\r\n     */\n\n    let encounteredKeys = {};\n    /**\r\n     * If a variant has been removed at a given index, and this component is controlling\r\n     * variant animations, we want to ensure lower-priority variants are forced to animate.\r\n     */\n\n    let removedVariantIndex = Infinity;\n    /**\r\n     * Iterate through all animation types in reverse priority order. For each, we want to\r\n     * detect which values it's handling and whether or not they've changed (and therefore\r\n     * need to be animated). If any values have been removed, we want to detect those in\r\n     * lower priority props and flag for animation.\r\n     */\n\n    for (let i = 0; i < numAnimationTypes; i++) {\n      const type = reversePriorityOrder[i];\n      const typeState = state[type];\n      const prop = props[type] !== undefined ? props[type] : context[type];\n      const propIsVariant = isVariantLabel(prop);\n      /**\r\n       * If this type has *just* changed isActive status, set activeDelta\r\n       * to that status. Otherwise set to null.\r\n       */\n\n      const activeDelta = type === changedActiveType ? typeState.isActive : null;\n      if (activeDelta === false) removedVariantIndex = i;\n      /**\r\n       * If this prop is an inherited variant, rather than been set directly on the\r\n       * component itself, we want to make sure we allow the parent to trigger animations.\r\n       *\r\n       * TODO: Can probably change this to a !isControllingVariants check\r\n       */\n\n      let isInherited = prop === context[type] && prop !== props[type] && propIsVariant;\n      /**\r\n       *\r\n       */\n\n      if (isInherited && isInitialRender && visualElement.manuallyAnimateOnMount) {\n        isInherited = false;\n      }\n      /**\r\n       * Set all encountered keys so far as the protected keys for this type. This will\r\n       * be any key that has been animated or otherwise handled by active, higher-priortiy types.\r\n       */\n\n\n      typeState.protectedKeys = { ...encounteredKeys\n      }; // Check if we can skip analysing this prop early\n\n      if ( // If it isn't active and hasn't *just* been set as inactive\n      !typeState.isActive && activeDelta === null || // If we didn't and don't have any defined prop for this animation type\n      !prop && !typeState.prevProp || // Or if the prop doesn't define an animation\n      isAnimationControls(prop) || typeof prop === \"boolean\") {\n        continue;\n      }\n      /**\r\n       * As we go look through the values defined on this type, if we detect\r\n       * a changed value or a value that was removed in a higher priority, we set\r\n       * this to true and add this prop to the animation list.\r\n       */\n\n\n      const variantDidChange = checkVariantsDidChange(typeState.prevProp, prop);\n      let shouldAnimateType = variantDidChange || // If we're making this variant active, we want to always make it active\n      type === changedActiveType && typeState.isActive && !isInherited && propIsVariant || // If we removed a higher-priority variant (i is in reverse order)\n      i > removedVariantIndex && propIsVariant;\n      let handledRemovedValues = false;\n      /**\r\n       * As animations can be set as variant lists, variants or target objects, we\r\n       * coerce everything to an array if it isn't one already\r\n       */\n\n      const definitionList = Array.isArray(prop) ? prop : [prop];\n      /**\r\n       * Build an object of all the resolved values. We'll use this in the subsequent\r\n       * animateChanges calls to determine whether a value has changed.\r\n       */\n\n      let resolvedValues = definitionList.reduce(buildResolvedTypeValues(type), {});\n      if (activeDelta === false) resolvedValues = {};\n      /**\r\n       * Now we need to loop through all the keys in the prev prop and this prop,\r\n       * and decide:\r\n       * 1. If the value has changed, and needs animating\r\n       * 2. If it has been removed, and needs adding to the removedKeys set\r\n       * 3. If it has been removed in a higher priority type and needs animating\r\n       * 4. If it hasn't been removed in a higher priority but hasn't changed, and\r\n       *    needs adding to the type's protectedKeys list.\r\n       */\n\n      const {\n        prevResolvedValues = {}\n      } = typeState;\n      const allKeys = { ...prevResolvedValues,\n        ...resolvedValues\n      };\n\n      const markToAnimate = key => {\n        shouldAnimateType = true;\n\n        if (removedKeys.has(key)) {\n          handledRemovedValues = true;\n          removedKeys.delete(key);\n        }\n\n        typeState.needsAnimating[key] = true;\n        const motionValue = visualElement.getValue(key);\n        if (motionValue) motionValue.liveStyle = false;\n      };\n\n      for (const key in allKeys) {\n        const next = resolvedValues[key];\n        const prev = prevResolvedValues[key]; // If we've already handled this we can just skip ahead\n\n        if (encounteredKeys.hasOwnProperty(key)) continue;\n        /**\r\n         * If the value has changed, we probably want to animate it.\r\n         */\n\n        let valueHasChanged = false;\n\n        if (isKeyframesTarget(next) && isKeyframesTarget(prev)) {\n          valueHasChanged = !shallowCompare(next, prev);\n        } else {\n          valueHasChanged = next !== prev;\n        }\n\n        if (valueHasChanged) {\n          if (next !== undefined && next !== null) {\n            // If next is defined and doesn't equal prev, it needs animating\n            markToAnimate(key);\n          } else {\n            // If it's undefined, it's been removed.\n            removedKeys.add(key);\n          }\n        } else if (next !== undefined && removedKeys.has(key)) {\n          /**\r\n           * If next hasn't changed and it isn't undefined, we want to check if it's\r\n           * been removed by a higher priority\r\n           */\n          markToAnimate(key);\n        } else {\n          /**\r\n           * If it hasn't changed, we add it to the list of protected values\r\n           * to ensure it doesn't get animated.\r\n           */\n          typeState.protectedKeys[key] = true;\n        }\n      }\n      /**\r\n       * Update the typeState so next time animateChanges is called we can compare the\r\n       * latest prop and resolvedValues to these.\r\n       */\n\n\n      typeState.prevProp = prop;\n      typeState.prevResolvedValues = resolvedValues;\n      /**\r\n       *\r\n       */\n\n      if (typeState.isActive) {\n        encounteredKeys = { ...encounteredKeys,\n          ...resolvedValues\n        };\n      }\n\n      if (isInitialRender && visualElement.blockInitialAnimation) {\n        shouldAnimateType = false;\n      }\n      /**\r\n       * If this is an inherited prop we want to skip this animation\r\n       * unless the inherited variants haven't changed on this render.\r\n       */\n\n\n      const willAnimateViaParent = isInherited && variantDidChange;\n      const needsAnimating = !willAnimateViaParent || handledRemovedValues;\n\n      if (shouldAnimateType && needsAnimating) {\n        animations.push(...definitionList.map(animation => ({\n          animation: animation,\n          options: {\n            type\n          }\n        })));\n      }\n    }\n    /**\r\n     * If there are some removed value that haven't been dealt with,\r\n     * we need to create a new animation that falls back either to the value\r\n     * defined in the style prop, or the last read value.\r\n     */\n\n\n    if (removedKeys.size) {\n      const fallbackAnimation = {};\n      /**\r\n       * If the initial prop contains a transition we can use that, otherwise\r\n       * allow the animation function to use the visual element's default.\r\n       */\n\n      if (typeof props.initial !== \"boolean\") {\n        const initialTransition = resolveVariant(visualElement, Array.isArray(props.initial) ? props.initial[0] : props.initial);\n\n        if (initialTransition && initialTransition.transition) {\n          fallbackAnimation.transition = initialTransition.transition;\n        }\n      }\n\n      removedKeys.forEach(key => {\n        const fallbackTarget = visualElement.getBaseTarget(key);\n        const motionValue = visualElement.getValue(key);\n        if (motionValue) motionValue.liveStyle = true; // @ts-expect-error - @mattgperry to figure if we should do something here\n\n        fallbackAnimation[key] = fallbackTarget !== null && fallbackTarget !== void 0 ? fallbackTarget : null;\n      });\n      animations.push({\n        animation: fallbackAnimation\n      });\n    }\n\n    let shouldAnimate = Boolean(animations.length);\n\n    if (isInitialRender && (props.initial === false || props.initial === props.animate) && !visualElement.manuallyAnimateOnMount) {\n      shouldAnimate = false;\n    }\n\n    isInitialRender = false;\n    return shouldAnimate ? animate(animations) : Promise.resolve();\n  }\n  /**\r\n   * Change whether a certain animation type is active.\r\n   */\n\n\n  function setActive(type, isActive) {\n    var _a; // If the active state hasn't changed, we can safely do nothing here\n\n\n    if (state[type].isActive === isActive) return Promise.resolve(); // Propagate active change to children\n\n    (_a = visualElement.variantChildren) === null || _a === void 0 ? void 0 : _a.forEach(child => {\n      var _a;\n\n      return (_a = child.animationState) === null || _a === void 0 ? void 0 : _a.setActive(type, isActive);\n    });\n    state[type].isActive = isActive;\n    const animations = animateChanges(type);\n\n    for (const key in state) {\n      state[key].protectedKeys = {};\n    }\n\n    return animations;\n  }\n\n  return {\n    animateChanges,\n    setActive,\n    setAnimateFunction,\n    getState: () => state,\n    reset: () => {\n      state = createState();\n      isInitialRender = true;\n    }\n  };\n}\n\nfunction checkVariantsDidChange(prev, next) {\n  if (typeof next === \"string\") {\n    return next !== prev;\n  } else if (Array.isArray(next)) {\n    return !shallowCompare(next, prev);\n  }\n\n  return false;\n}\n\nfunction createTypeState() {\n  let isActive = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n  return {\n    isActive,\n    protectedKeys: {},\n    needsAnimating: {},\n    prevResolvedValues: {}\n  };\n}\n\nfunction createState() {\n  return {\n    animate: createTypeState(true),\n    whileInView: createTypeState(),\n    whileHover: createTypeState(),\n    whileTap: createTypeState(),\n    whileDrag: createTypeState(),\n    whileFocus: createTypeState(),\n    exit: createTypeState()\n  };\n}\n\nexport { checkVariantsDidChange, createAnimationState };","map":{"version":3,"sources":["C:/Users/PC/Documents/PROGRAMMING/New folder/MERN-BF/frontend/node_modules/framer-motion/dist/es/render/utils/animation-state.mjs"],"names":["animateVisualElement","isAnimationControls","isKeyframesTarget","shallowCompare","getVariantContext","isVariantLabel","resolveVariant","variantPriorityOrder","reversePriorityOrder","reverse","numAnimationTypes","length","animateList","visualElement","animations","Promise","all","map","animation","options","createAnimationState","animate","state","createState","isInitialRender","buildResolvedTypeValues","type","acc","definition","_a","resolved","presenceContext","custom","undefined","transition","transitionEnd","target","setAnimateFunction","makeAnimator","animateChanges","changedActiveType","props","context","parent","removedKeys","Set","encounteredKeys","removedVariantIndex","Infinity","i","typeState","prop","propIsVariant","activeDelta","isActive","isInherited","manuallyAnimateOnMount","protectedKeys","prevProp","variantDidChange","checkVariantsDidChange","shouldAnimateType","handledRemovedValues","definitionList","Array","isArray","resolvedValues","reduce","prevResolvedValues","allKeys","markToAnimate","key","has","delete","needsAnimating","motionValue","getValue","liveStyle","next","prev","hasOwnProperty","valueHasChanged","add","blockInitialAnimation","willAnimateViaParent","push","size","fallbackAnimation","initial","initialTransition","forEach","fallbackTarget","getBaseTarget","shouldAnimate","Boolean","resolve","setActive","variantChildren","child","animationState","getState","reset","createTypeState","whileInView","whileHover","whileTap","whileDrag","whileFocus","exit"],"mappings":"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","sourcesContent":["import { animateVisualElement } from '../../animation/interfaces/visual-element.mjs';\r\nimport { isAnimationControls } from '../../animation/utils/is-animation-controls.mjs';\r\nimport { isKeyframesTarget } from '../../animation/utils/is-keyframes-target.mjs';\r\nimport { shallowCompare } from '../../utils/shallow-compare.mjs';\r\nimport { getVariantContext } from './get-variant-context.mjs';\r\nimport { isVariantLabel } from './is-variant-label.mjs';\r\nimport { resolveVariant } from './resolve-dynamic-variants.mjs';\r\nimport { variantPriorityOrder } from './variant-props.mjs';\r\n\r\nconst reversePriorityOrder = [...variantPriorityOrder].reverse();\r\nconst numAnimationTypes = variantPriorityOrder.length;\r\nfunction animateList(visualElement) {\r\n    return (animations) => Promise.all(animations.map(({ animation, options }) => animateVisualElement(visualElement, animation, options)));\r\n}\r\nfunction createAnimationState(visualElement) {\r\n    let animate = animateList(visualElement);\r\n    let state = createState();\r\n    let isInitialRender = true;\r\n    /**\r\n     * This function will be used to reduce the animation definitions for\r\n     * each active animation type into an object of resolved values for it.\r\n     */\r\n    const buildResolvedTypeValues = (type) => (acc, definition) => {\r\n        var _a;\r\n        const resolved = resolveVariant(visualElement, definition, type === \"exit\"\r\n            ? (_a = visualElement.presenceContext) === null || _a === void 0 ? void 0 : _a.custom\r\n            : undefined);\r\n        if (resolved) {\r\n            const { transition, transitionEnd, ...target } = resolved;\r\n            acc = { ...acc, ...target, ...transitionEnd };\r\n        }\r\n        return acc;\r\n    };\r\n    /**\r\n     * This just allows us to inject mocked animation functions\r\n     * @internal\r\n     */\r\n    function setAnimateFunction(makeAnimator) {\r\n        animate = makeAnimator(visualElement);\r\n    }\r\n    /**\r\n     * When we receive new props, we need to:\r\n     * 1. Create a list of protected keys for each type. This is a directory of\r\n     *    value keys that are currently being \"handled\" by types of a higher priority\r\n     *    so that whenever an animation is played of a given type, these values are\r\n     *    protected from being animated.\r\n     * 2. Determine if an animation type needs animating.\r\n     * 3. Determine if any values have been removed from a type and figure out\r\n     *    what to animate those to.\r\n     */\r\n    function animateChanges(changedActiveType) {\r\n        const { props } = visualElement;\r\n        const context = getVariantContext(visualElement.parent) || {};\r\n        /**\r\n         * A list of animations that we'll build into as we iterate through the animation\r\n         * types. This will get executed at the end of the function.\r\n         */\r\n        const animations = [];\r\n        /**\r\n         * Keep track of which values have been removed. Then, as we hit lower priority\r\n         * animation types, we can check if they contain removed values and animate to that.\r\n         */\r\n        const removedKeys = new Set();\r\n        /**\r\n         * A dictionary of all encountered keys. This is an object to let us build into and\r\n         * copy it without iteration. Each time we hit an animation type we set its protected\r\n         * keys - the keys its not allowed to animate - to the latest version of this object.\r\n         */\r\n        let encounteredKeys = {};\r\n        /**\r\n         * If a variant has been removed at a given index, and this component is controlling\r\n         * variant animations, we want to ensure lower-priority variants are forced to animate.\r\n         */\r\n        let removedVariantIndex = Infinity;\r\n        /**\r\n         * Iterate through all animation types in reverse priority order. For each, we want to\r\n         * detect which values it's handling and whether or not they've changed (and therefore\r\n         * need to be animated). If any values have been removed, we want to detect those in\r\n         * lower priority props and flag for animation.\r\n         */\r\n        for (let i = 0; i < numAnimationTypes; i++) {\r\n            const type = reversePriorityOrder[i];\r\n            const typeState = state[type];\r\n            const prop = props[type] !== undefined\r\n                ? props[type]\r\n                : context[type];\r\n            const propIsVariant = isVariantLabel(prop);\r\n            /**\r\n             * If this type has *just* changed isActive status, set activeDelta\r\n             * to that status. Otherwise set to null.\r\n             */\r\n            const activeDelta = type === changedActiveType ? typeState.isActive : null;\r\n            if (activeDelta === false)\r\n                removedVariantIndex = i;\r\n            /**\r\n             * If this prop is an inherited variant, rather than been set directly on the\r\n             * component itself, we want to make sure we allow the parent to trigger animations.\r\n             *\r\n             * TODO: Can probably change this to a !isControllingVariants check\r\n             */\r\n            let isInherited = prop === context[type] &&\r\n                prop !== props[type] &&\r\n                propIsVariant;\r\n            /**\r\n             *\r\n             */\r\n            if (isInherited &&\r\n                isInitialRender &&\r\n                visualElement.manuallyAnimateOnMount) {\r\n                isInherited = false;\r\n            }\r\n            /**\r\n             * Set all encountered keys so far as the protected keys for this type. This will\r\n             * be any key that has been animated or otherwise handled by active, higher-priortiy types.\r\n             */\r\n            typeState.protectedKeys = { ...encounteredKeys };\r\n            // Check if we can skip analysing this prop early\r\n            if (\r\n            // If it isn't active and hasn't *just* been set as inactive\r\n            (!typeState.isActive && activeDelta === null) ||\r\n                // If we didn't and don't have any defined prop for this animation type\r\n                (!prop && !typeState.prevProp) ||\r\n                // Or if the prop doesn't define an animation\r\n                isAnimationControls(prop) ||\r\n                typeof prop === \"boolean\") {\r\n                continue;\r\n            }\r\n            /**\r\n             * As we go look through the values defined on this type, if we detect\r\n             * a changed value or a value that was removed in a higher priority, we set\r\n             * this to true and add this prop to the animation list.\r\n             */\r\n            const variantDidChange = checkVariantsDidChange(typeState.prevProp, prop);\r\n            let shouldAnimateType = variantDidChange ||\r\n                // If we're making this variant active, we want to always make it active\r\n                (type === changedActiveType &&\r\n                    typeState.isActive &&\r\n                    !isInherited &&\r\n                    propIsVariant) ||\r\n                // If we removed a higher-priority variant (i is in reverse order)\r\n                (i > removedVariantIndex && propIsVariant);\r\n            let handledRemovedValues = false;\r\n            /**\r\n             * As animations can be set as variant lists, variants or target objects, we\r\n             * coerce everything to an array if it isn't one already\r\n             */\r\n            const definitionList = Array.isArray(prop) ? prop : [prop];\r\n            /**\r\n             * Build an object of all the resolved values. We'll use this in the subsequent\r\n             * animateChanges calls to determine whether a value has changed.\r\n             */\r\n            let resolvedValues = definitionList.reduce(buildResolvedTypeValues(type), {});\r\n            if (activeDelta === false)\r\n                resolvedValues = {};\r\n            /**\r\n             * Now we need to loop through all the keys in the prev prop and this prop,\r\n             * and decide:\r\n             * 1. If the value has changed, and needs animating\r\n             * 2. If it has been removed, and needs adding to the removedKeys set\r\n             * 3. If it has been removed in a higher priority type and needs animating\r\n             * 4. If it hasn't been removed in a higher priority but hasn't changed, and\r\n             *    needs adding to the type's protectedKeys list.\r\n             */\r\n            const { prevResolvedValues = {} } = typeState;\r\n            const allKeys = {\r\n                ...prevResolvedValues,\r\n                ...resolvedValues,\r\n            };\r\n            const markToAnimate = (key) => {\r\n                shouldAnimateType = true;\r\n                if (removedKeys.has(key)) {\r\n                    handledRemovedValues = true;\r\n                    removedKeys.delete(key);\r\n                }\r\n                typeState.needsAnimating[key] = true;\r\n                const motionValue = visualElement.getValue(key);\r\n                if (motionValue)\r\n                    motionValue.liveStyle = false;\r\n            };\r\n            for (const key in allKeys) {\r\n                const next = resolvedValues[key];\r\n                const prev = prevResolvedValues[key];\r\n                // If we've already handled this we can just skip ahead\r\n                if (encounteredKeys.hasOwnProperty(key))\r\n                    continue;\r\n                /**\r\n                 * If the value has changed, we probably want to animate it.\r\n                 */\r\n                let valueHasChanged = false;\r\n                if (isKeyframesTarget(next) && isKeyframesTarget(prev)) {\r\n                    valueHasChanged = !shallowCompare(next, prev);\r\n                }\r\n                else {\r\n                    valueHasChanged = next !== prev;\r\n                }\r\n                if (valueHasChanged) {\r\n                    if (next !== undefined && next !== null) {\r\n                        // If next is defined and doesn't equal prev, it needs animating\r\n                        markToAnimate(key);\r\n                    }\r\n                    else {\r\n                        // If it's undefined, it's been removed.\r\n                        removedKeys.add(key);\r\n                    }\r\n                }\r\n                else if (next !== undefined && removedKeys.has(key)) {\r\n                    /**\r\n                     * If next hasn't changed and it isn't undefined, we want to check if it's\r\n                     * been removed by a higher priority\r\n                     */\r\n                    markToAnimate(key);\r\n                }\r\n                else {\r\n                    /**\r\n                     * If it hasn't changed, we add it to the list of protected values\r\n                     * to ensure it doesn't get animated.\r\n                     */\r\n                    typeState.protectedKeys[key] = true;\r\n                }\r\n            }\r\n            /**\r\n             * Update the typeState so next time animateChanges is called we can compare the\r\n             * latest prop and resolvedValues to these.\r\n             */\r\n            typeState.prevProp = prop;\r\n            typeState.prevResolvedValues = resolvedValues;\r\n            /**\r\n             *\r\n             */\r\n            if (typeState.isActive) {\r\n                encounteredKeys = { ...encounteredKeys, ...resolvedValues };\r\n            }\r\n            if (isInitialRender && visualElement.blockInitialAnimation) {\r\n                shouldAnimateType = false;\r\n            }\r\n            /**\r\n             * If this is an inherited prop we want to skip this animation\r\n             * unless the inherited variants haven't changed on this render.\r\n             */\r\n            const willAnimateViaParent = isInherited && variantDidChange;\r\n            const needsAnimating = !willAnimateViaParent || handledRemovedValues;\r\n            if (shouldAnimateType && needsAnimating) {\r\n                animations.push(...definitionList.map((animation) => ({\r\n                    animation: animation,\r\n                    options: { type },\r\n                })));\r\n            }\r\n        }\r\n        /**\r\n         * If there are some removed value that haven't been dealt with,\r\n         * we need to create a new animation that falls back either to the value\r\n         * defined in the style prop, or the last read value.\r\n         */\r\n        if (removedKeys.size) {\r\n            const fallbackAnimation = {};\r\n            /**\r\n             * If the initial prop contains a transition we can use that, otherwise\r\n             * allow the animation function to use the visual element's default.\r\n             */\r\n            if (typeof props.initial !== \"boolean\") {\r\n                const initialTransition = resolveVariant(visualElement, Array.isArray(props.initial)\r\n                    ? props.initial[0]\r\n                    : props.initial);\r\n                if (initialTransition && initialTransition.transition) {\r\n                    fallbackAnimation.transition = initialTransition.transition;\r\n                }\r\n            }\r\n            removedKeys.forEach((key) => {\r\n                const fallbackTarget = visualElement.getBaseTarget(key);\r\n                const motionValue = visualElement.getValue(key);\r\n                if (motionValue)\r\n                    motionValue.liveStyle = true;\r\n                // @ts-expect-error - @mattgperry to figure if we should do something here\r\n                fallbackAnimation[key] = fallbackTarget !== null && fallbackTarget !== void 0 ? fallbackTarget : null;\r\n            });\r\n            animations.push({ animation: fallbackAnimation });\r\n        }\r\n        let shouldAnimate = Boolean(animations.length);\r\n        if (isInitialRender &&\r\n            (props.initial === false || props.initial === props.animate) &&\r\n            !visualElement.manuallyAnimateOnMount) {\r\n            shouldAnimate = false;\r\n        }\r\n        isInitialRender = false;\r\n        return shouldAnimate ? animate(animations) : Promise.resolve();\r\n    }\r\n    /**\r\n     * Change whether a certain animation type is active.\r\n     */\r\n    function setActive(type, isActive) {\r\n        var _a;\r\n        // If the active state hasn't changed, we can safely do nothing here\r\n        if (state[type].isActive === isActive)\r\n            return Promise.resolve();\r\n        // Propagate active change to children\r\n        (_a = visualElement.variantChildren) === null || _a === void 0 ? void 0 : _a.forEach((child) => { var _a; return (_a = child.animationState) === null || _a === void 0 ? void 0 : _a.setActive(type, isActive); });\r\n        state[type].isActive = isActive;\r\n        const animations = animateChanges(type);\r\n        for (const key in state) {\r\n            state[key].protectedKeys = {};\r\n        }\r\n        return animations;\r\n    }\r\n    return {\r\n        animateChanges,\r\n        setActive,\r\n        setAnimateFunction,\r\n        getState: () => state,\r\n        reset: () => {\r\n            state = createState();\r\n            isInitialRender = true;\r\n        },\r\n    };\r\n}\r\nfunction checkVariantsDidChange(prev, next) {\r\n    if (typeof next === \"string\") {\r\n        return next !== prev;\r\n    }\r\n    else if (Array.isArray(next)) {\r\n        return !shallowCompare(next, prev);\r\n    }\r\n    return false;\r\n}\r\nfunction createTypeState(isActive = false) {\r\n    return {\r\n        isActive,\r\n        protectedKeys: {},\r\n        needsAnimating: {},\r\n        prevResolvedValues: {},\r\n    };\r\n}\r\nfunction createState() {\r\n    return {\r\n        animate: createTypeState(true),\r\n        whileInView: createTypeState(),\r\n        whileHover: createTypeState(),\r\n        whileTap: createTypeState(),\r\n        whileDrag: createTypeState(),\r\n        whileFocus: createTypeState(),\r\n        exit: createTypeState(),\r\n    };\r\n}\r\n\r\nexport { checkVariantsDidChange, createAnimationState };\r\n"]},"metadata":{},"sourceType":"module"}