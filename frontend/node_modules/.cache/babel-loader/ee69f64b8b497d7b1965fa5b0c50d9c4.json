{"ast":null,"code":"import { mixNumber } from '../../utils/mix/number.mjs';\nimport { hasTransform } from '../utils/has-transform.mjs';\n/**\r\n * Scales a point based on a factor and an originPoint\r\n */\n\nfunction scalePoint(point, scale, originPoint) {\n  const distanceFromOrigin = point - originPoint;\n  const scaled = scale * distanceFromOrigin;\n  return originPoint + scaled;\n}\n/**\r\n * Applies a translate/scale delta to a point\r\n */\n\n\nfunction applyPointDelta(point, translate, scale, originPoint, boxScale) {\n  if (boxScale !== undefined) {\n    point = scalePoint(point, boxScale, originPoint);\n  }\n\n  return scalePoint(point, scale, originPoint) + translate;\n}\n/**\r\n * Applies a translate/scale delta to an axis\r\n */\n\n\nfunction applyAxisDelta(axis) {\n  let translate = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  let scale = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n  let originPoint = arguments.length > 3 ? arguments[3] : undefined;\n  let boxScale = arguments.length > 4 ? arguments[4] : undefined;\n  axis.min = applyPointDelta(axis.min, translate, scale, originPoint, boxScale);\n  axis.max = applyPointDelta(axis.max, translate, scale, originPoint, boxScale);\n}\n/**\r\n * Applies a translate/scale delta to a box\r\n */\n\n\nfunction applyBoxDelta(box, _ref) {\n  let {\n    x,\n    y\n  } = _ref;\n  applyAxisDelta(box.x, x.translate, x.scale, x.originPoint);\n  applyAxisDelta(box.y, y.translate, y.scale, y.originPoint);\n}\n\nconst TREE_SCALE_SNAP_MIN = 0.999999999999;\nconst TREE_SCALE_SNAP_MAX = 1.0000000000001;\n/**\r\n * Apply a tree of deltas to a box. We do this to calculate the effect of all the transforms\r\n * in a tree upon our box before then calculating how to project it into our desired viewport-relative box\r\n *\r\n * This is the final nested loop within updateLayoutDelta for future refactoring\r\n */\n\nfunction applyTreeDeltas(box, treeScale, treePath) {\n  let isSharedTransition = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n  const treeLength = treePath.length;\n  if (!treeLength) return; // Reset the treeScale\n\n  treeScale.x = treeScale.y = 1;\n  let node;\n  let delta;\n\n  for (let i = 0; i < treeLength; i++) {\n    node = treePath[i];\n    delta = node.projectionDelta;\n    /**\r\n     * TODO: Prefer to remove this, but currently we have motion components with\r\n     * display: contents in Framer.\r\n     */\n\n    const {\n      visualElement\n    } = node.options;\n\n    if (visualElement && visualElement.props.style && visualElement.props.style.display === \"contents\") {\n      continue;\n    }\n\n    if (isSharedTransition && node.options.layoutScroll && node.scroll && node !== node.root) {\n      transformBox(box, {\n        x: -node.scroll.offset.x,\n        y: -node.scroll.offset.y\n      });\n    }\n\n    if (delta) {\n      // Incoporate each ancestor's scale into a culmulative treeScale for this component\n      treeScale.x *= delta.x.scale;\n      treeScale.y *= delta.y.scale; // Apply each ancestor's calculated delta into this component's recorded layout box\n\n      applyBoxDelta(box, delta);\n    }\n\n    if (isSharedTransition && hasTransform(node.latestValues)) {\n      transformBox(box, node.latestValues);\n    }\n  }\n  /**\r\n   * Snap tree scale back to 1 if it's within a non-perceivable threshold.\r\n   * This will help reduce useless scales getting rendered.\r\n   */\n\n\n  if (treeScale.x < TREE_SCALE_SNAP_MAX && treeScale.x > TREE_SCALE_SNAP_MIN) {\n    treeScale.x = 1.0;\n  }\n\n  if (treeScale.y < TREE_SCALE_SNAP_MAX && treeScale.y > TREE_SCALE_SNAP_MIN) {\n    treeScale.y = 1.0;\n  }\n}\n\nfunction translateAxis(axis, distance) {\n  axis.min = axis.min + distance;\n  axis.max = axis.max + distance;\n}\n/**\r\n * Apply a transform to an axis from the latest resolved motion values.\r\n * This function basically acts as a bridge between a flat motion value map\r\n * and applyAxisDelta\r\n */\n\n\nfunction transformAxis(axis, axisTranslate, axisScale, boxScale) {\n  let axisOrigin = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0.5;\n  const originPoint = mixNumber(axis.min, axis.max, axisOrigin); // Apply the axis delta to the final axis\n\n  applyAxisDelta(axis, axisTranslate, axisScale, originPoint, boxScale);\n}\n/**\r\n * Apply a transform to a box from the latest resolved motion values.\r\n */\n\n\nfunction transformBox(box, transform) {\n  transformAxis(box.x, transform.x, transform.scaleX, transform.scale, transform.originX);\n  transformAxis(box.y, transform.y, transform.scaleY, transform.scale, transform.originY);\n}\n\nexport { applyAxisDelta, applyBoxDelta, applyPointDelta, applyTreeDeltas, scalePoint, transformAxis, transformBox, translateAxis };","map":{"version":3,"sources":["C:/Users/PC/Documents/PROGRAMMING/New folder/MERN-BF/frontend/node_modules/framer-motion/dist/es/projection/geometry/delta-apply.mjs"],"names":["mixNumber","hasTransform","scalePoint","point","scale","originPoint","distanceFromOrigin","scaled","applyPointDelta","translate","boxScale","undefined","applyAxisDelta","axis","min","max","applyBoxDelta","box","x","y","TREE_SCALE_SNAP_MIN","TREE_SCALE_SNAP_MAX","applyTreeDeltas","treeScale","treePath","isSharedTransition","treeLength","length","node","delta","i","projectionDelta","visualElement","options","props","style","display","layoutScroll","scroll","root","transformBox","offset","latestValues","translateAxis","distance","transformAxis","axisTranslate","axisScale","axisOrigin","transform","scaleX","originX","scaleY","originY"],"mappings":"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","sourcesContent":["import { mixNumber } from '../../utils/mix/number.mjs';\r\nimport { hasTransform } from '../utils/has-transform.mjs';\r\n\r\n/**\r\n * Scales a point based on a factor and an originPoint\r\n */\r\nfunction scalePoint(point, scale, originPoint) {\r\n    const distanceFromOrigin = point - originPoint;\r\n    const scaled = scale * distanceFromOrigin;\r\n    return originPoint + scaled;\r\n}\r\n/**\r\n * Applies a translate/scale delta to a point\r\n */\r\nfunction applyPointDelta(point, translate, scale, originPoint, boxScale) {\r\n    if (boxScale !== undefined) {\r\n        point = scalePoint(point, boxScale, originPoint);\r\n    }\r\n    return scalePoint(point, scale, originPoint) + translate;\r\n}\r\n/**\r\n * Applies a translate/scale delta to an axis\r\n */\r\nfunction applyAxisDelta(axis, translate = 0, scale = 1, originPoint, boxScale) {\r\n    axis.min = applyPointDelta(axis.min, translate, scale, originPoint, boxScale);\r\n    axis.max = applyPointDelta(axis.max, translate, scale, originPoint, boxScale);\r\n}\r\n/**\r\n * Applies a translate/scale delta to a box\r\n */\r\nfunction applyBoxDelta(box, { x, y }) {\r\n    applyAxisDelta(box.x, x.translate, x.scale, x.originPoint);\r\n    applyAxisDelta(box.y, y.translate, y.scale, y.originPoint);\r\n}\r\nconst TREE_SCALE_SNAP_MIN = 0.999999999999;\r\nconst TREE_SCALE_SNAP_MAX = 1.0000000000001;\r\n/**\r\n * Apply a tree of deltas to a box. We do this to calculate the effect of all the transforms\r\n * in a tree upon our box before then calculating how to project it into our desired viewport-relative box\r\n *\r\n * This is the final nested loop within updateLayoutDelta for future refactoring\r\n */\r\nfunction applyTreeDeltas(box, treeScale, treePath, isSharedTransition = false) {\r\n    const treeLength = treePath.length;\r\n    if (!treeLength)\r\n        return;\r\n    // Reset the treeScale\r\n    treeScale.x = treeScale.y = 1;\r\n    let node;\r\n    let delta;\r\n    for (let i = 0; i < treeLength; i++) {\r\n        node = treePath[i];\r\n        delta = node.projectionDelta;\r\n        /**\r\n         * TODO: Prefer to remove this, but currently we have motion components with\r\n         * display: contents in Framer.\r\n         */\r\n        const { visualElement } = node.options;\r\n        if (visualElement &&\r\n            visualElement.props.style &&\r\n            visualElement.props.style.display === \"contents\") {\r\n            continue;\r\n        }\r\n        if (isSharedTransition &&\r\n            node.options.layoutScroll &&\r\n            node.scroll &&\r\n            node !== node.root) {\r\n            transformBox(box, {\r\n                x: -node.scroll.offset.x,\r\n                y: -node.scroll.offset.y,\r\n            });\r\n        }\r\n        if (delta) {\r\n            // Incoporate each ancestor's scale into a culmulative treeScale for this component\r\n            treeScale.x *= delta.x.scale;\r\n            treeScale.y *= delta.y.scale;\r\n            // Apply each ancestor's calculated delta into this component's recorded layout box\r\n            applyBoxDelta(box, delta);\r\n        }\r\n        if (isSharedTransition && hasTransform(node.latestValues)) {\r\n            transformBox(box, node.latestValues);\r\n        }\r\n    }\r\n    /**\r\n     * Snap tree scale back to 1 if it's within a non-perceivable threshold.\r\n     * This will help reduce useless scales getting rendered.\r\n     */\r\n    if (treeScale.x < TREE_SCALE_SNAP_MAX &&\r\n        treeScale.x > TREE_SCALE_SNAP_MIN) {\r\n        treeScale.x = 1.0;\r\n    }\r\n    if (treeScale.y < TREE_SCALE_SNAP_MAX &&\r\n        treeScale.y > TREE_SCALE_SNAP_MIN) {\r\n        treeScale.y = 1.0;\r\n    }\r\n}\r\nfunction translateAxis(axis, distance) {\r\n    axis.min = axis.min + distance;\r\n    axis.max = axis.max + distance;\r\n}\r\n/**\r\n * Apply a transform to an axis from the latest resolved motion values.\r\n * This function basically acts as a bridge between a flat motion value map\r\n * and applyAxisDelta\r\n */\r\nfunction transformAxis(axis, axisTranslate, axisScale, boxScale, axisOrigin = 0.5) {\r\n    const originPoint = mixNumber(axis.min, axis.max, axisOrigin);\r\n    // Apply the axis delta to the final axis\r\n    applyAxisDelta(axis, axisTranslate, axisScale, originPoint, boxScale);\r\n}\r\n/**\r\n * Apply a transform to a box from the latest resolved motion values.\r\n */\r\nfunction transformBox(box, transform) {\r\n    transformAxis(box.x, transform.x, transform.scaleX, transform.scale, transform.originX);\r\n    transformAxis(box.y, transform.y, transform.scaleY, transform.scale, transform.originY);\r\n}\r\n\r\nexport { applyAxisDelta, applyBoxDelta, applyPointDelta, applyTreeDeltas, scalePoint, transformAxis, transformBox, translateAxis };\r\n"]},"metadata":{},"sourceType":"module"}