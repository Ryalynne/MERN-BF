{"ast":null,"code":"import { invariant, noop, progress } from 'motion-utils';\nimport { clamp } from './clamp.mjs';\nimport { mix } from './mix/index.mjs';\nimport { pipe } from './pipe.mjs';\n\nfunction createMixers(output, ease, customMixer) {\n  const mixers = [];\n  const mixerFactory = customMixer || mix;\n  const numMixers = output.length - 1;\n\n  for (let i = 0; i < numMixers; i++) {\n    let mixer = mixerFactory(output[i], output[i + 1]);\n\n    if (ease) {\n      const easingFunction = Array.isArray(ease) ? ease[i] || noop : ease;\n      mixer = pipe(easingFunction, mixer);\n    }\n\n    mixers.push(mixer);\n  }\n\n  return mixers;\n}\n/**\r\n * Create a function that maps from a numerical input array to a generic output array.\r\n *\r\n * Accepts:\r\n *   - Numbers\r\n *   - Colors (hex, hsl, hsla, rgb, rgba)\r\n *   - Complex (combinations of one or more numbers or strings)\r\n *\r\n * ```jsx\r\n * const mixColor = interpolate([0, 1], ['#fff', '#000'])\r\n *\r\n * mixColor(0.5) // 'rgba(128, 128, 128, 1)'\r\n * ```\r\n *\r\n * TODO Revist this approach once we've moved to data models for values,\r\n * probably not needed to pregenerate mixer functions.\r\n *\r\n * @public\r\n */\n\n\nfunction interpolate(input, output) {\n  let {\n    clamp: isClamp = true,\n    ease,\n    mixer\n  } = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  const inputLength = input.length;\n  invariant(inputLength === output.length, \"Both input and output ranges must be the same length\");\n  /**\r\n   * If we're only provided a single input, we can just make a function\r\n   * that returns the output.\r\n   */\n\n  if (inputLength === 1) return () => output[0];\n  if (inputLength === 2 && output[0] === output[1]) return () => output[1];\n  const isZeroDeltaRange = input[0] === input[1]; // If input runs highest -> lowest, reverse both arrays\n\n  if (input[0] > input[inputLength - 1]) {\n    input = [...input].reverse();\n    output = [...output].reverse();\n  }\n\n  const mixers = createMixers(output, ease, mixer);\n  const numMixers = mixers.length;\n\n  const interpolator = v => {\n    if (isZeroDeltaRange && v < input[0]) return output[0];\n    let i = 0;\n\n    if (numMixers > 1) {\n      for (; i < input.length - 2; i++) {\n        if (v < input[i + 1]) break;\n      }\n    }\n\n    const progressInRange = progress(input[i], input[i + 1], v);\n    return mixers[i](progressInRange);\n  };\n\n  return isClamp ? v => interpolator(clamp(input[0], input[inputLength - 1], v)) : interpolator;\n}\n\nexport { interpolate };","map":{"version":3,"sources":["C:/Users/PC/Documents/PROGRAMMING/New folder/MERN-BF/frontend/node_modules/framer-motion/dist/es/utils/interpolate.mjs"],"names":["invariant","noop","progress","clamp","mix","pipe","createMixers","output","ease","customMixer","mixers","mixerFactory","numMixers","length","i","mixer","easingFunction","Array","isArray","push","interpolate","input","isClamp","inputLength","isZeroDeltaRange","reverse","interpolator","v","progressInRange"],"mappings":"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","sourcesContent":["import { invariant, noop, progress } from 'motion-utils';\r\nimport { clamp } from './clamp.mjs';\r\nimport { mix } from './mix/index.mjs';\r\nimport { pipe } from './pipe.mjs';\r\n\r\nfunction createMixers(output, ease, customMixer) {\r\n    const mixers = [];\r\n    const mixerFactory = customMixer || mix;\r\n    const numMixers = output.length - 1;\r\n    for (let i = 0; i < numMixers; i++) {\r\n        let mixer = mixerFactory(output[i], output[i + 1]);\r\n        if (ease) {\r\n            const easingFunction = Array.isArray(ease) ? ease[i] || noop : ease;\r\n            mixer = pipe(easingFunction, mixer);\r\n        }\r\n        mixers.push(mixer);\r\n    }\r\n    return mixers;\r\n}\r\n/**\r\n * Create a function that maps from a numerical input array to a generic output array.\r\n *\r\n * Accepts:\r\n *   - Numbers\r\n *   - Colors (hex, hsl, hsla, rgb, rgba)\r\n *   - Complex (combinations of one or more numbers or strings)\r\n *\r\n * ```jsx\r\n * const mixColor = interpolate([0, 1], ['#fff', '#000'])\r\n *\r\n * mixColor(0.5) // 'rgba(128, 128, 128, 1)'\r\n * ```\r\n *\r\n * TODO Revist this approach once we've moved to data models for values,\r\n * probably not needed to pregenerate mixer functions.\r\n *\r\n * @public\r\n */\r\nfunction interpolate(input, output, { clamp: isClamp = true, ease, mixer } = {}) {\r\n    const inputLength = input.length;\r\n    invariant(inputLength === output.length, \"Both input and output ranges must be the same length\");\r\n    /**\r\n     * If we're only provided a single input, we can just make a function\r\n     * that returns the output.\r\n     */\r\n    if (inputLength === 1)\r\n        return () => output[0];\r\n    if (inputLength === 2 && output[0] === output[1])\r\n        return () => output[1];\r\n    const isZeroDeltaRange = input[0] === input[1];\r\n    // If input runs highest -> lowest, reverse both arrays\r\n    if (input[0] > input[inputLength - 1]) {\r\n        input = [...input].reverse();\r\n        output = [...output].reverse();\r\n    }\r\n    const mixers = createMixers(output, ease, mixer);\r\n    const numMixers = mixers.length;\r\n    const interpolator = (v) => {\r\n        if (isZeroDeltaRange && v < input[0])\r\n            return output[0];\r\n        let i = 0;\r\n        if (numMixers > 1) {\r\n            for (; i < input.length - 2; i++) {\r\n                if (v < input[i + 1])\r\n                    break;\r\n            }\r\n        }\r\n        const progressInRange = progress(input[i], input[i + 1], v);\r\n        return mixers[i](progressInRange);\r\n    };\r\n    return isClamp\r\n        ? (v) => interpolator(clamp(input[0], input[inputLength - 1], v))\r\n        : interpolator;\r\n}\r\n\r\nexport { interpolate };\r\n"]},"metadata":{},"sourceType":"module"}