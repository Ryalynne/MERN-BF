{"ast":null,"code":"import { compose, castArray, parseFloat as parseFloat$1, matchPercent } from '@react-pdf/fns';\nimport matchMedia from 'media-engine';\nimport hlsToHex from 'hsl-to-hex';\nimport colorString from 'color-string';\nimport parse$1 from 'postcss-value-parser/lib/parse.js';\nimport parseUnit from 'postcss-value-parser/lib/unit.js';\n/**\r\n * Remove nil values from array\r\n *\r\n * @param array - Style array\r\n * @returns Style array without nils\r\n */\n\nconst compact = array => array.filter(Boolean);\n/**\r\n * Merges style objects array\r\n *\r\n * @param styles - Style array\r\n * @returns Merged style object\r\n */\n\n\nconst mergeStyles = styles => styles.reduce((acc, style) => {\n  const s = Array.isArray(style) ? flatten(style) : style;\n  Object.keys(s).forEach(key => {\n    if (s[key] !== null && s[key] !== undefined) {\n      acc[key] = s[key];\n    }\n  });\n  return acc;\n}, {});\n/**\r\n * Flattens an array of style objects, into one aggregated style object.\r\n *\r\n * @param styles - Style or style array\r\n * @returns Flattened style object\r\n */\n\n\nconst flatten = compose(mergeStyles, compact, castArray);\n/**\r\n * Resolves media queries in styles object\r\n *\r\n * @param container - Container for which styles are resolved\r\n * @param style - Style description\r\n * @returns Resolved style object\r\n */\n\nconst resolveMediaQueries = (container, style) => {\n  return Object.keys(style).reduce((acc, key) => {\n    if (/@media/.test(key)) {\n      return { ...acc,\n        ...matchMedia({\n          [key]: style[key]\n        }, container)\n      };\n    }\n\n    return { ...acc,\n      [key]: style[key]\n    };\n  }, {});\n};\n\nconst isRgb = value => /rgba?/g.test(value);\n\nconst isHsl = value => /hsla?/g.test(value);\n/**\r\n * Transform rgb color to hexa\r\n *\r\n * @param value - Styles value\r\n * @returns Transformed value\r\n */\n\n\nconst parseRgb = value => {\n  const rgb = colorString.get.rgb(value);\n  return colorString.to.hex(rgb);\n};\n/**\r\n * Transform Hsl color to hexa\r\n *\r\n * @param value - Styles value\r\n * @returns Transformed value\r\n */\n\n\nconst parseHsl = value => {\n  const hsl = colorString.get.hsl(value).map(Math.round);\n  const hex = hlsToHex(...hsl);\n  return hex.toUpperCase();\n};\n/**\r\n * Transform given color to hexa\r\n *\r\n * @param value - Styles value\r\n * @returns Transformed value\r\n */\n\n\nconst transformColor = value => {\n  if (isRgb(value)) return parseRgb(value);\n  if (isHsl(value)) return parseHsl(value);\n  return value;\n};\n/**\r\n * Parses scalar value in value and unit pairs\r\n *\r\n * @param value - Scalar value\r\n * @returns Parsed value\r\n */\n\n\nconst parseValue = value => {\n  if (typeof value === 'number') return {\n    value,\n    unit: undefined\n  };\n  const match = /^(-?\\d*\\.?\\d+)(in|mm|cm|pt|vh|vw|px|rem)?$/g.exec(value);\n  return match ? {\n    value: parseFloat(match[1]),\n    unit: match[2] || 'pt'\n  } : {\n    value,\n    unit: undefined\n  };\n};\n/**\r\n * Transform given scalar value\r\n *\r\n * @param container\r\n * @param value - Styles value\r\n * @returns Transformed value\r\n */\n\n\nconst transformUnit = (container, value) => {\n  const scalar = parseValue(value);\n  const outputDpi = 72;\n  const inputDpi = container.dpi || 72;\n  const mmFactor = 1 / 25.4 * outputDpi;\n  const cmFactor = 1 / 2.54 * outputDpi;\n  if (typeof scalar.value !== 'number') return scalar.value;\n\n  switch (scalar.unit) {\n    case 'rem':\n      return scalar.value * (container.remBase || 18);\n\n    case 'in':\n      return scalar.value * outputDpi;\n\n    case 'mm':\n      return scalar.value * mmFactor;\n\n    case 'cm':\n      return scalar.value * cmFactor;\n\n    case 'vh':\n      return scalar.value * (container.height / 100);\n\n    case 'vw':\n      return scalar.value * (container.width / 100);\n\n    case 'px':\n      return Math.round(scalar.value * (outputDpi / inputDpi));\n\n    default:\n      return scalar.value;\n  }\n};\n\nconst processNumberValue = (key, value) => ({\n  [key]: parseFloat$1(value)\n});\n\nconst processUnitValue = (key, value, container) => ({\n  [key]: transformUnit(container, value)\n});\n\nconst processColorValue = (key, value) => {\n  const result = {\n    [key]: transformColor(value)\n  };\n  return result;\n};\n\nconst processNoopValue = (key, value) => ({\n  [key]: value\n});\n\nconst BORDER_SHORTHAND_REGEX = /(-?\\d+(\\.\\d+)?(in|mm|cm|pt|vw|vh|px|rem)?)\\s(\\S+)\\s(.+)/;\n\nconst matchBorderShorthand = value => value.match(BORDER_SHORTHAND_REGEX) || [];\n\nconst resolveBorderShorthand = (key, value, container) => {\n  const match = matchBorderShorthand(`${value}`);\n\n  if (match) {\n    const widthMatch = match[1] || value;\n    const styleMatch = match[4] || value;\n    const colorMatch = match[5] || value;\n    const style = styleMatch;\n    const color = colorMatch ? transformColor(colorMatch) : undefined;\n    const width = widthMatch ? transformUnit(container, widthMatch) : undefined;\n\n    if (key.match(/(Top|Right|Bottom|Left)$/)) {\n      return {\n        [`${key}Color`]: color,\n        [`${key}Style`]: style,\n        [`${key}Width`]: width\n      };\n    }\n\n    if (key.match(/Color$/)) {\n      return {\n        borderTopColor: color,\n        borderRightColor: color,\n        borderBottomColor: color,\n        borderLeftColor: color\n      };\n    }\n\n    if (key.match(/Style$/)) {\n      if (typeof style === 'number') throw new Error(`Invalid border style: ${style}`);\n      return {\n        borderTopStyle: style,\n        borderRightStyle: style,\n        borderBottomStyle: style,\n        borderLeftStyle: style\n      };\n    }\n\n    if (key.match(/Width$/)) {\n      if (typeof width !== 'number') throw new Error(`Invalid border width: ${width}`);\n      return {\n        borderTopWidth: width,\n        borderRightWidth: width,\n        borderBottomWidth: width,\n        borderLeftWidth: width\n      };\n    }\n\n    if (key.match(/Radius$/)) {\n      const radius = value ? transformUnit(container, value) : undefined;\n      if (typeof radius !== 'number') throw new Error(`Invalid border radius: ${radius}`);\n      return {\n        borderTopLeftRadius: radius,\n        borderTopRightRadius: radius,\n        borderBottomRightRadius: radius,\n        borderBottomLeftRadius: radius\n      };\n    }\n\n    if (typeof width !== 'number') throw new Error(`Invalid border width: ${width}`);\n    if (typeof style === 'number') throw new Error(`Invalid border style: ${style}`);\n    return {\n      borderTopColor: color,\n      borderTopStyle: style,\n      borderTopWidth: width,\n      borderRightColor: color,\n      borderRightStyle: style,\n      borderRightWidth: width,\n      borderBottomColor: color,\n      borderBottomStyle: style,\n      borderBottomWidth: width,\n      borderLeftColor: color,\n      borderLeftStyle: style,\n      borderLeftWidth: width\n    };\n  }\n\n  return {\n    [key]: value\n  };\n};\n\nconst handlers$b = {\n  border: resolveBorderShorthand,\n  borderBottom: resolveBorderShorthand,\n  borderBottomColor: processColorValue,\n  borderBottomLeftRadius: processUnitValue,\n  borderBottomRightRadius: processUnitValue,\n  borderBottomStyle: processNoopValue,\n  borderBottomWidth: processUnitValue,\n  borderColor: resolveBorderShorthand,\n  borderLeft: resolveBorderShorthand,\n  borderLeftColor: processColorValue,\n  borderLeftStyle: processNoopValue,\n  borderLeftWidth: processUnitValue,\n  borderRadius: resolveBorderShorthand,\n  borderRight: resolveBorderShorthand,\n  borderRightColor: processColorValue,\n  borderRightStyle: processNoopValue,\n  borderRightWidth: processUnitValue,\n  borderStyle: resolveBorderShorthand,\n  borderTop: resolveBorderShorthand,\n  borderTopColor: processColorValue,\n  borderTopLeftRadius: processUnitValue,\n  borderTopRightRadius: processUnitValue,\n  borderTopStyle: processNoopValue,\n  borderTopWidth: processUnitValue,\n  borderWidth: resolveBorderShorthand\n};\nconst handlers$a = {\n  backgroundColor: processColorValue,\n  color: processColorValue,\n  opacity: processNumberValue\n};\nconst handlers$9 = {\n  height: processUnitValue,\n  maxHeight: processUnitValue,\n  maxWidth: processUnitValue,\n  minHeight: processUnitValue,\n  minWidth: processUnitValue,\n  width: processUnitValue\n}; // https://developer.mozilla.org/en-US/docs/Web/CSS/flex#values\n// TODO: change flex defaults to [0, 1, 'auto'] as in spec in next major release\n\nconst flexDefaults = [1, 1, 0];\nconst flexAuto = [1, 1, 'auto'];\n\nconst processFlexShorthand = (key, value, container) => {\n  let defaults = flexDefaults;\n  let matches = [];\n\n  if (value === 'auto') {\n    defaults = flexAuto;\n  } else {\n    matches = `${value}`.split(' ');\n  }\n\n  const flexGrow = parseFloat$1(matches[0] || defaults[0]);\n  const flexShrink = parseFloat$1(matches[1] || defaults[1]);\n  const flexBasis = transformUnit(container, matches[2] || defaults[2]);\n  return {\n    flexGrow,\n    flexShrink,\n    flexBasis\n  };\n};\n\nconst handlers$8 = {\n  alignContent: processNoopValue,\n  alignItems: processNoopValue,\n  alignSelf: processNoopValue,\n  flex: processFlexShorthand,\n  flexBasis: processUnitValue,\n  flexDirection: processNoopValue,\n  flexFlow: processNoopValue,\n  flexGrow: processNumberValue,\n  flexShrink: processNumberValue,\n  flexWrap: processNoopValue,\n  justifyContent: processNoopValue,\n  justifySelf: processNoopValue\n};\n\nconst processGapShorthand = (key, value, container) => {\n  const match = `${value}`.split(' ');\n  const rowGap = transformUnit(container, match?.[0] || value);\n  const columnGap = transformUnit(container, match?.[1] || value);\n  return {\n    rowGap,\n    columnGap\n  };\n};\n\nconst handlers$7 = {\n  gap: processGapShorthand,\n  columnGap: processUnitValue,\n  rowGap: processUnitValue\n};\nconst handlers$6 = {\n  aspectRatio: processNumberValue,\n  bottom: processUnitValue,\n  display: processNoopValue,\n  left: processUnitValue,\n  position: processNoopValue,\n  right: processUnitValue,\n  top: processUnitValue,\n  overflow: processNoopValue,\n  zIndex: processNumberValue\n};\nconst BOX_MODEL_UNITS = 'px,in,mm,cm,pt,%,vw,vh';\n\nconst logError = (style, value) => {\n  const name = style.toString(); // eslint-disable-next-line no-console\n\n  console.error(`\n    @react-pdf/stylesheet parsing error:\n    ${name}: ${value},\n    ${' '.repeat(name.length + 2)}^\n    Unsupported ${name} value format\n  `);\n};\n/**\r\n * @param options\r\n * @param [options.expandsTo]\r\n * @param [options.maxValues]\r\n * @param [options.autoSupported]\r\n */\n\n\nconst expandBoxModel = function () {\n  let {\n    expandsTo,\n    maxValues = 1,\n    autoSupported = false\n  } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  return (model, value, container) => {\n    const nodes = parse$1(`${value}`);\n    const parts = [];\n\n    for (let i = 0; i < nodes.length; i++) {\n      const node = nodes[i]; // value contains `calc`, `url` or other css function\n      // `,`, `/` or strings that unsupported by margin and padding\n\n      if (node.type === 'function' || node.type === 'string' || node.type === 'div') {\n        logError(model, value);\n        return {};\n      }\n\n      if (node.type === 'word') {\n        if (node.value === 'auto' && autoSupported) {\n          parts.push(node.value);\n        } else {\n          const result = parseUnit(node.value); // when unit isn't specified this condition is true\n\n          if (result && BOX_MODEL_UNITS.includes(result.unit)) {\n            parts.push(node.value);\n          } else {\n            logError(model, value);\n            return {};\n          }\n        }\n      }\n    } // checks that we have enough parsed values\n\n\n    if (parts.length > maxValues) {\n      logError(model, value);\n      return {};\n    }\n\n    const first = transformUnit(container, parts[0]);\n\n    if (expandsTo) {\n      const second = transformUnit(container, parts[1] || parts[0]);\n      const third = transformUnit(container, parts[2] || parts[0]);\n      const fourth = transformUnit(container, parts[3] || parts[1] || parts[0]);\n      return expandsTo({\n        first,\n        second,\n        third,\n        fourth\n      });\n    }\n\n    return {\n      [model]: first\n    };\n  };\n};\n\nconst processMargin = expandBoxModel({\n  expandsTo: _ref => {\n    let {\n      first,\n      second,\n      third,\n      fourth\n    } = _ref;\n    return {\n      marginTop: first,\n      marginRight: second,\n      marginBottom: third,\n      marginLeft: fourth\n    };\n  },\n  maxValues: 4,\n  autoSupported: true\n});\nconst processMarginVertical = expandBoxModel({\n  expandsTo: _ref2 => {\n    let {\n      first,\n      second\n    } = _ref2;\n    return {\n      marginTop: first,\n      marginBottom: second\n    };\n  },\n  maxValues: 2,\n  autoSupported: true\n});\nconst processMarginHorizontal = expandBoxModel({\n  expandsTo: _ref3 => {\n    let {\n      first,\n      second\n    } = _ref3;\n    return {\n      marginRight: first,\n      marginLeft: second\n    };\n  },\n  maxValues: 2,\n  autoSupported: true\n});\nconst processMarginSingle = expandBoxModel({\n  autoSupported: true\n});\nconst handlers$5 = {\n  margin: processMargin,\n  marginBottom: processMarginSingle,\n  marginHorizontal: processMarginHorizontal,\n  marginLeft: processMarginSingle,\n  marginRight: processMarginSingle,\n  marginTop: processMarginSingle,\n  marginVertical: processMarginVertical\n};\nconst processPadding = expandBoxModel({\n  expandsTo: _ref4 => {\n    let {\n      first,\n      second,\n      third,\n      fourth\n    } = _ref4;\n    return {\n      paddingTop: first,\n      paddingRight: second,\n      paddingBottom: third,\n      paddingLeft: fourth\n    };\n  },\n  maxValues: 4\n});\nconst processPaddingVertical = expandBoxModel({\n  expandsTo: _ref5 => {\n    let {\n      first,\n      second\n    } = _ref5;\n    return {\n      paddingTop: first,\n      paddingBottom: second\n    };\n  },\n  maxValues: 2\n});\nconst processPaddingHorizontal = expandBoxModel({\n  expandsTo: _ref6 => {\n    let {\n      first,\n      second\n    } = _ref6;\n    return {\n      paddingRight: first,\n      paddingLeft: second\n    };\n  },\n  maxValues: 2\n});\nconst processPaddingSingle = expandBoxModel();\nconst handlers$4 = {\n  padding: processPadding,\n  paddingBottom: processPaddingSingle,\n  paddingHorizontal: processPaddingHorizontal,\n  paddingLeft: processPaddingSingle,\n  paddingRight: processPaddingSingle,\n  paddingTop: processPaddingSingle,\n  paddingVertical: processPaddingVertical\n};\n\nconst offsetKeyword = value => {\n  switch (value) {\n    case 'top':\n    case 'left':\n      return '0%';\n\n    case 'right':\n    case 'bottom':\n      return '100%';\n\n    case 'center':\n      return '50%';\n\n    default:\n      return value;\n  }\n};\n\nconst processObjectPosition = (key, value, container) => {\n  const match = `${value}`.split(' ');\n  const objectPositionX = offsetKeyword(transformUnit(container, match?.[0] || value));\n  const objectPositionY = offsetKeyword(transformUnit(container, match?.[1] || value));\n  return {\n    objectPositionX,\n    objectPositionY\n  };\n};\n\nconst processObjectPositionValue = (key, value, container) => ({\n  [key]: offsetKeyword(transformUnit(container, value))\n});\n\nconst handlers$3 = {\n  objectPosition: processObjectPosition,\n  objectPositionX: processObjectPositionValue,\n  objectPositionY: processObjectPositionValue,\n  objectFit: processNoopValue\n};\n\nconst castInt = value => {\n  if (typeof value === 'number') return value;\n  return parseInt(value, 10);\n};\n\nconst FONT_WEIGHTS = {\n  thin: 100,\n  hairline: 100,\n  ultralight: 200,\n  extralight: 200,\n  light: 300,\n  normal: 400,\n  medium: 500,\n  semibold: 600,\n  demibold: 600,\n  bold: 700,\n  ultrabold: 800,\n  extrabold: 800,\n  heavy: 900,\n  black: 900\n};\n\nconst transformFontWeight = value => {\n  if (!value) return FONT_WEIGHTS.normal;\n  if (typeof value === 'number') return value;\n  const lv = value.toLowerCase();\n  if (FONT_WEIGHTS[lv]) return FONT_WEIGHTS[lv];\n  return castInt(value);\n};\n\nconst processFontWeight = (key, value) => {\n  return {\n    [key]: transformFontWeight(value)\n  };\n};\n\nconst transformLineHeight = (value, styles, container) => {\n  if (value === '') return value;\n  const fontSize = transformUnit(container, styles.fontSize || 18);\n  const lineHeight = transformUnit(container, value); // Percent values: use this number multiplied by the element's font size\n\n  const {\n    percent\n  } = matchPercent(lineHeight) || {};\n  if (percent) return percent * fontSize; // Unitless values: use this number multiplied by the element's font size\n\n  return isNaN(value) ? lineHeight : lineHeight * fontSize;\n};\n\nconst processLineHeight = (key, value, container, styles) => {\n  return {\n    [key]: transformLineHeight(value, styles, container)\n  };\n};\n\nconst handlers$2 = {\n  direction: processNoopValue,\n  fontFamily: processNoopValue,\n  fontSize: processUnitValue,\n  fontStyle: processNoopValue,\n  fontWeight: processFontWeight,\n  letterSpacing: processUnitValue,\n  lineHeight: processLineHeight,\n  maxLines: processNumberValue,\n  textAlign: processNoopValue,\n  textDecoration: processNoopValue,\n  textDecorationColor: processColorValue,\n  textDecorationStyle: processNoopValue,\n  textIndent: processNoopValue,\n  textOverflow: processNoopValue,\n  textTransform: processNoopValue,\n  verticalAlign: processNoopValue\n};\n\nconst matchNumber = value => typeof value === 'string' && /^-?\\d*\\.?\\d*$/.test(value);\n\nconst castFloat = value => {\n  if (typeof value !== 'string') return value;\n  if (matchNumber(value)) return parseFloat(value);\n  return value;\n};\n\nconst parse = transformString => {\n  const transforms = transformString.trim().split(/\\)[ ,]|\\)/); // Handle \"initial\", \"inherit\", \"unset\".\n\n  if (transforms.length === 1) {\n    return [[transforms[0], true]];\n  }\n\n  const parsed = [];\n\n  for (let i = 0; i < transforms.length; i += 1) {\n    const transform = transforms[i];\n\n    if (transform) {\n      const [name, rawValue] = transform.split('(');\n      const splitChar = rawValue.indexOf(',') >= 0 ? ',' : ' ';\n      const value = rawValue.split(splitChar).map(val => val.trim());\n      parsed.push({\n        operation: name.trim(),\n        value\n      });\n    }\n  }\n\n  return parsed;\n};\n\nconst parseAngle = value => {\n  const unitsRegexp = /(-?\\d*\\.?\\d*)(\\w*)?/i;\n  const [, angle, unit] = unitsRegexp.exec(value);\n  const number = Number.parseFloat(angle);\n  return unit === 'rad' ? number * 180 / Math.PI : number;\n};\n\nconst normalizeTransformOperation = _ref7 => {\n  let {\n    operation,\n    value\n  } = _ref7;\n\n  switch (operation) {\n    case 'scale':\n      {\n        const [scaleX, scaleY = scaleX] = value.map(num => Number.parseFloat(num));\n        return {\n          operation: 'scale',\n          value: [scaleX, scaleY]\n        };\n      }\n\n    case 'scaleX':\n      {\n        return {\n          operation: 'scale',\n          value: [Number.parseFloat(value), 1]\n        };\n      }\n\n    case 'scaleY':\n      {\n        return {\n          operation: 'scale',\n          value: [1, Number.parseFloat(value)]\n        };\n      }\n\n    case 'rotate':\n      {\n        return {\n          operation: 'rotate',\n          value: [parseAngle(value)]\n        };\n      }\n\n    case 'translate':\n      {\n        return {\n          operation: 'translate',\n          value: value.map(num => Number.parseFloat(num))\n        };\n      }\n\n    case 'translateX':\n      {\n        return {\n          operation: 'translate',\n          value: [Number.parseFloat(value), 0]\n        };\n      }\n\n    case 'translateY':\n      {\n        return {\n          operation: 'translate',\n          value: [0, Number.parseFloat(value)]\n        };\n      }\n\n    case 'skew':\n      {\n        return {\n          operation: 'skew',\n          value: value.map(parseAngle)\n        };\n      }\n\n    case 'skewX':\n      {\n        return {\n          operation: 'skew',\n          value: [parseAngle(value), 0]\n        };\n      }\n\n    case 'skewY':\n      {\n        return {\n          operation: 'skew',\n          value: [0, parseAngle(value)]\n        };\n      }\n\n    default:\n      {\n        return {\n          operation,\n          value: value.map(num => Number.parseFloat(num))\n        };\n      }\n  }\n};\n\nconst normalize = operations => {\n  return operations.map(operation => normalizeTransformOperation(operation));\n};\n\nconst processTransform = (key, value) => {\n  if (typeof value !== 'string') return {\n    [key]: value\n  };\n  return {\n    [key]: normalize(parse(value))\n  };\n};\n\nconst Y_AXIS_SHORTHANDS = {\n  top: true,\n  bottom: true\n};\n\nconst sortTransformOriginPair = (a, b) => {\n  if (Y_AXIS_SHORTHANDS[a]) return 1;\n  if (Y_AXIS_SHORTHANDS[b]) return -1;\n  return 0;\n};\n\nconst getTransformOriginPair = values => {\n  if (!values || values.length === 0) return ['center', 'center'];\n  const pair = values.length === 1 ? [values[0], 'center'] : values;\n  return pair.sort(sortTransformOriginPair);\n}; // Transforms shorthand transformOrigin values\n\n\nconst processTransformOriginShorthand = (key, value, container) => {\n  const match = `${value}`.split(' ');\n  const pair = getTransformOriginPair(match);\n  const transformOriginX = transformUnit(container, pair[0]);\n  const transformOriginY = transformUnit(container, pair[1]);\n  return {\n    transformOriginX: offsetKeyword(transformOriginX) || castFloat(transformOriginX),\n    transformOriginY: offsetKeyword(transformOriginY) || castFloat(transformOriginY)\n  };\n};\n\nconst processTransformOriginValue = (key, value, container) => {\n  const v = transformUnit(container, value);\n  return {\n    [key]: offsetKeyword(v) || castFloat(v)\n  };\n};\n\nconst handlers$1 = {\n  transform: processTransform,\n  gradientTransform: processTransform,\n  transformOrigin: processTransformOriginShorthand,\n  transformOriginX: processTransformOriginValue,\n  transformOriginY: processTransformOriginValue\n};\nconst handlers = {\n  fill: processColorValue,\n  stroke: processColorValue,\n  strokeDasharray: processNoopValue,\n  strokeWidth: processUnitValue,\n  fillOpacity: processNumberValue,\n  strokeOpacity: processNumberValue,\n  fillRule: processNoopValue,\n  textAnchor: processNoopValue,\n  strokeLinecap: processNoopValue,\n  strokeLinejoin: processNoopValue,\n  visibility: processNoopValue,\n  clipPath: processNoopValue,\n  dominantBaseline: processNoopValue\n};\nconst shorthands = { ...handlers$b,\n  ...handlers$a,\n  ...handlers$9,\n  ...handlers$8,\n  ...handlers$7,\n  ...handlers$6,\n  ...handlers$5,\n  ...handlers$4,\n  ...handlers$3,\n  ...handlers$2,\n  ...handlers$1,\n  ...handlers\n};\n/**\r\n * Expand the shorthand properties.\r\n *\r\n * @param style - Style object\r\n * @returns Expanded style object\r\n */\n\nconst resolve = container => style => {\n  const propsArray = Object.keys(style);\n  const resolvedStyle = {};\n\n  for (let i = 0; i < propsArray.length; i += 1) {\n    const key = propsArray[i];\n    const value = style[key];\n\n    if (!shorthands[key]) {\n      resolvedStyle[key] = value;\n      continue;\n    }\n\n    const resolved = shorthands[key](key, value, container, style);\n    const keys = Object.keys(resolved);\n\n    for (let j = 0; j < keys.length; j += 1) {\n      const propName = keys[j];\n      const propValue = resolved[propName];\n      resolvedStyle[propName] = propValue;\n    }\n  }\n\n  return resolvedStyle;\n};\n/**\r\n * Resolves styles\r\n *\r\n * @param container\r\n * @param style - Style\r\n * @returns Resolved style\r\n */\n\n\nconst resolveStyles = (container, style) => {\n  const computeMediaQueries = value => resolveMediaQueries(container, value);\n\n  return compose(resolve(container), computeMediaQueries, flatten)(style);\n};\n\nexport { resolveStyles as default, flatten, transformColor };","map":{"version":3,"sources":["C:/Users/PC/Documents/PROGRAMMING/New folder/MERN-BF/frontend/node_modules/@react-pdf/stylesheet/lib/index.js"],"names":["compose","castArray","parseFloat","parseFloat$1","matchPercent","matchMedia","hlsToHex","colorString","parse$1","parseUnit","compact","array","filter","Boolean","mergeStyles","styles","reduce","acc","style","s","Array","isArray","flatten","Object","keys","forEach","key","undefined","resolveMediaQueries","container","test","isRgb","value","isHsl","parseRgb","rgb","get","to","hex","parseHsl","hsl","map","Math","round","toUpperCase","transformColor","parseValue","unit","match","exec","transformUnit","scalar","outputDpi","inputDpi","dpi","mmFactor","cmFactor","remBase","height","width","processNumberValue","processUnitValue","processColorValue","result","processNoopValue","BORDER_SHORTHAND_REGEX","matchBorderShorthand","resolveBorderShorthand","widthMatch","styleMatch","colorMatch","color","borderTopColor","borderRightColor","borderBottomColor","borderLeftColor","Error","borderTopStyle","borderRightStyle","borderBottomStyle","borderLeftStyle","borderTopWidth","borderRightWidth","borderBottomWidth","borderLeftWidth","radius","borderTopLeftRadius","borderTopRightRadius","borderBottomRightRadius","borderBottomLeftRadius","handlers$b","border","borderBottom","borderColor","borderLeft","borderRadius","borderRight","borderStyle","borderTop","borderWidth","handlers$a","backgroundColor","opacity","handlers$9","maxHeight","maxWidth","minHeight","minWidth","flexDefaults","flexAuto","processFlexShorthand","defaults","matches","split","flexGrow","flexShrink","flexBasis","handlers$8","alignContent","alignItems","alignSelf","flex","flexDirection","flexFlow","flexWrap","justifyContent","justifySelf","processGapShorthand","rowGap","columnGap","handlers$7","gap","handlers$6","aspectRatio","bottom","display","left","position","right","top","overflow","zIndex","BOX_MODEL_UNITS","logError","name","toString","console","error","repeat","length","expandBoxModel","expandsTo","maxValues","autoSupported","model","nodes","parts","i","node","type","push","includes","first","second","third","fourth","processMargin","marginTop","marginRight","marginBottom","marginLeft","processMarginVertical","processMarginHorizontal","processMarginSingle","handlers$5","margin","marginHorizontal","marginVertical","processPadding","paddingTop","paddingRight","paddingBottom","paddingLeft","processPaddingVertical","processPaddingHorizontal","processPaddingSingle","handlers$4","padding","paddingHorizontal","paddingVertical","offsetKeyword","processObjectPosition","objectPositionX","objectPositionY","processObjectPositionValue","handlers$3","objectPosition","objectFit","castInt","parseInt","FONT_WEIGHTS","thin","hairline","ultralight","extralight","light","normal","medium","semibold","demibold","bold","ultrabold","extrabold","heavy","black","transformFontWeight","lv","toLowerCase","processFontWeight","transformLineHeight","fontSize","lineHeight","percent","isNaN","processLineHeight","handlers$2","direction","fontFamily","fontStyle","fontWeight","letterSpacing","maxLines","textAlign","textDecoration","textDecorationColor","textDecorationStyle","textIndent","textOverflow","textTransform","verticalAlign","matchNumber","castFloat","parse","transformString","transforms","trim","parsed","transform","rawValue","splitChar","indexOf","val","operation","parseAngle","unitsRegexp","angle","number","Number","PI","normalizeTransformOperation","scaleX","scaleY","num","normalize","operations","processTransform","Y_AXIS_SHORTHANDS","sortTransformOriginPair","a","b","getTransformOriginPair","values","pair","sort","processTransformOriginShorthand","transformOriginX","transformOriginY","processTransformOriginValue","v","handlers$1","gradientTransform","transformOrigin","handlers","fill","stroke","strokeDasharray","strokeWidth","fillOpacity","strokeOpacity","fillRule","textAnchor","strokeLinecap","strokeLinejoin","visibility","clipPath","dominantBaseline","shorthands","resolve","propsArray","resolvedStyle","resolved","j","propName","propValue","resolveStyles","computeMediaQueries","default"],"mappings":"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","sourcesContent":["import { compose, castArray, parseFloat as parseFloat$1, matchPercent } from '@react-pdf/fns';\r\nimport matchMedia from 'media-engine';\r\nimport hlsToHex from 'hsl-to-hex';\r\nimport colorString from 'color-string';\r\nimport parse$1 from 'postcss-value-parser/lib/parse.js';\r\nimport parseUnit from 'postcss-value-parser/lib/unit.js';\r\n\r\n/**\r\n * Remove nil values from array\r\n *\r\n * @param array - Style array\r\n * @returns Style array without nils\r\n */\r\nconst compact = (array) => array.filter(Boolean);\r\n/**\r\n * Merges style objects array\r\n *\r\n * @param styles - Style array\r\n * @returns Merged style object\r\n */\r\nconst mergeStyles = (styles) => styles.reduce((acc, style) => {\r\n    const s = Array.isArray(style) ? flatten(style) : style;\r\n    Object.keys(s).forEach((key) => {\r\n        if (s[key] !== null && s[key] !== undefined) {\r\n            acc[key] = s[key];\r\n        }\r\n    });\r\n    return acc;\r\n}, {});\r\n/**\r\n * Flattens an array of style objects, into one aggregated style object.\r\n *\r\n * @param styles - Style or style array\r\n * @returns Flattened style object\r\n */\r\nconst flatten = compose(mergeStyles, compact, (castArray));\r\n\r\n/**\r\n * Resolves media queries in styles object\r\n *\r\n * @param container - Container for which styles are resolved\r\n * @param style - Style description\r\n * @returns Resolved style object\r\n */\r\nconst resolveMediaQueries = (container, style) => {\r\n    return Object.keys(style).reduce((acc, key) => {\r\n        if (/@media/.test(key)) {\r\n            return {\r\n                ...acc,\r\n                ...matchMedia({ [key]: style[key] }, container),\r\n            };\r\n        }\r\n        return { ...acc, [key]: style[key] };\r\n    }, {});\r\n};\r\n\r\nconst isRgb = (value) => /rgba?/g.test(value);\r\nconst isHsl = (value) => /hsla?/g.test(value);\r\n/**\r\n * Transform rgb color to hexa\r\n *\r\n * @param value - Styles value\r\n * @returns Transformed value\r\n */\r\nconst parseRgb = (value) => {\r\n    const rgb = colorString.get.rgb(value);\r\n    return colorString.to.hex(rgb);\r\n};\r\n/**\r\n * Transform Hsl color to hexa\r\n *\r\n * @param value - Styles value\r\n * @returns Transformed value\r\n */\r\nconst parseHsl = (value) => {\r\n    const hsl = colorString.get.hsl(value).map(Math.round);\r\n    const hex = hlsToHex(...hsl);\r\n    return hex.toUpperCase();\r\n};\r\n/**\r\n * Transform given color to hexa\r\n *\r\n * @param value - Styles value\r\n * @returns Transformed value\r\n */\r\nconst transformColor = (value) => {\r\n    if (isRgb(value))\r\n        return parseRgb(value);\r\n    if (isHsl(value))\r\n        return parseHsl(value);\r\n    return value;\r\n};\r\n\r\n/**\r\n * Parses scalar value in value and unit pairs\r\n *\r\n * @param value - Scalar value\r\n * @returns Parsed value\r\n */\r\nconst parseValue = (value) => {\r\n    if (typeof value === 'number')\r\n        return { value, unit: undefined };\r\n    const match = /^(-?\\d*\\.?\\d+)(in|mm|cm|pt|vh|vw|px|rem)?$/g.exec(value);\r\n    return match\r\n        ? { value: parseFloat(match[1]), unit: match[2] || 'pt' }\r\n        : { value, unit: undefined };\r\n};\r\n/**\r\n * Transform given scalar value\r\n *\r\n * @param container\r\n * @param value - Styles value\r\n * @returns Transformed value\r\n */\r\nconst transformUnit = (container, value) => {\r\n    const scalar = parseValue(value);\r\n    const outputDpi = 72;\r\n    const inputDpi = container.dpi || 72;\r\n    const mmFactor = (1 / 25.4) * outputDpi;\r\n    const cmFactor = (1 / 2.54) * outputDpi;\r\n    if (typeof scalar.value !== 'number')\r\n        return scalar.value;\r\n    switch (scalar.unit) {\r\n        case 'rem':\r\n            return scalar.value * (container.remBase || 18);\r\n        case 'in':\r\n            return scalar.value * outputDpi;\r\n        case 'mm':\r\n            return scalar.value * mmFactor;\r\n        case 'cm':\r\n            return scalar.value * cmFactor;\r\n        case 'vh':\r\n            return scalar.value * (container.height / 100);\r\n        case 'vw':\r\n            return scalar.value * (container.width / 100);\r\n        case 'px':\r\n            return Math.round(scalar.value * (outputDpi / inputDpi));\r\n        default:\r\n            return scalar.value;\r\n    }\r\n};\r\n\r\nconst processNumberValue = (key, value) => ({\r\n    [key]: parseFloat$1(value),\r\n});\r\nconst processUnitValue = (key, value, container) => ({\r\n    [key]: transformUnit(container, value),\r\n});\r\nconst processColorValue = (key, value) => {\r\n    const result = { [key]: transformColor(value) };\r\n    return result;\r\n};\r\nconst processNoopValue = (key, value) => ({\r\n    [key]: value,\r\n});\r\n\r\nconst BORDER_SHORTHAND_REGEX = /(-?\\d+(\\.\\d+)?(in|mm|cm|pt|vw|vh|px|rem)?)\\s(\\S+)\\s(.+)/;\r\nconst matchBorderShorthand = (value) => value.match(BORDER_SHORTHAND_REGEX) || [];\r\nconst resolveBorderShorthand = (key, value, container) => {\r\n    const match = matchBorderShorthand(`${value}`);\r\n    if (match) {\r\n        const widthMatch = match[1] || value;\r\n        const styleMatch = match[4] || value;\r\n        const colorMatch = match[5] || value;\r\n        const style = styleMatch;\r\n        const color = colorMatch ? transformColor(colorMatch) : undefined;\r\n        const width = widthMatch ? transformUnit(container, widthMatch) : undefined;\r\n        if (key.match(/(Top|Right|Bottom|Left)$/)) {\r\n            return {\r\n                [`${key}Color`]: color,\r\n                [`${key}Style`]: style,\r\n                [`${key}Width`]: width,\r\n            };\r\n        }\r\n        if (key.match(/Color$/)) {\r\n            return {\r\n                borderTopColor: color,\r\n                borderRightColor: color,\r\n                borderBottomColor: color,\r\n                borderLeftColor: color,\r\n            };\r\n        }\r\n        if (key.match(/Style$/)) {\r\n            if (typeof style === 'number')\r\n                throw new Error(`Invalid border style: ${style}`);\r\n            return {\r\n                borderTopStyle: style,\r\n                borderRightStyle: style,\r\n                borderBottomStyle: style,\r\n                borderLeftStyle: style,\r\n            };\r\n        }\r\n        if (key.match(/Width$/)) {\r\n            if (typeof width !== 'number')\r\n                throw new Error(`Invalid border width: ${width}`);\r\n            return {\r\n                borderTopWidth: width,\r\n                borderRightWidth: width,\r\n                borderBottomWidth: width,\r\n                borderLeftWidth: width,\r\n            };\r\n        }\r\n        if (key.match(/Radius$/)) {\r\n            const radius = value ? transformUnit(container, value) : undefined;\r\n            if (typeof radius !== 'number')\r\n                throw new Error(`Invalid border radius: ${radius}`);\r\n            return {\r\n                borderTopLeftRadius: radius,\r\n                borderTopRightRadius: radius,\r\n                borderBottomRightRadius: radius,\r\n                borderBottomLeftRadius: radius,\r\n            };\r\n        }\r\n        if (typeof width !== 'number')\r\n            throw new Error(`Invalid border width: ${width}`);\r\n        if (typeof style === 'number')\r\n            throw new Error(`Invalid border style: ${style}`);\r\n        return {\r\n            borderTopColor: color,\r\n            borderTopStyle: style,\r\n            borderTopWidth: width,\r\n            borderRightColor: color,\r\n            borderRightStyle: style,\r\n            borderRightWidth: width,\r\n            borderBottomColor: color,\r\n            borderBottomStyle: style,\r\n            borderBottomWidth: width,\r\n            borderLeftColor: color,\r\n            borderLeftStyle: style,\r\n            borderLeftWidth: width,\r\n        };\r\n    }\r\n    return { [key]: value };\r\n};\r\nconst handlers$b = {\r\n    border: (resolveBorderShorthand),\r\n    borderBottom: (resolveBorderShorthand),\r\n    borderBottomColor: (processColorValue),\r\n    borderBottomLeftRadius: (processUnitValue),\r\n    borderBottomRightRadius: (processUnitValue),\r\n    borderBottomStyle: (processNoopValue),\r\n    borderBottomWidth: (processUnitValue),\r\n    borderColor: (resolveBorderShorthand),\r\n    borderLeft: (resolveBorderShorthand),\r\n    borderLeftColor: (processColorValue),\r\n    borderLeftStyle: (processNoopValue),\r\n    borderLeftWidth: (processUnitValue),\r\n    borderRadius: (resolveBorderShorthand),\r\n    borderRight: (resolveBorderShorthand),\r\n    borderRightColor: (processColorValue),\r\n    borderRightStyle: (processNoopValue),\r\n    borderRightWidth: (processUnitValue),\r\n    borderStyle: (resolveBorderShorthand),\r\n    borderTop: (resolveBorderShorthand),\r\n    borderTopColor: (processColorValue),\r\n    borderTopLeftRadius: (processUnitValue),\r\n    borderTopRightRadius: (processUnitValue),\r\n    borderTopStyle: (processNoopValue),\r\n    borderTopWidth: (processUnitValue),\r\n    borderWidth: (resolveBorderShorthand),\r\n};\r\n\r\nconst handlers$a = {\r\n    backgroundColor: (processColorValue),\r\n    color: (processColorValue),\r\n    opacity: (processNumberValue),\r\n};\r\n\r\nconst handlers$9 = {\r\n    height: (processUnitValue),\r\n    maxHeight: (processUnitValue),\r\n    maxWidth: (processUnitValue),\r\n    minHeight: (processUnitValue),\r\n    minWidth: (processUnitValue),\r\n    width: (processUnitValue),\r\n};\r\n\r\n// https://developer.mozilla.org/en-US/docs/Web/CSS/flex#values\r\n// TODO: change flex defaults to [0, 1, 'auto'] as in spec in next major release\r\nconst flexDefaults = [1, 1, 0];\r\nconst flexAuto = [1, 1, 'auto'];\r\nconst processFlexShorthand = (key, value, container) => {\r\n    let defaults = flexDefaults;\r\n    let matches = [];\r\n    if (value === 'auto') {\r\n        defaults = flexAuto;\r\n    }\r\n    else {\r\n        matches = `${value}`.split(' ');\r\n    }\r\n    const flexGrow = parseFloat$1(matches[0] || defaults[0]);\r\n    const flexShrink = parseFloat$1(matches[1] || defaults[1]);\r\n    const flexBasis = transformUnit(container, matches[2] || defaults[2]);\r\n    return { flexGrow, flexShrink, flexBasis };\r\n};\r\nconst handlers$8 = {\r\n    alignContent: (processNoopValue),\r\n    alignItems: (processNoopValue),\r\n    alignSelf: (processNoopValue),\r\n    flex: (processFlexShorthand),\r\n    flexBasis: (processUnitValue),\r\n    flexDirection: (processNoopValue),\r\n    flexFlow: (processNoopValue),\r\n    flexGrow: (processNumberValue),\r\n    flexShrink: (processNumberValue),\r\n    flexWrap: (processNoopValue),\r\n    justifyContent: (processNoopValue),\r\n    justifySelf: (processNoopValue),\r\n};\r\n\r\nconst processGapShorthand = (key, value, container) => {\r\n    const match = `${value}`.split(' ');\r\n    const rowGap = transformUnit(container, match?.[0] || value);\r\n    const columnGap = transformUnit(container, match?.[1] || value);\r\n    return { rowGap, columnGap };\r\n};\r\nconst handlers$7 = {\r\n    gap: (processGapShorthand),\r\n    columnGap: (processUnitValue),\r\n    rowGap: (processUnitValue),\r\n};\r\n\r\nconst handlers$6 = {\r\n    aspectRatio: (processNumberValue),\r\n    bottom: (processUnitValue),\r\n    display: (processNoopValue),\r\n    left: (processUnitValue),\r\n    position: (processNoopValue),\r\n    right: (processUnitValue),\r\n    top: (processUnitValue),\r\n    overflow: (processNoopValue),\r\n    zIndex: (processNumberValue),\r\n};\r\n\r\nconst BOX_MODEL_UNITS = 'px,in,mm,cm,pt,%,vw,vh';\r\nconst logError = (style, value) => {\r\n    const name = style.toString();\r\n    // eslint-disable-next-line no-console\r\n    console.error(`\r\n    @react-pdf/stylesheet parsing error:\r\n    ${name}: ${value},\r\n    ${' '.repeat(name.length + 2)}^\r\n    Unsupported ${name} value format\r\n  `);\r\n};\r\n/**\r\n * @param options\r\n * @param [options.expandsTo]\r\n * @param [options.maxValues]\r\n * @param [options.autoSupported]\r\n */\r\nconst expandBoxModel = ({ expandsTo, maxValues = 1, autoSupported = false, } = {}) => (model, value, container) => {\r\n    const nodes = parse$1(`${value}`);\r\n    const parts = [];\r\n    for (let i = 0; i < nodes.length; i++) {\r\n        const node = nodes[i];\r\n        // value contains `calc`, `url` or other css function\r\n        // `,`, `/` or strings that unsupported by margin and padding\r\n        if (node.type === 'function' ||\r\n            node.type === 'string' ||\r\n            node.type === 'div') {\r\n            logError(model, value);\r\n            return {};\r\n        }\r\n        if (node.type === 'word') {\r\n            if (node.value === 'auto' && autoSupported) {\r\n                parts.push(node.value);\r\n            }\r\n            else {\r\n                const result = parseUnit(node.value);\r\n                // when unit isn't specified this condition is true\r\n                if (result && BOX_MODEL_UNITS.includes(result.unit)) {\r\n                    parts.push(node.value);\r\n                }\r\n                else {\r\n                    logError(model, value);\r\n                    return {};\r\n                }\r\n            }\r\n        }\r\n    }\r\n    // checks that we have enough parsed values\r\n    if (parts.length > maxValues) {\r\n        logError(model, value);\r\n        return {};\r\n    }\r\n    const first = transformUnit(container, parts[0]);\r\n    if (expandsTo) {\r\n        const second = transformUnit(container, parts[1] || parts[0]);\r\n        const third = transformUnit(container, parts[2] || parts[0]);\r\n        const fourth = transformUnit(container, parts[3] || parts[1] || parts[0]);\r\n        return expandsTo({ first, second, third, fourth });\r\n    }\r\n    return {\r\n        [model]: first,\r\n    };\r\n};\r\n\r\nconst processMargin = expandBoxModel({\r\n    expandsTo: ({ first, second, third, fourth }) => ({\r\n        marginTop: first,\r\n        marginRight: second,\r\n        marginBottom: third,\r\n        marginLeft: fourth,\r\n    }),\r\n    maxValues: 4,\r\n    autoSupported: true,\r\n});\r\nconst processMarginVertical = expandBoxModel({\r\n    expandsTo: ({ first, second }) => ({\r\n        marginTop: first,\r\n        marginBottom: second,\r\n    }),\r\n    maxValues: 2,\r\n    autoSupported: true,\r\n});\r\nconst processMarginHorizontal = expandBoxModel({\r\n    expandsTo: ({ first, second }) => ({\r\n        marginRight: first,\r\n        marginLeft: second,\r\n    }),\r\n    maxValues: 2,\r\n    autoSupported: true,\r\n});\r\nconst processMarginSingle = expandBoxModel({\r\n    autoSupported: true,\r\n});\r\nconst handlers$5 = {\r\n    margin: (processMargin),\r\n    marginBottom: (processMarginSingle),\r\n    marginHorizontal: (processMarginHorizontal),\r\n    marginLeft: (processMarginSingle),\r\n    marginRight: (processMarginSingle),\r\n    marginTop: (processMarginSingle),\r\n    marginVertical: (processMarginVertical),\r\n};\r\n\r\nconst processPadding = expandBoxModel({\r\n    expandsTo: ({ first, second, third, fourth }) => ({\r\n        paddingTop: first,\r\n        paddingRight: second,\r\n        paddingBottom: third,\r\n        paddingLeft: fourth,\r\n    }),\r\n    maxValues: 4,\r\n});\r\nconst processPaddingVertical = expandBoxModel({\r\n    expandsTo: ({ first, second }) => ({\r\n        paddingTop: first,\r\n        paddingBottom: second,\r\n    }),\r\n    maxValues: 2,\r\n});\r\nconst processPaddingHorizontal = expandBoxModel({\r\n    expandsTo: ({ first, second }) => ({\r\n        paddingRight: first,\r\n        paddingLeft: second,\r\n    }),\r\n    maxValues: 2,\r\n});\r\nconst processPaddingSingle = expandBoxModel();\r\nconst handlers$4 = {\r\n    padding: (processPadding),\r\n    paddingBottom: (processPaddingSingle),\r\n    paddingHorizontal: (processPaddingHorizontal),\r\n    paddingLeft: (processPaddingSingle),\r\n    paddingRight: (processPaddingSingle),\r\n    paddingTop: (processPaddingSingle),\r\n    paddingVertical: (processPaddingVertical),\r\n};\r\n\r\nconst offsetKeyword = (value) => {\r\n    switch (value) {\r\n        case 'top':\r\n        case 'left':\r\n            return '0%';\r\n        case 'right':\r\n        case 'bottom':\r\n            return '100%';\r\n        case 'center':\r\n            return '50%';\r\n        default:\r\n            return value;\r\n    }\r\n};\r\n\r\nconst processObjectPosition = (key, value, container) => {\r\n    const match = `${value}`.split(' ');\r\n    const objectPositionX = offsetKeyword(transformUnit(container, match?.[0] || value));\r\n    const objectPositionY = offsetKeyword(transformUnit(container, match?.[1] || value));\r\n    return { objectPositionX, objectPositionY };\r\n};\r\nconst processObjectPositionValue = (key, value, container) => ({\r\n    [key]: offsetKeyword(transformUnit(container, value)),\r\n});\r\nconst handlers$3 = {\r\n    objectPosition: (processObjectPosition),\r\n    objectPositionX: (processObjectPositionValue),\r\n    objectPositionY: (processObjectPositionValue),\r\n    objectFit: (processNoopValue),\r\n};\r\n\r\nconst castInt = (value) => {\r\n    if (typeof value === 'number')\r\n        return value;\r\n    return parseInt(value, 10);\r\n};\r\n\r\nconst FONT_WEIGHTS = {\r\n    thin: 100,\r\n    hairline: 100,\r\n    ultralight: 200,\r\n    extralight: 200,\r\n    light: 300,\r\n    normal: 400,\r\n    medium: 500,\r\n    semibold: 600,\r\n    demibold: 600,\r\n    bold: 700,\r\n    ultrabold: 800,\r\n    extrabold: 800,\r\n    heavy: 900,\r\n    black: 900,\r\n};\r\nconst transformFontWeight = (value) => {\r\n    if (!value)\r\n        return FONT_WEIGHTS.normal;\r\n    if (typeof value === 'number')\r\n        return value;\r\n    const lv = value.toLowerCase();\r\n    if (FONT_WEIGHTS[lv])\r\n        return FONT_WEIGHTS[lv];\r\n    return castInt(value);\r\n};\r\nconst processFontWeight = (key, value) => {\r\n    return { [key]: transformFontWeight(value) };\r\n};\r\nconst transformLineHeight = (value, styles, container) => {\r\n    if (value === '')\r\n        return value;\r\n    const fontSize = transformUnit(container, styles.fontSize || 18);\r\n    const lineHeight = transformUnit(container, value);\r\n    // Percent values: use this number multiplied by the element's font size\r\n    const { percent } = matchPercent(lineHeight) || {};\r\n    if (percent)\r\n        return percent * fontSize;\r\n    // Unitless values: use this number multiplied by the element's font size\r\n    return isNaN(value) ? lineHeight : lineHeight * fontSize;\r\n};\r\nconst processLineHeight = (key, value, container, styles) => {\r\n    return {\r\n        [key]: transformLineHeight(value, styles, container),\r\n    };\r\n};\r\nconst handlers$2 = {\r\n    direction: (processNoopValue),\r\n    fontFamily: (processNoopValue),\r\n    fontSize: (processUnitValue),\r\n    fontStyle: (processNoopValue),\r\n    fontWeight: (processFontWeight),\r\n    letterSpacing: (processUnitValue),\r\n    lineHeight: (processLineHeight),\r\n    maxLines: (processNumberValue),\r\n    textAlign: (processNoopValue),\r\n    textDecoration: (processNoopValue),\r\n    textDecorationColor: (processColorValue),\r\n    textDecorationStyle: (processNoopValue),\r\n    textIndent: (processNoopValue),\r\n    textOverflow: (processNoopValue),\r\n    textTransform: (processNoopValue),\r\n    verticalAlign: (processNoopValue),\r\n};\r\n\r\nconst matchNumber = (value) => typeof value === 'string' && /^-?\\d*\\.?\\d*$/.test(value);\r\nconst castFloat = (value) => {\r\n    if (typeof value !== 'string')\r\n        return value;\r\n    if (matchNumber(value))\r\n        return parseFloat(value);\r\n    return value;\r\n};\r\n\r\nconst parse = (transformString) => {\r\n    const transforms = transformString.trim().split(/\\)[ ,]|\\)/);\r\n    // Handle \"initial\", \"inherit\", \"unset\".\r\n    if (transforms.length === 1) {\r\n        return [[transforms[0], true]];\r\n    }\r\n    const parsed = [];\r\n    for (let i = 0; i < transforms.length; i += 1) {\r\n        const transform = transforms[i];\r\n        if (transform) {\r\n            const [name, rawValue] = transform.split('(');\r\n            const splitChar = rawValue.indexOf(',') >= 0 ? ',' : ' ';\r\n            const value = rawValue.split(splitChar).map((val) => val.trim());\r\n            parsed.push({ operation: name.trim(), value });\r\n        }\r\n    }\r\n    return parsed;\r\n};\r\nconst parseAngle = (value) => {\r\n    const unitsRegexp = /(-?\\d*\\.?\\d*)(\\w*)?/i;\r\n    const [, angle, unit] = unitsRegexp.exec(value);\r\n    const number = Number.parseFloat(angle);\r\n    return unit === 'rad' ? (number * 180) / Math.PI : number;\r\n};\r\nconst normalizeTransformOperation = ({ operation, value }) => {\r\n    switch (operation) {\r\n        case 'scale': {\r\n            const [scaleX, scaleY = scaleX] = value.map((num) => Number.parseFloat(num));\r\n            return { operation: 'scale', value: [scaleX, scaleY] };\r\n        }\r\n        case 'scaleX': {\r\n            return { operation: 'scale', value: [Number.parseFloat(value), 1] };\r\n        }\r\n        case 'scaleY': {\r\n            return { operation: 'scale', value: [1, Number.parseFloat(value)] };\r\n        }\r\n        case 'rotate': {\r\n            return { operation: 'rotate', value: [parseAngle(value)] };\r\n        }\r\n        case 'translate': {\r\n            return {\r\n                operation: 'translate',\r\n                value: value.map((num) => Number.parseFloat(num)),\r\n            };\r\n        }\r\n        case 'translateX': {\r\n            return {\r\n                operation: 'translate',\r\n                value: [Number.parseFloat(value), 0],\r\n            };\r\n        }\r\n        case 'translateY': {\r\n            return { operation: 'translate', value: [0, Number.parseFloat(value)] };\r\n        }\r\n        case 'skew': {\r\n            return { operation: 'skew', value: value.map(parseAngle) };\r\n        }\r\n        case 'skewX': {\r\n            return { operation: 'skew', value: [parseAngle(value), 0] };\r\n        }\r\n        case 'skewY': {\r\n            return { operation: 'skew', value: [0, parseAngle(value)] };\r\n        }\r\n        default: {\r\n            return { operation, value: value.map((num) => Number.parseFloat(num)) };\r\n        }\r\n    }\r\n};\r\nconst normalize = (operations) => {\r\n    return operations.map((operation) => normalizeTransformOperation(operation));\r\n};\r\nconst processTransform = (key, value) => {\r\n    if (typeof value !== 'string')\r\n        return { [key]: value };\r\n    return { [key]: normalize(parse(value)) };\r\n};\r\nconst Y_AXIS_SHORTHANDS = { top: true, bottom: true };\r\nconst sortTransformOriginPair = (a, b) => {\r\n    if (Y_AXIS_SHORTHANDS[a])\r\n        return 1;\r\n    if (Y_AXIS_SHORTHANDS[b])\r\n        return -1;\r\n    return 0;\r\n};\r\nconst getTransformOriginPair = (values) => {\r\n    if (!values || values.length === 0)\r\n        return ['center', 'center'];\r\n    const pair = values.length === 1 ? [values[0], 'center'] : values;\r\n    return pair.sort(sortTransformOriginPair);\r\n};\r\n// Transforms shorthand transformOrigin values\r\nconst processTransformOriginShorthand = (key, value, container) => {\r\n    const match = `${value}`.split(' ');\r\n    const pair = getTransformOriginPair(match);\r\n    const transformOriginX = transformUnit(container, pair[0]);\r\n    const transformOriginY = transformUnit(container, pair[1]);\r\n    return {\r\n        transformOriginX: offsetKeyword(transformOriginX) || castFloat(transformOriginX),\r\n        transformOriginY: offsetKeyword(transformOriginY) || castFloat(transformOriginY),\r\n    };\r\n};\r\nconst processTransformOriginValue = (key, value, container) => {\r\n    const v = transformUnit(container, value);\r\n    return { [key]: offsetKeyword(v) || castFloat(v) };\r\n};\r\nconst handlers$1 = {\r\n    transform: processTransform,\r\n    gradientTransform: processTransform,\r\n    transformOrigin: (processTransformOriginShorthand),\r\n    transformOriginX: (processTransformOriginValue),\r\n    transformOriginY: (processTransformOriginValue),\r\n};\r\n\r\nconst handlers = {\r\n    fill: (processColorValue),\r\n    stroke: (processColorValue),\r\n    strokeDasharray: (processNoopValue),\r\n    strokeWidth: (processUnitValue),\r\n    fillOpacity: (processNumberValue),\r\n    strokeOpacity: (processNumberValue),\r\n    fillRule: (processNoopValue),\r\n    textAnchor: (processNoopValue),\r\n    strokeLinecap: (processNoopValue),\r\n    strokeLinejoin: (processNoopValue),\r\n    visibility: (processNoopValue),\r\n    clipPath: (processNoopValue),\r\n    dominantBaseline: (processNoopValue),\r\n};\r\n\r\nconst shorthands = {\r\n    ...handlers$b,\r\n    ...handlers$a,\r\n    ...handlers$9,\r\n    ...handlers$8,\r\n    ...handlers$7,\r\n    ...handlers$6,\r\n    ...handlers$5,\r\n    ...handlers$4,\r\n    ...handlers$3,\r\n    ...handlers$2,\r\n    ...handlers$1,\r\n    ...handlers,\r\n};\r\n/**\r\n * Expand the shorthand properties.\r\n *\r\n * @param style - Style object\r\n * @returns Expanded style object\r\n */\r\nconst resolve = (container) => (style) => {\r\n    const propsArray = Object.keys(style);\r\n    const resolvedStyle = {};\r\n    for (let i = 0; i < propsArray.length; i += 1) {\r\n        const key = propsArray[i];\r\n        const value = style[key];\r\n        if (!shorthands[key]) {\r\n            resolvedStyle[key] = value;\r\n            continue;\r\n        }\r\n        const resolved = shorthands[key](key, value, container, style);\r\n        const keys = Object.keys(resolved);\r\n        for (let j = 0; j < keys.length; j += 1) {\r\n            const propName = keys[j];\r\n            const propValue = resolved[propName];\r\n            resolvedStyle[propName] = propValue;\r\n        }\r\n    }\r\n    return resolvedStyle;\r\n};\r\n\r\n/**\r\n * Resolves styles\r\n *\r\n * @param container\r\n * @param style - Style\r\n * @returns Resolved style\r\n */\r\nconst resolveStyles = (container, style) => {\r\n    const computeMediaQueries = (value) => resolveMediaQueries(container, value);\r\n    return compose(resolve(container), computeMediaQueries, flatten)(style);\r\n};\r\n\r\nexport { resolveStyles as default, flatten, transformColor };\r\n"]},"metadata":{},"sourceType":"module"}