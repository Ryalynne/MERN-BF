{"ast":null,"code":"import { motionValue } from 'motion-dom';\nimport { warnOnce } from 'motion-utils';\nimport { isMotionValue } from '../../value/utils/is-motion-value.mjs';\n\nfunction updateMotionValuesFromProps(element, next, prev) {\n  for (const key in next) {\n    const nextValue = next[key];\n    const prevValue = prev[key];\n\n    if (isMotionValue(nextValue)) {\n      /**\r\n       * If this is a motion value found in props or style, we want to add it\r\n       * to our visual element's motion value map.\r\n       */\n      element.addValue(key, nextValue);\n      /**\r\n       * Check the version of the incoming motion value with this version\r\n       * and warn against mismatches.\r\n       */\n\n      if (process.env.NODE_ENV === \"development\") {\n        warnOnce(nextValue.version === \"12.5.0\", `Attempting to mix Motion versions ${nextValue.version} with 12.5.0 may not work as expected.`);\n      }\n    } else if (isMotionValue(prevValue)) {\n      /**\r\n       * If we're swapping from a motion value to a static value,\r\n       * create a new motion value from that\r\n       */\n      element.addValue(key, motionValue(nextValue, {\n        owner: element\n      }));\n    } else if (prevValue !== nextValue) {\n      /**\r\n       * If this is a flat value that has changed, update the motion value\r\n       * or create one if it doesn't exist. We only want to do this if we're\r\n       * not handling the value with our animation state.\r\n       */\n      if (element.hasValue(key)) {\n        const existingValue = element.getValue(key);\n\n        if (existingValue.liveStyle === true) {\n          existingValue.jump(nextValue);\n        } else if (!existingValue.hasAnimated) {\n          existingValue.set(nextValue);\n        }\n      } else {\n        const latestValue = element.getStaticValue(key);\n        element.addValue(key, motionValue(latestValue !== undefined ? latestValue : nextValue, {\n          owner: element\n        }));\n      }\n    }\n  } // Handle removed values\n\n\n  for (const key in prev) {\n    if (next[key] === undefined) element.removeValue(key);\n  }\n\n  return next;\n}\n\nexport { updateMotionValuesFromProps };","map":{"version":3,"sources":["C:/Users/PC/Documents/PROGRAMMING/New folder/MERN-BF/frontend/node_modules/framer-motion/dist/es/render/utils/motion-values.mjs"],"names":["motionValue","warnOnce","isMotionValue","updateMotionValuesFromProps","element","next","prev","key","nextValue","prevValue","addValue","process","env","NODE_ENV","version","owner","hasValue","existingValue","getValue","liveStyle","jump","hasAnimated","set","latestValue","getStaticValue","undefined","removeValue"],"mappings":"AAAA,SAASA,WAAT,QAA4B,YAA5B;AACA,SAASC,QAAT,QAAyB,cAAzB;AACA,SAASC,aAAT,QAA8B,uCAA9B;;AAEA,SAASC,2BAAT,CAAqCC,OAArC,EAA8CC,IAA9C,EAAoDC,IAApD,EAA0D;AACtD,OAAK,MAAMC,GAAX,IAAkBF,IAAlB,EAAwB;AACpB,UAAMG,SAAS,GAAGH,IAAI,CAACE,GAAD,CAAtB;AACA,UAAME,SAAS,GAAGH,IAAI,CAACC,GAAD,CAAtB;;AACA,QAAIL,aAAa,CAACM,SAAD,CAAjB,EAA8B;AAC1B;AACZ;AACA;AACA;AACYJ,MAAAA,OAAO,CAACM,QAAR,CAAiBH,GAAjB,EAAsBC,SAAtB;AACA;AACZ;AACA;AACA;;AACY,UAAIG,OAAO,CAACC,GAAR,CAAYC,QAAZ,KAAyB,aAA7B,EAA4C;AACxCZ,QAAAA,QAAQ,CAACO,SAAS,CAACM,OAAV,KAAsB,QAAvB,EAAkC,qCAAoCN,SAAS,CAACM,OAAQ,wCAAxF,CAAR;AACH;AACJ,KAbD,MAcK,IAAIZ,aAAa,CAACO,SAAD,CAAjB,EAA8B;AAC/B;AACZ;AACA;AACA;AACYL,MAAAA,OAAO,CAACM,QAAR,CAAiBH,GAAjB,EAAsBP,WAAW,CAACQ,SAAD,EAAY;AAAEO,QAAAA,KAAK,EAAEX;AAAT,OAAZ,CAAjC;AACH,KANI,MAOA,IAAIK,SAAS,KAAKD,SAAlB,EAA6B;AAC9B;AACZ;AACA;AACA;AACA;AACY,UAAIJ,OAAO,CAACY,QAAR,CAAiBT,GAAjB,CAAJ,EAA2B;AACvB,cAAMU,aAAa,GAAGb,OAAO,CAACc,QAAR,CAAiBX,GAAjB,CAAtB;;AACA,YAAIU,aAAa,CAACE,SAAd,KAA4B,IAAhC,EAAsC;AAClCF,UAAAA,aAAa,CAACG,IAAd,CAAmBZ,SAAnB;AACH,SAFD,MAGK,IAAI,CAACS,aAAa,CAACI,WAAnB,EAAgC;AACjCJ,UAAAA,aAAa,CAACK,GAAd,CAAkBd,SAAlB;AACH;AACJ,OARD,MASK;AACD,cAAMe,WAAW,GAAGnB,OAAO,CAACoB,cAAR,CAAuBjB,GAAvB,CAApB;AACAH,QAAAA,OAAO,CAACM,QAAR,CAAiBH,GAAjB,EAAsBP,WAAW,CAACuB,WAAW,KAAKE,SAAhB,GAA4BF,WAA5B,GAA0Cf,SAA3C,EAAsD;AAAEO,UAAAA,KAAK,EAAEX;AAAT,SAAtD,CAAjC;AACH;AACJ;AACJ,GA7CqD,CA8CtD;;;AACA,OAAK,MAAMG,GAAX,IAAkBD,IAAlB,EAAwB;AACpB,QAAID,IAAI,CAACE,GAAD,CAAJ,KAAckB,SAAlB,EACIrB,OAAO,CAACsB,WAAR,CAAoBnB,GAApB;AACP;;AACD,SAAOF,IAAP;AACH;;AAED,SAASF,2BAAT","sourcesContent":["import { motionValue } from 'motion-dom';\r\nimport { warnOnce } from 'motion-utils';\r\nimport { isMotionValue } from '../../value/utils/is-motion-value.mjs';\r\n\r\nfunction updateMotionValuesFromProps(element, next, prev) {\r\n    for (const key in next) {\r\n        const nextValue = next[key];\r\n        const prevValue = prev[key];\r\n        if (isMotionValue(nextValue)) {\r\n            /**\r\n             * If this is a motion value found in props or style, we want to add it\r\n             * to our visual element's motion value map.\r\n             */\r\n            element.addValue(key, nextValue);\r\n            /**\r\n             * Check the version of the incoming motion value with this version\r\n             * and warn against mismatches.\r\n             */\r\n            if (process.env.NODE_ENV === \"development\") {\r\n                warnOnce(nextValue.version === \"12.5.0\", `Attempting to mix Motion versions ${nextValue.version} with 12.5.0 may not work as expected.`);\r\n            }\r\n        }\r\n        else if (isMotionValue(prevValue)) {\r\n            /**\r\n             * If we're swapping from a motion value to a static value,\r\n             * create a new motion value from that\r\n             */\r\n            element.addValue(key, motionValue(nextValue, { owner: element }));\r\n        }\r\n        else if (prevValue !== nextValue) {\r\n            /**\r\n             * If this is a flat value that has changed, update the motion value\r\n             * or create one if it doesn't exist. We only want to do this if we're\r\n             * not handling the value with our animation state.\r\n             */\r\n            if (element.hasValue(key)) {\r\n                const existingValue = element.getValue(key);\r\n                if (existingValue.liveStyle === true) {\r\n                    existingValue.jump(nextValue);\r\n                }\r\n                else if (!existingValue.hasAnimated) {\r\n                    existingValue.set(nextValue);\r\n                }\r\n            }\r\n            else {\r\n                const latestValue = element.getStaticValue(key);\r\n                element.addValue(key, motionValue(latestValue !== undefined ? latestValue : nextValue, { owner: element }));\r\n            }\r\n        }\r\n    }\r\n    // Handle removed values\r\n    for (const key in prev) {\r\n        if (next[key] === undefined)\r\n            element.removeValue(key);\r\n    }\r\n    return next;\r\n}\r\n\r\nexport { updateMotionValuesFromProps };\r\n"]},"metadata":{},"sourceType":"module"}