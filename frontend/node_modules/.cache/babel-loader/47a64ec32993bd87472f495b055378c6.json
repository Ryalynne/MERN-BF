{"ast":null,"code":"import { time } from 'motion-dom';\nimport { flushKeyframeResolvers } from '../../render/utils/KeyframesResolver.mjs';\nimport { instantAnimationState } from '../../utils/use-instant-transition-state.mjs';\nimport { canAnimate } from './utils/can-animate.mjs';\nimport { getFinalKeyframe } from './waapi/utils/get-final-keyframe.mjs';\n/**\r\n * Maximum time allowed between an animation being created and it being\r\n * resolved for us to use the latter as the start time.\r\n *\r\n * This is to ensure that while we prefer to \"start\" an animation as soon\r\n * as it's triggered, we also want to avoid a visual jump if there's a big delay\r\n * between these two moments.\r\n */\n\nconst MAX_RESOLVE_DELAY = 40;\n\nclass BaseAnimation {\n  constructor(_ref) {\n    let {\n      autoplay = true,\n      delay = 0,\n      type = \"keyframes\",\n      repeat = 0,\n      repeatDelay = 0,\n      repeatType = \"loop\",\n      ...options\n    } = _ref;\n    // Track whether the animation has been stopped. Stopped animations won't restart.\n    this.isStopped = false;\n    this.hasAttemptedResolve = false;\n    this.createdAt = time.now();\n    this.options = {\n      autoplay,\n      delay,\n      type,\n      repeat,\n      repeatDelay,\n      repeatType,\n      ...options\n    };\n    this.updateFinishedPromise();\n  }\n  /**\r\n   * This method uses the createdAt and resolvedAt to calculate the\r\n   * animation startTime. *Ideally*, we would use the createdAt time as t=0\r\n   * as the following frame would then be the first frame of the animation in\r\n   * progress, which would feel snappier.\r\n   *\r\n   * However, if there's a delay (main thread work) between the creation of\r\n   * the animation and the first commited frame, we prefer to use resolvedAt\r\n   * to avoid a sudden jump into the animation.\r\n   */\n\n\n  calcStartTime() {\n    if (!this.resolvedAt) return this.createdAt;\n    return this.resolvedAt - this.createdAt > MAX_RESOLVE_DELAY ? this.resolvedAt : this.createdAt;\n  }\n  /**\r\n   * A getter for resolved data. If keyframes are not yet resolved, accessing\r\n   * this.resolved will synchronously flush all pending keyframe resolvers.\r\n   * This is a deoptimisation, but at its worst still batches read/writes.\r\n   */\n\n\n  get resolved() {\n    if (!this._resolved && !this.hasAttemptedResolve) {\n      flushKeyframeResolvers();\n    }\n\n    return this._resolved;\n  }\n  /**\r\n   * A method to be called when the keyframes resolver completes. This method\r\n   * will check if its possible to run the animation and, if not, skip it.\r\n   * Otherwise, it will call initPlayback on the implementing class.\r\n   */\n\n\n  onKeyframesResolved(keyframes, finalKeyframe) {\n    this.resolvedAt = time.now();\n    this.hasAttemptedResolve = true;\n    const {\n      name,\n      type,\n      velocity,\n      delay,\n      onComplete,\n      onUpdate,\n      isGenerator\n    } = this.options;\n    /**\r\n     * If we can't animate this value with the resolved keyframes\r\n     * then we should complete it immediately.\r\n     */\n\n    if (!isGenerator && !canAnimate(keyframes, name, type, velocity)) {\n      // Finish immediately\n      if (instantAnimationState.current || !delay) {\n        onUpdate && onUpdate(getFinalKeyframe(keyframes, this.options, finalKeyframe));\n        onComplete && onComplete();\n        this.resolveFinishedPromise();\n        return;\n      } // Finish after a delay\n      else {\n        this.options.duration = 0;\n      }\n    }\n\n    const resolvedAnimation = this.initPlayback(keyframes, finalKeyframe);\n    if (resolvedAnimation === false) return;\n    this._resolved = {\n      keyframes,\n      finalKeyframe,\n      ...resolvedAnimation\n    };\n    this.onPostResolved();\n  }\n\n  onPostResolved() {}\n  /**\r\n   * Allows the returned animation to be awaited or promise-chained. Currently\r\n   * resolves when the animation finishes at all but in a future update could/should\r\n   * reject if its cancels.\r\n   */\n\n\n  then(resolve, reject) {\n    return this.currentFinishedPromise.then(resolve, reject);\n  }\n\n  flatten() {\n    if (!this.options.allowFlatten) return;\n    this.options.type = \"keyframes\";\n    this.options.ease = \"linear\";\n  }\n\n  updateFinishedPromise() {\n    this.currentFinishedPromise = new Promise(resolve => {\n      this.resolveFinishedPromise = resolve;\n    });\n  }\n\n}\n\nexport { BaseAnimation };","map":{"version":3,"sources":["C:/Users/PC/Documents/PROGRAMMING/New folder/MERN-BF/frontend/node_modules/framer-motion/dist/es/animation/animators/BaseAnimation.mjs"],"names":["time","flushKeyframeResolvers","instantAnimationState","canAnimate","getFinalKeyframe","MAX_RESOLVE_DELAY","BaseAnimation","constructor","autoplay","delay","type","repeat","repeatDelay","repeatType","options","isStopped","hasAttemptedResolve","createdAt","now","updateFinishedPromise","calcStartTime","resolvedAt","resolved","_resolved","onKeyframesResolved","keyframes","finalKeyframe","name","velocity","onComplete","onUpdate","isGenerator","current","resolveFinishedPromise","duration","resolvedAnimation","initPlayback","onPostResolved","then","resolve","reject","currentFinishedPromise","flatten","allowFlatten","ease","Promise"],"mappings":"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","sourcesContent":["import { time } from 'motion-dom';\r\nimport { flushKeyframeResolvers } from '../../render/utils/KeyframesResolver.mjs';\r\nimport { instantAnimationState } from '../../utils/use-instant-transition-state.mjs';\r\nimport { canAnimate } from './utils/can-animate.mjs';\r\nimport { getFinalKeyframe } from './waapi/utils/get-final-keyframe.mjs';\r\n\r\n/**\r\n * Maximum time allowed between an animation being created and it being\r\n * resolved for us to use the latter as the start time.\r\n *\r\n * This is to ensure that while we prefer to \"start\" an animation as soon\r\n * as it's triggered, we also want to avoid a visual jump if there's a big delay\r\n * between these two moments.\r\n */\r\nconst MAX_RESOLVE_DELAY = 40;\r\nclass BaseAnimation {\r\n    constructor({ autoplay = true, delay = 0, type = \"keyframes\", repeat = 0, repeatDelay = 0, repeatType = \"loop\", ...options }) {\r\n        // Track whether the animation has been stopped. Stopped animations won't restart.\r\n        this.isStopped = false;\r\n        this.hasAttemptedResolve = false;\r\n        this.createdAt = time.now();\r\n        this.options = {\r\n            autoplay,\r\n            delay,\r\n            type,\r\n            repeat,\r\n            repeatDelay,\r\n            repeatType,\r\n            ...options,\r\n        };\r\n        this.updateFinishedPromise();\r\n    }\r\n    /**\r\n     * This method uses the createdAt and resolvedAt to calculate the\r\n     * animation startTime. *Ideally*, we would use the createdAt time as t=0\r\n     * as the following frame would then be the first frame of the animation in\r\n     * progress, which would feel snappier.\r\n     *\r\n     * However, if there's a delay (main thread work) between the creation of\r\n     * the animation and the first commited frame, we prefer to use resolvedAt\r\n     * to avoid a sudden jump into the animation.\r\n     */\r\n    calcStartTime() {\r\n        if (!this.resolvedAt)\r\n            return this.createdAt;\r\n        return this.resolvedAt - this.createdAt > MAX_RESOLVE_DELAY\r\n            ? this.resolvedAt\r\n            : this.createdAt;\r\n    }\r\n    /**\r\n     * A getter for resolved data. If keyframes are not yet resolved, accessing\r\n     * this.resolved will synchronously flush all pending keyframe resolvers.\r\n     * This is a deoptimisation, but at its worst still batches read/writes.\r\n     */\r\n    get resolved() {\r\n        if (!this._resolved && !this.hasAttemptedResolve) {\r\n            flushKeyframeResolvers();\r\n        }\r\n        return this._resolved;\r\n    }\r\n    /**\r\n     * A method to be called when the keyframes resolver completes. This method\r\n     * will check if its possible to run the animation and, if not, skip it.\r\n     * Otherwise, it will call initPlayback on the implementing class.\r\n     */\r\n    onKeyframesResolved(keyframes, finalKeyframe) {\r\n        this.resolvedAt = time.now();\r\n        this.hasAttemptedResolve = true;\r\n        const { name, type, velocity, delay, onComplete, onUpdate, isGenerator, } = this.options;\r\n        /**\r\n         * If we can't animate this value with the resolved keyframes\r\n         * then we should complete it immediately.\r\n         */\r\n        if (!isGenerator && !canAnimate(keyframes, name, type, velocity)) {\r\n            // Finish immediately\r\n            if (instantAnimationState.current || !delay) {\r\n                onUpdate &&\r\n                    onUpdate(getFinalKeyframe(keyframes, this.options, finalKeyframe));\r\n                onComplete && onComplete();\r\n                this.resolveFinishedPromise();\r\n                return;\r\n            }\r\n            // Finish after a delay\r\n            else {\r\n                this.options.duration = 0;\r\n            }\r\n        }\r\n        const resolvedAnimation = this.initPlayback(keyframes, finalKeyframe);\r\n        if (resolvedAnimation === false)\r\n            return;\r\n        this._resolved = {\r\n            keyframes,\r\n            finalKeyframe,\r\n            ...resolvedAnimation,\r\n        };\r\n        this.onPostResolved();\r\n    }\r\n    onPostResolved() { }\r\n    /**\r\n     * Allows the returned animation to be awaited or promise-chained. Currently\r\n     * resolves when the animation finishes at all but in a future update could/should\r\n     * reject if its cancels.\r\n     */\r\n    then(resolve, reject) {\r\n        return this.currentFinishedPromise.then(resolve, reject);\r\n    }\r\n    flatten() {\r\n        if (!this.options.allowFlatten)\r\n            return;\r\n        this.options.type = \"keyframes\";\r\n        this.options.ease = \"linear\";\r\n    }\r\n    updateFinishedPromise() {\r\n        this.currentFinishedPromise = new Promise((resolve) => {\r\n            this.resolveFinishedPromise = resolve;\r\n        });\r\n    }\r\n}\r\n\r\nexport { BaseAnimation };\r\n"]},"metadata":{},"sourceType":"module"}