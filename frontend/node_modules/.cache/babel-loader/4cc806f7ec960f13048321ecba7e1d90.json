{"ast":null,"code":"import { isNil, last, repeat, reverse, dropLast as dropLast$2, adjust, compose } from '@react-pdf/fns';\nimport bidiFactory from 'bidi-js';\nimport unicode from 'unicode-properties';\nimport hyphen from 'hyphen';\nimport pattern from 'hyphen/patterns/en-us.js';\n/**\r\n * Create attributed string from text fragments\r\n *\r\n * @param fragments - Fragments\r\n * @returns Attributed string\r\n */\n\nconst fromFragments = fragments => {\n  let offset = 0;\n  let string = '';\n  const runs = [];\n  fragments.forEach(fragment => {\n    string += fragment.string;\n    runs.push({ ...fragment,\n      start: offset,\n      end: offset + fragment.string.length,\n      attributes: fragment.attributes || {}\n    });\n    offset += fragment.string.length;\n  });\n  return {\n    string,\n    runs\n  };\n};\n/**\r\n * Default word hyphenation engine used when no one provided.\r\n * Does not perform word hyphenation at all\r\n *\r\n * @param word\r\n * @returns Same word\r\n */\n\n\nconst defaultHyphenationEngine = word => [word];\n/**\r\n * Wrap words of attribute string\r\n *\r\n * @param engines layout engines\r\n * @param options layout options\r\n */\n\n\nconst wrapWords = function () {\n  let engines = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n  /**\r\n   * @param attributedString - Attributed string\r\n   * @returns Attributed string including syllables\r\n   */\n  return attributedString => {\n    const syllables = [];\n    const fragments = [];\n    const hyphenateWord = options.hyphenationCallback || engines.wordHyphenation?.() || defaultHyphenationEngine;\n\n    for (let i = 0; i < attributedString.runs.length; i += 1) {\n      let string = '';\n      const run = attributedString.runs[i];\n      const words = attributedString.string.slice(run.start, run.end).split(/([ ]+)/g).filter(Boolean);\n\n      for (let j = 0; j < words.length; j += 1) {\n        const word = words[j];\n        const parts = hyphenateWord(word);\n        syllables.push(...parts);\n        string += parts.join('');\n      }\n\n      fragments.push({ ...run,\n        string\n      });\n    }\n\n    const result = { ...fromFragments(fragments),\n      syllables\n    };\n    return result;\n  };\n};\n/**\r\n * Clone rect\r\n *\r\n * @param rect - Rect\r\n * @returns Cloned rect\r\n */\n\n\nconst copy = rect => {\n  return Object.assign({}, rect);\n};\n/**\r\n * Partition rect in two in the vertical direction\r\n *\r\n * @param rect - Rect\r\n * @param height - Height\r\n * @returns Partitioned rects\r\n */\n\n\nconst partition = (rect, height) => {\n  const a = Object.assign({}, rect, {\n    height\n  });\n  const b = Object.assign({}, rect, {\n    y: rect.y + height,\n    height: rect.height - height\n  });\n  return [a, b];\n};\n/**\r\n * Crop upper section of rect\r\n *\r\n * @param height - Height\r\n * @param rect - Rect\r\n * @returns Cropped rect\r\n */\n\n\nconst crop = (height, rect) => {\n  const [, result] = partition(rect, height);\n  return result;\n};\n/**\r\n * Get paragraph block height\r\n *\r\n * @param paragraph - Paragraph\r\n * @returns Paragraph block height\r\n */\n\n\nconst height$2 = paragraph => {\n  return paragraph.reduce((acc, block) => acc + block.box.height, 0);\n};\n/**\r\n * Calculate run scale\r\n *\r\n * @param run - Run\r\n * @returns Scale\r\n */\n\n\nconst calculateScale = run => {\n  const attributes = run.attributes || {};\n  const fontSize = attributes.fontSize || 12;\n  const font = attributes.font;\n  const unitsPerEm = typeof font === 'string' ? null : font?.[0]?.unitsPerEm;\n  return unitsPerEm ? fontSize / unitsPerEm : 0;\n};\n/**\r\n * Get run scale\r\n *\r\n * @param  run\r\n * @returns Scale\r\n */\n\n\nconst scale = run => {\n  return run.attributes?.scale || calculateScale(run);\n};\n/**\r\n * Get ligature offset by index\r\n *\r\n * Ex. ffi ligature\r\n *\r\n *   glyphs:         l  o  f  f  i  m\r\n *   glyphIndices:   0  1  2  2  2  3\r\n *   offset:         0  0  0  1  2  0\r\n *\r\n * @param index\r\n * @param run - Run\r\n * @returns Ligature offset\r\n */\n\n\nconst offset = (index, run) => {\n  if (!run) return 0;\n  const glyphIndices = run.glyphIndices || [];\n  const value = glyphIndices[index];\n  return glyphIndices.slice(0, index).filter(i => i === value).length;\n};\n/**\r\n * Get run font\r\n *\r\n * @param run - Run\r\n * @returns Font\r\n */\n\n\nconst getFont = run => {\n  return run.attributes?.font?.[0] || null;\n};\n/**\r\n * Slice glyph between codePoints range\r\n * Util for breaking ligatures\r\n *\r\n * @param start - Start code point index\r\n * @param end - End code point index\r\n * @param font - Font to generate new glyph\r\n * @param glyph - Glyph to be sliced\r\n * @returns Sliced glyph parts\r\n */\n\n\nconst slice$2 = (start, end, font, glyph) => {\n  if (!glyph) return [];\n  if (start === end) return [];\n  if (start === 0 && end === glyph.codePoints.length) return [glyph];\n  const codePoints = glyph.codePoints.slice(start, end);\n  const string = String.fromCodePoint(...codePoints); // passing LTR To force fontkit to not reverse the string\n\n  return font ? font.layout(string, undefined, undefined, undefined, 'ltr').glyphs : [glyph];\n};\n/**\r\n * Return glyph index at string index, if glyph indices present.\r\n * Otherwise return string index\r\n *\r\n * @param index - Index\r\n * @param run - Run\r\n * @returns Glyph index\r\n */\n\n\nconst glyphIndexAt = (index, run) => {\n  const result = run?.glyphIndices?.[index];\n  return isNil(result) ? index : result;\n};\n/**\r\n * Returns new array starting with zero, and keeping same relation between consecutive values\r\n *\r\n * @param array - List\r\n * @returns Normalized array\r\n */\n\n\nconst normalize = array => {\n  const head = array[0];\n  return array.map(value => value - head);\n};\n/**\r\n * Slice run between glyph indices range\r\n *\r\n * @param start - Glyph index\r\n * @param end - Glyph index\r\n * @param run - Run\r\n * @returns Sliced run\r\n */\n\n\nconst slice$1 = (start, end, run) => {\n  const runScale = scale(run);\n  const font = getFont(run); // Get glyph start and end indices\n\n  const startIndex = glyphIndexAt(start, run);\n  const endIndex = glyphIndexAt(end, run); // Get start and end glyph\n\n  const startGlyph = run.glyphs?.[startIndex];\n  const endGlyph = run.glyphs?.[endIndex]; // Get start ligature chunks (if any)\n\n  const startOffset = offset(start, run);\n  const startGlyphs = startOffset > 0 ? slice$2(startOffset, Infinity, font, startGlyph) : []; // Get end ligature chunks (if any)\n\n  const endOffset = offset(end, run);\n  const endGlyphs = slice$2(0, endOffset, font, endGlyph); // Compute new glyphs\n\n  const sliceStart = startIndex + Math.min(1, startOffset);\n  const glyphs = (run.glyphs || []).slice(sliceStart, endIndex); // Compute new positions\n\n  const glyphPosition = g => ({\n    xAdvance: g.advanceWidth * runScale,\n    yAdvance: 0,\n    xOffset: 0,\n    yOffset: 0\n  });\n\n  const startPositions = startGlyphs.map(glyphPosition);\n  const positions = (run.positions || []).slice(sliceStart, endIndex);\n  const endPositions = endGlyphs.map(glyphPosition);\n  return Object.assign({}, run, {\n    start: run.start + start,\n    end: Math.min(run.end, run.start + end),\n    glyphIndices: normalize((run.glyphIndices || []).slice(start, end)),\n    glyphs: [startGlyphs, glyphs, endGlyphs].flat(),\n    positions: [startPositions, positions, endPositions].flat()\n  });\n};\n/**\r\n * Get run index that contains passed index\r\n *\r\n * @param index - Index\r\n * @param runs - Runs\r\n * @returns Run index\r\n */\n\n\nconst runIndexAt$1 = (index, runs) => {\n  if (!runs) return -1;\n  return runs.findIndex(run => run.start <= index && index < run.end);\n};\n/**\r\n * Filter runs contained between start and end\r\n *\r\n * @param start\r\n * @param end\r\n * @param runs\r\n * @returns Filtered runs\r\n */\n\n\nconst filter = (start, end, runs) => {\n  const startIndex = runIndexAt$1(start, runs);\n  const endIndex = Math.max(runIndexAt$1(end - 1, runs), startIndex);\n  return runs.slice(startIndex, endIndex + 1);\n};\n/**\r\n * Subtract scalar to run\r\n *\r\n * @param index - Scalar\r\n * @param run - Run\r\n * @returns Subtracted run\r\n */\n\n\nconst subtract = (index, run) => {\n  const start = run.start - index;\n  const end = run.end - index;\n  return Object.assign({}, run, {\n    start,\n    end\n  });\n};\n/**\r\n * Slice array of runs\r\n *\r\n * @param start - Offset\r\n * @param end - Offset\r\n * @param runs\r\n * @returns Sliced runs\r\n */\n\n\nconst sliceRuns = (start, end, runs) => {\n  const sliceFirstRun = a => slice$1(start - a.start, end - a.start, a);\n\n  const sliceLastRun = a => slice$1(0, end - a.start, a);\n\n  return runs.map((run, i) => {\n    let result = run;\n    const isFirst = i === 0;\n    const isLast = !isFirst && i === runs.length - 1;\n    if (isFirst) result = sliceFirstRun(run);\n    if (isLast) result = sliceLastRun(run);\n    return subtract(start, result);\n  });\n};\n/**\r\n * Slice attributed string between two indices\r\n *\r\n * @param start - Offset\r\n * @param end - Offset\r\n * @param attributedString - Attributed string\r\n * @returns Attributed string\r\n */\n\n\nconst slice = (start, end, attributedString) => {\n  if (attributedString.string.length === 0) return attributedString;\n  const string = attributedString.string.slice(start, end);\n  const filteredRuns = filter(start, end, attributedString.runs);\n  const slicedRuns = sliceRuns(start, end, filteredRuns);\n  return Object.assign({}, attributedString, {\n    string,\n    runs: slicedRuns\n  });\n};\n\nconst findCharIndex = string => {\n  return string.search(/\\S/g);\n};\n\nconst findLastCharIndex = string => {\n  const match = string.match(/\\S/g);\n  return match ? string.lastIndexOf(match[match.length - 1]) : -1;\n};\n/**\r\n * Removes (strips) whitespace from both ends of the attributted string.\r\n *\r\n * @param attributedString - Attributed string\r\n * @returns Attributed string\r\n */\n\n\nconst trim = attributedString => {\n  const start = findCharIndex(attributedString.string);\n  const end = findLastCharIndex(attributedString.string);\n  return slice(start, end + 1, attributedString);\n};\n/**\r\n * Returns empty run\r\n *\r\n * @returns Empty run\r\n */\n\n\nconst empty$1 = () => {\n  return {\n    start: 0,\n    end: 0,\n    glyphIndices: [],\n    glyphs: [],\n    positions: [],\n    attributes: {}\n  };\n};\n/**\r\n * Check if value is a number\r\n *\r\n * @param value - Value to check\r\n * @returns Whether value is a number\r\n */\n\n\nconst isNumber = value => {\n  return typeof value === 'number';\n};\n/**\r\n * Append glyph indices with given length\r\n *\r\n * Ex. appendIndices(3, [0, 1, 2, 2]) => [0, 1, 2, 2, 3, 3, 3]\r\n *\r\n * @param length - Length\r\n * @param indices - Glyph indices\r\n * @returns Extended glyph indices\r\n */\n\n\nconst appendIndices = (length, indices) => {\n  const lastIndex = last(indices);\n  const value = isNil(lastIndex) ? 0 : lastIndex + 1;\n  const newIndices = Array(length).fill(value);\n  return indices.concat(newIndices);\n};\n/**\r\n * Get glyph for a given code point\r\n *\r\n * @param value - CodePoint\r\n * @param font - Font\r\n * @returns Glyph\r\n * */\n\n\nconst fromCodePoint = (value, font) => {\n  if (typeof font === 'string') return null;\n  return font && value ? font.glyphForCodePoint(value) : null;\n};\n/**\r\n * Append glyph to run\r\n *\r\n * @param glyph - Glyph\r\n * @param run - Run\r\n * @returns Run with glyph\r\n */\n\n\nconst appendGlyph = (glyph, run) => {\n  const glyphLength = glyph.codePoints?.length || 0;\n  const end = run.end + glyphLength;\n  const glyphs = run.glyphs.concat(glyph);\n  const glyphIndices = appendIndices(glyphLength, run.glyphIndices);\n  if (!run.positions) return Object.assign({}, run, {\n    end,\n    glyphs,\n    glyphIndices\n  });\n  const positions = run.positions.concat({\n    xAdvance: glyph.advanceWidth * scale(run),\n    yAdvance: 0,\n    xOffset: 0,\n    yOffset: 0\n  });\n  return Object.assign({}, run, {\n    end,\n    glyphs,\n    glyphIndices,\n    positions\n  });\n};\n/**\r\n * Append glyph or code point to run\r\n *\r\n * @param value - Glyph or codePoint\r\n * @param run - Run\r\n * @returns Run with glyph\r\n */\n\n\nconst append$1 = (value, run) => {\n  if (!value) return run;\n  const font = getFont(run);\n  const glyph = isNumber(value) ? fromCodePoint(value, font) : value;\n  return appendGlyph(glyph, run);\n};\n/**\r\n * Get string from array of code points\r\n *\r\n * @param codePoints - Points\r\n * @returns String\r\n */\n\n\nconst stringFromCodePoints = codePoints => {\n  return String.fromCodePoint(...(codePoints || []));\n};\n/**\r\n * Append glyph into last run of attributed string\r\n *\r\n * @param glyph - Glyph or code point\r\n * @param attributedString - Attributed string\r\n * @returns Attributed string with new glyph\r\n */\n\n\nconst append = (glyph, attributedString) => {\n  const codePoints = typeof glyph === 'number' ? [glyph] : glyph?.codePoints;\n  const codePointsString = stringFromCodePoints(codePoints || []);\n  const string = attributedString.string + codePointsString;\n  const firstRuns = attributedString.runs.slice(0, -1);\n  const lastRun = last(attributedString.runs) || empty$1();\n  const runs = firstRuns.concat(append$1(glyph, lastRun));\n  return Object.assign({}, attributedString, {\n    string,\n    runs\n  });\n};\n\nconst ELLIPSIS_UNICODE = 8230;\nconst ELLIPSIS_STRING = String.fromCharCode(ELLIPSIS_UNICODE);\n/**\r\n * Get ellipsis codepoint. This may be different in standard and embedded fonts\r\n *\r\n * @param font\r\n * @returns Ellipsis codepoint\r\n */\n\nconst getEllipsisCodePoint = font => {\n  if (!font.encode) return ELLIPSIS_UNICODE;\n  const [codePoints] = font.encode(ELLIPSIS_STRING);\n  return parseInt(codePoints[0], 16);\n};\n/**\r\n * Trucante block with ellipsis\r\n *\r\n * @param paragraph - Paragraph\r\n * @returns Sliced paragraph\r\n */\n\n\nconst truncate = paragraph => {\n  const runs = last(paragraph)?.runs || [];\n  const font = last(runs)?.attributes?.font[0];\n\n  if (font) {\n    const index = paragraph.length - 1;\n    const codePoint = getEllipsisCodePoint(font);\n    const glyph = font.glyphForCodePoint(codePoint);\n    const lastBlock = append(glyph, trim(paragraph[index]));\n    return Object.assign([], paragraph, {\n      [index]: lastBlock\n    });\n  }\n\n  return paragraph;\n};\n/**\r\n * Omit attribute from run\r\n *\r\n * @param value - Attribute key\r\n * @param run - Run\r\n * @returns Run without ommited attribute\r\n */\n\n\nconst omit = (value, run) => {\n  const attributes = Object.assign({}, run.attributes);\n  delete attributes[value];\n  return Object.assign({}, run, {\n    attributes\n  });\n};\n/**\r\n * Get run ascent\r\n *\r\n * @param run - Run\r\n * @returns Ascent\r\n */\n\n\nconst ascent$1 = run => {\n  const {\n    font,\n    attachment\n  } = run.attributes;\n  const attachmentHeight = attachment?.height || 0;\n  const fontAscent = typeof font === 'string' ? 0 : font?.[0]?.ascent || 0;\n  return Math.max(attachmentHeight, fontAscent * scale(run));\n};\n/**\r\n * Get run descent\r\n *\r\n * @param run - Run\r\n * @returns Descent\r\n */\n\n\nconst descent = run => {\n  const font = run.attributes?.font;\n  const fontDescent = typeof font === 'string' ? 0 : font?.[0]?.descent || 0;\n  return scale(run) * fontDescent;\n};\n/**\r\n * Get run lineGap\r\n *\r\n * @param run - Run\r\n * @returns LineGap\r\n */\n\n\nconst lineGap = run => {\n  const font = run.attributes?.font;\n  const lineGap = typeof font === 'string' ? 0 : font?.[0]?.lineGap || 0;\n  return lineGap * scale(run);\n};\n/**\r\n * Get run height\r\n *\r\n * @param run - Run\r\n * @returns Height\r\n */\n\n\nconst height$1 = run => {\n  const lineHeight = run.attributes?.lineHeight;\n  return lineHeight || lineGap(run) + ascent$1(run) - descent(run);\n};\n/**\r\n * Returns attributed string height\r\n *\r\n * @param attributedString - Attributed string\r\n * @returns Height\r\n */\n\n\nconst height = attributedString => {\n  const reducer = (acc, run) => Math.max(acc, height$1(run));\n\n  return attributedString.runs.reduce(reducer, 0);\n};\n/**\r\n * Checks if two rects intersect each other\r\n *\r\n * @param a - Rect A\r\n * @param b - Rect B\r\n * @returns Whether rects intersect\r\n */\n\n\nconst intersects = (a, b) => {\n  const x = Math.max(a.x, b.x);\n  const num1 = Math.min(a.x + a.width, b.x + b.width);\n  const y = Math.max(a.y, b.y);\n  const num2 = Math.min(a.y + a.height, b.y + b.height);\n  return num1 >= x && num2 >= y;\n};\n\nconst getLineFragment = (lineRect, excludeRect) => {\n  if (!intersects(excludeRect, lineRect)) return [lineRect];\n  const eStart = excludeRect.x;\n  const eEnd = excludeRect.x + excludeRect.width;\n  const lStart = lineRect.x;\n  const lEnd = lineRect.x + lineRect.width;\n  const a = Object.assign({}, lineRect, {\n    width: eStart - lStart\n  });\n  const b = Object.assign({}, lineRect, {\n    x: eEnd,\n    width: lEnd - eEnd\n  });\n  return [a, b].filter(r => r.width > 0);\n};\n\nconst getLineFragments = (rect, excludeRects) => {\n  let fragments = [rect];\n\n  for (let i = 0; i < excludeRects.length; i += 1) {\n    const excludeRect = excludeRects[i];\n    fragments = fragments.reduce((acc, fragment) => {\n      const pieces = getLineFragment(fragment, excludeRect);\n      return acc.concat(pieces);\n    }, []);\n  }\n\n  return fragments;\n};\n\nconst generateLineRects = (container, height) => {\n  const {\n    excludeRects,\n    ...rect\n  } = container;\n  if (!excludeRects) return [rect];\n  const lineRects = [];\n  const maxY = Math.max(...excludeRects.map(r => r.y + r.height));\n  let currentRect = rect;\n\n  while (currentRect.y < maxY) {\n    const [lineRect, rest] = partition(currentRect, height);\n    const lineRectFragments = getLineFragments(lineRect, excludeRects);\n    currentRect = rest;\n    lineRects.push(...lineRectFragments);\n  }\n\n  return [...lineRects, currentRect];\n};\n\nconst ATTACHMENT_CODE$1 = '\\ufffc'; // 65532\n\n/**\r\n * Remove attachment attribute if no char present\r\n *\r\n * @param line - Line\r\n * @returns Line\r\n */\n\nconst purgeAttachments = line => {\n  const shouldPurge = !line.string.includes(ATTACHMENT_CODE$1);\n  if (!shouldPurge) return line;\n  const runs = line.runs.map(run => omit('attachment', run));\n  return Object.assign({}, line, {\n    runs\n  });\n};\n/**\r\n * Layout paragraphs inside rectangle\r\n *\r\n * @param rects - Rects\r\n * @param lines - Attributed strings\r\n * @param indent\r\n * @returns layout blocks\r\n */\n\n\nconst layoutLines = (rects, lines, indent) => {\n  let rect = rects.shift();\n  let currentY = rect.y;\n  return lines.map((line, i) => {\n    const lineIndent = i === 0 ? indent : 0;\n    const style = line.runs?.[0]?.attributes || {};\n    const height$1 = Math.max(height(line), style.lineHeight);\n\n    if (currentY + height$1 > rect.y + rect.height && rects.length > 0) {\n      rect = rects.shift();\n      currentY = rect.y;\n    }\n\n    const newLine = {\n      string: line.string,\n      runs: line.runs,\n      box: {\n        x: rect.x + lineIndent,\n        y: currentY,\n        width: rect.width - lineIndent,\n        height: height$1\n      }\n    };\n    currentY += height$1;\n    return purgeAttachments(newLine);\n  });\n};\n/**\r\n * Performs line breaking and layout\r\n *\r\n * @param engines - Engines\r\n * @param options - Layout options\r\n */\n\n\nconst layoutParagraph = function (engines) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n  /**\r\n   * @param container - Container\r\n   * @param paragraph - Attributed string\r\n   * @returns Layout block\r\n   */\n  return (container, paragraph) => {\n    const height$1 = height(paragraph);\n    const indent = paragraph.runs?.[0]?.attributes?.indent || 0;\n    const rects = generateLineRects(container, height$1);\n    const availableWidths = rects.map(r => r.width);\n    availableWidths.unshift(availableWidths[0] - indent);\n    const lines = engines.linebreaker(options)(paragraph, availableWidths);\n    return layoutLines(rects, lines, indent);\n  };\n};\n/**\r\n * Slice block at given height\r\n *\r\n * @param height - Height\r\n * @param paragraph - Paragraph\r\n * @returns Sliced paragraph\r\n */\n\n\nconst sliceAtHeight = (height, paragraph) => {\n  const newBlock = [];\n  let counter = 0;\n\n  for (let i = 0; i < paragraph.length; i += 1) {\n    const line = paragraph[i];\n    counter += line.box.height;\n\n    if (counter < height) {\n      newBlock.push(line);\n    } else {\n      break;\n    }\n  }\n\n  return newBlock;\n};\n/**\r\n * Layout paragraphs inside container until it does not\r\n * fit anymore, performing line wrapping in the process.\r\n *\r\n * @param  engines - Engines\r\n * @param  options - Layout options\r\n * @param container - Container\r\n */\n\n\nconst typesetter = (engines, options, container) => {\n  /**\r\n   * @param attributedStrings - Attributed strings (paragraphs)\r\n   * @returns Paragraph blocks\r\n   */\n  return attributedStrings => {\n    const result = [];\n    const paragraphs = [...attributedStrings];\n    const layout = layoutParagraph(engines, options);\n    const maxLines = isNil(container.maxLines) ? Infinity : container.maxLines;\n    const truncateEllipsis = container.truncateMode === 'ellipsis';\n    let linesCount = maxLines;\n    let paragraphRect = copy(container);\n    let nextParagraph = paragraphs.shift();\n\n    while (linesCount > 0 && nextParagraph) {\n      const paragraph = layout(paragraphRect, nextParagraph);\n      const slicedBlock = paragraph.slice(0, linesCount);\n      const linesHeight = height$2(slicedBlock);\n      const shouldTruncate = truncateEllipsis && paragraph.length !== slicedBlock.length;\n      linesCount -= slicedBlock.length;\n\n      if (paragraphRect.height >= linesHeight) {\n        result.push(shouldTruncate ? truncate(slicedBlock) : slicedBlock);\n        paragraphRect = crop(linesHeight, paragraphRect);\n        nextParagraph = paragraphs.shift();\n      } else {\n        result.push(truncate(sliceAtHeight(paragraphRect.height, slicedBlock)));\n        break;\n      }\n    }\n\n    return result;\n  };\n};\n/**\r\n * Get attributed string start value\r\n *\r\n * @param attributedString - Attributed string\r\n * @returns Start\r\n */\n\n\nconst start = attributedString => {\n  const {\n    runs\n  } = attributedString;\n  return runs.length === 0 ? 0 : runs[0].start;\n};\n/**\r\n * Get attributed string end value\r\n *\r\n * @param attributedString - Attributed string\r\n * @returns End\r\n */\n\n\nconst end = attributedString => {\n  const {\n    runs\n  } = attributedString;\n  return runs.length === 0 ? 0 : last(runs).end;\n};\n/**\r\n * Get attributed string length\r\n *\r\n * @param attributedString - Attributed string\r\n * @returns End\r\n */\n\n\nconst length$1 = attributedString => {\n  return end(attributedString) - start(attributedString);\n};\n\nconst bidi$2 = bidiFactory();\n\nconst getBidiLevels$1 = runs => {\n  return runs.reduce((acc, run) => {\n    const length = run.end - run.start;\n    const levels = repeat(run.attributes.bidiLevel, length);\n    return acc.concat(levels);\n  }, []);\n};\n\nconst getReorderedIndices = (string, segments) => {\n  // Fill an array with indices\n  const indices = [];\n\n  for (let i = 0; i < string.length; i += 1) {\n    indices[i] = i;\n  } // Reverse each segment in order\n\n\n  segments.forEach(_ref => {\n    let [start, end] = _ref;\n    const slice = indices.slice(start, end + 1);\n\n    for (let i = slice.length - 1; i >= 0; i -= 1) {\n      indices[end - i] = slice[i];\n    }\n  });\n  return indices;\n};\n\nconst getItemAtIndex = (runs, objectName, index) => {\n  for (let i = 0; i < runs.length; i += 1) {\n    const run = runs[i];\n    const updatedIndex = run.glyphIndices[index - run.start];\n\n    if (index >= run.start && index < run.end) {\n      return run[objectName][updatedIndex];\n    }\n  }\n\n  throw new Error(`index ${index} out of range`);\n};\n\nconst reorderLine = line => {\n  const levels = getBidiLevels$1(line.runs);\n  const direction = line.runs[0]?.attributes.direction;\n  const level = direction === 'rtl' ? 1 : 0;\n  const end = length$1(line) - 1;\n  const paragraphs = [{\n    start: 0,\n    end,\n    level\n  }];\n  const embeddingLevels = {\n    paragraphs,\n    levels\n  };\n  const segments = bidi$2.getReorderSegments(line.string, embeddingLevels); // No need for bidi reordering\n\n  if (segments.length === 0) return line;\n  const indices = getReorderedIndices(line.string, segments);\n  const updatedString = bidi$2.getReorderedString(line.string, embeddingLevels);\n  const updatedRuns = line.runs.map(run => {\n    const selectedIndices = indices.slice(run.start, run.end);\n    const updatedGlyphs = [];\n    const updatedPositions = [];\n    const addedGlyphs = new Set();\n\n    for (let i = 0; i < selectedIndices.length; i += 1) {\n      const index = selectedIndices[i];\n      const glyph = getItemAtIndex(line.runs, 'glyphs', index);\n      if (addedGlyphs.has(glyph.id)) continue;\n      updatedGlyphs.push(glyph);\n      updatedPositions.push(getItemAtIndex(line.runs, 'positions', index));\n\n      if (glyph.isLigature) {\n        addedGlyphs.add(glyph.id);\n      }\n    }\n\n    return { ...run,\n      glyphs: updatedGlyphs,\n      positions: updatedPositions\n    };\n  });\n  return {\n    box: line.box,\n    runs: updatedRuns,\n    string: updatedString\n  };\n};\n\nconst reorderParagraph = paragraph => paragraph.map(reorderLine);\n/**\r\n * Perform bidi reordering\r\n *\r\n * @returns Reordered paragraphs\r\n */\n\n\nconst bidiReordering = () => {\n  /**\r\n   * @param paragraphs - Paragraphs\r\n   * @returns Reordered paragraphs\r\n   */\n  return paragraphs => paragraphs.map(reorderParagraph);\n};\n\nconst DUMMY_CODEPOINT = 123;\n/**\r\n * Resolve string indices based on glyphs code points\r\n *\r\n * @param glyphs\r\n * @returns Glyph indices\r\n */\n\nconst resolve = function () {\n  let glyphs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n  return glyphs.reduce((acc, glyph) => {\n    const codePoints = glyph?.codePoints || [DUMMY_CODEPOINT];\n    if (acc.length === 0) return codePoints.map(() => 0);\n    const last = acc[acc.length - 1];\n    const next = codePoints.map(() => last + 1);\n    return [...acc, ...next];\n  }, []);\n};\n\nconst getCharacterSpacing = run => {\n  return run.attributes?.characterSpacing || 0;\n};\n/**\r\n * Scale run positions\r\n *\r\n * @param  run\r\n * @param  positions\r\n * @returns Scaled positions\r\n */\n\n\nconst scalePositions = (run, positions) => {\n  const runScale = scale(run);\n  const characterSpacing = getCharacterSpacing(run);\n  return positions.map((position, i) => {\n    const isLast = i === positions.length;\n    const xSpacing = isLast ? 0 : characterSpacing;\n    return Object.assign({}, position, {\n      xAdvance: position.xAdvance * runScale + xSpacing,\n      yAdvance: position.yAdvance * runScale,\n      xOffset: position.xOffset * runScale,\n      yOffset: position.yOffset * runScale\n    });\n  });\n};\n/**\r\n * Create glyph run\r\n *\r\n * @param string string\r\n */\n\n\nconst layoutRun = string => {\n  /**\r\n   * @param run - Run\r\n   * @returns Glyph run\r\n   */\n  return run => {\n    const {\n      start,\n      end,\n      attributes = {}\n    } = run;\n    const {\n      font\n    } = attributes;\n    if (!font) return { ...run,\n      glyphs: [],\n      glyphIndices: [],\n      positions: []\n    };\n    const runString = string.slice(start, end);\n    if (typeof font === 'string') throw new Error('Invalid font'); // passing LTR To force fontkit to not reverse the string\n\n    const glyphRun = font[0].layout(runString, undefined, undefined, undefined, 'ltr');\n    const positions = scalePositions(run, glyphRun.positions);\n    const glyphIndices = resolve(glyphRun.glyphs);\n    const result = { ...run,\n      positions,\n      glyphIndices,\n      glyphs: glyphRun.glyphs\n    };\n    return result;\n  };\n};\n/**\r\n * Generate glyphs for single attributed string\r\n */\n\n\nconst generateGlyphs = () => {\n  /**\r\n   * @param attributedString - Attributed string\r\n   * @returns Attributed string with glyphs\r\n   */\n  return attributedString => {\n    const runs = attributedString.runs.map(layoutRun(attributedString.string));\n    const res = Object.assign({}, attributedString, {\n      runs\n    });\n    return res;\n  };\n};\n/**\r\n * Resolves yOffset for run\r\n *\r\n * @param run - Run\r\n * @returns Run\r\n */\n\n\nconst resolveRunYOffset = run => {\n  if (!run.positions) return run;\n  const unitsPerEm = run.attributes?.font?.[0]?.unitsPerEm || 0;\n  const yOffset = (run.attributes?.yOffset || 0) * unitsPerEm;\n  const positions = run.positions.map(p => Object.assign({}, p, {\n    yOffset\n  }));\n  return Object.assign({}, run, {\n    positions\n  });\n};\n/**\r\n * Resolves yOffset for multiple paragraphs\r\n */\n\n\nconst resolveYOffset = () => {\n  /**\r\n   * @param attributedString - Attributed string\r\n   * @returns Attributed string\r\n   */\n  return attributedString => {\n    const runs = attributedString.runs.map(resolveRunYOffset);\n    const res = Object.assign({}, attributedString, {\n      runs\n    });\n    return res;\n  };\n};\n/**\r\n * Sort runs in ascending order\r\n *\r\n * @param runs\r\n * @returns Sorted runs\r\n */\n\n\nconst sort = runs => {\n  return runs.sort((a, b) => a.start - b.start || a.end - b.end);\n};\n/**\r\n * Is run empty (start === end)\r\n *\r\n * @param run - Run\r\n * @returns Is run empty\r\n */\n\n\nconst isEmpty = run => {\n  return run.start === run.end;\n};\n/**\r\n * Sort points in ascending order\r\n * @param a - First point\r\n * @param b - Second point\r\n * @returns Sort order\r\n */\n\n\nconst sortPoints = (a, b) => {\n  return a[1] - b[1] || a[3] - b[3];\n};\n/**\r\n * @param runs\r\n * @returns Points\r\n */\n\n\nconst generatePoints = runs => {\n  const result = runs.reduce((acc, run, i) => {\n    return acc.concat([['start', run.start, run.attributes, i], ['end', run.end, run.attributes, i]]);\n  }, []);\n  return result.sort(sortPoints);\n};\n/**\r\n * @param runs\r\n * @returns Merged runs\r\n */\n\n\nconst mergeRuns = runs => {\n  return runs.reduce((acc, run) => {\n    const attributes = Object.assign({}, acc.attributes, run.attributes);\n    return Object.assign({}, run, {\n      attributes\n    });\n  }, {});\n};\n/**\r\n * @param runs\r\n * @returns Grouped runs\r\n */\n\n\nconst groupEmptyRuns = runs => {\n  const groups = runs.reduce((acc, run) => {\n    if (!acc[run.start]) acc[run.start] = [];\n    acc[run.start].push(run);\n    return acc;\n  }, []);\n  return Object.values(groups);\n};\n/**\r\n * @param runs\r\n * @returns Flattened runs\r\n */\n\n\nconst flattenEmptyRuns = runs => {\n  return groupEmptyRuns(runs).map(mergeRuns);\n};\n/**\r\n * @param runs\r\n * @returns Flattened runs\r\n */\n\n\nconst flattenRegularRuns = runs => {\n  const res = [];\n  const points = generatePoints(runs);\n  let start = -1;\n  let attrs = {};\n  const stack = [];\n\n  for (let i = 0; i < points.length; i += 1) {\n    const [type, offset, attributes] = points[i];\n\n    if (start !== -1 && start < offset) {\n      res.push({\n        start,\n        end: offset,\n        attributes: attrs,\n        glyphIndices: [],\n        glyphs: [],\n        positions: []\n      });\n    }\n\n    if (type === 'start') {\n      stack.push(attributes);\n      attrs = Object.assign({}, attrs, attributes);\n    } else {\n      attrs = {};\n\n      for (let j = 0; j < stack.length; j += 1) {\n        if (stack[j] === attributes) {\n          stack.splice(j--, 1);\n        } else {\n          attrs = Object.assign({}, attrs, stack[j]);\n        }\n      }\n    }\n\n    start = offset;\n  }\n\n  return res;\n};\n/**\r\n * Flatten many runs\r\n *\r\n * @param runs\r\n * @returns Flattened runs\r\n */\n\n\nconst flatten = function () {\n  let runs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n  const emptyRuns = flattenEmptyRuns(runs.filter(run => isEmpty(run)));\n  const regularRuns = flattenRegularRuns(runs.filter(run => !isEmpty(run)));\n  return sort(emptyRuns.concat(regularRuns));\n};\n/**\r\n * Returns empty attributed string\r\n *\r\n * @returns Empty attributed string\r\n */\n\n\nconst empty = () => ({\n  string: '',\n  runs: []\n});\n/**\r\n *\r\n * @param attributedString\r\n * @returns Attributed string without font\r\n */\n\n\nconst omitFont = attributedString => {\n  const runs = attributedString.runs.map(run => omit('font', run));\n  return Object.assign({}, attributedString, {\n    runs\n  });\n};\n/**\r\n * Performs font substitution and script itemization on attributed string\r\n *\r\n * @param engines - engines\r\n */\n\n\nconst preprocessRuns = engines => {\n  /**\r\n   * @param attributedString - Attributed string\r\n   * @returns Processed attributed string\r\n   */\n  return attributedString => {\n    if (isNil(attributedString)) return empty();\n    const {\n      string\n    } = attributedString;\n    const {\n      fontSubstitution,\n      scriptItemizer,\n      bidi\n    } = engines;\n    const {\n      runs: omittedFontRuns\n    } = omitFont(attributedString);\n    const {\n      runs: itemizationRuns\n    } = scriptItemizer()(attributedString);\n    const {\n      runs: substitutedRuns\n    } = fontSubstitution()(attributedString);\n    const {\n      runs: bidiRuns\n    } = bidi()(attributedString);\n    const runs = bidiRuns.concat(substitutedRuns).concat(itemizationRuns).concat(omittedFontRuns);\n    return {\n      string,\n      runs: flatten(runs)\n    };\n  };\n};\n/**\r\n * Breaks attributed string into paragraphs\r\n */\n\n\nconst splitParagraphs = () => {\n  /**\r\n   * @param attributedString - Attributed string\r\n   * @returns Paragraphs attributed strings\r\n   */\n  return attributedString => {\n    const paragraphs = [];\n    let start = 0;\n    let breakPoint = attributedString.string.indexOf('\\n') + 1;\n\n    while (breakPoint > 0) {\n      paragraphs.push(slice(start, breakPoint, attributedString));\n      start = breakPoint;\n      breakPoint = attributedString.string.indexOf('\\n', breakPoint) + 1;\n    }\n\n    if (start === 0) {\n      paragraphs.push(attributedString);\n    } else if (start < attributedString.string.length) {\n      paragraphs.push(slice(start, length$1(attributedString), attributedString));\n    }\n\n    return paragraphs;\n  };\n};\n/**\r\n * Return positions advance width\r\n *\r\n * @param positions - Positions\r\n * @returns {number} advance width\r\n */\n\n\nconst advanceWidth$2 = positions => {\n  return positions.reduce((acc, pos) => acc + (pos.xAdvance || 0), 0);\n};\n/**\r\n * Return run advance width\r\n *\r\n * @param run - Run\r\n * @returns Advance width\r\n */\n\n\nconst advanceWidth$1 = run => {\n  return advanceWidth$2(run.positions || []);\n};\n/**\r\n * Returns attributed string advancewidth\r\n *\r\n * @param attributedString - Attributed string\r\n * @returns Advance width\r\n */\n\n\nconst advanceWidth = attributedString => {\n  const reducer = (acc, run) => acc + advanceWidth$1(run);\n\n  return attributedString.runs.reduce(reducer, 0);\n};\n\nconst WHITE_SPACES_CODE = 32;\n/**\r\n * Check if glyph is white space\r\n *\r\n * @param glyph - Glyph\r\n * @returns Whether glyph is white space\r\n * */\n\nconst isWhiteSpace = glyph => {\n  const codePoints = glyph?.codePoints || [];\n  return codePoints.includes(WHITE_SPACES_CODE);\n};\n/**\r\n * Get white space leading positions\r\n *\r\n * @param run - Run\r\n * @returns White space leading positions\r\n */\n\n\nconst leadingPositions = run => {\n  const glyphs = run.glyphs || [];\n  const positions = run.positions || [];\n  const leadingWhitespaces = glyphs.findIndex(g => !isWhiteSpace(g));\n  return positions.slice(0, leadingWhitespaces);\n};\n/**\r\n * Get run leading white space offset\r\n *\r\n * @param run - Run\r\n * @returns Leading white space offset\r\n */\n\n\nconst leadingOffset$1 = run => {\n  const positions = leadingPositions(run);\n  return positions.reduce((acc, pos) => acc + (pos.xAdvance || 0), 0);\n};\n/**\r\n * Get attributed string leading white space offset\r\n *\r\n * @param attributedString - Attributed string\r\n * @returns Leading white space offset\r\n */\n\n\nconst leadingOffset = attributedString => {\n  const runs = attributedString.runs || [];\n  return leadingOffset$1(runs[0]);\n};\n/**\r\n * Get white space trailing positions\r\n *\r\n * @param run run\r\n * @returns White space trailing positions\r\n */\n\n\nconst trailingPositions = run => {\n  const glyphs = reverse(run.glyphs || []);\n  const positions = reverse(run.positions || []);\n  const leadingWhitespaces = glyphs.findIndex(g => !isWhiteSpace(g));\n  return positions.slice(0, leadingWhitespaces);\n};\n/**\r\n * Get run trailing white space offset\r\n *\r\n * @param run - Run\r\n * @returns Trailing white space offset\r\n */\n\n\nconst trailingOffset$1 = run => {\n  const positions = trailingPositions(run);\n  return positions.reduce((acc, pos) => acc + (pos.xAdvance || 0), 0);\n};\n/**\r\n * Get attributed string trailing white space offset\r\n *\r\n * @param attributedString - Attributed string\r\n * @returns Trailing white space offset\r\n */\n\n\nconst trailingOffset = attributedString => {\n  const runs = attributedString.runs || [];\n  return trailingOffset$1(last(runs));\n};\n/**\r\n * Drop last char of run\r\n *\r\n * @param run - Run\r\n * @returns Run without last char\r\n */\n\n\nconst dropLast$1 = run => {\n  return slice$1(0, run.end - run.start - 1, run);\n};\n/**\r\n * Drop last glyph\r\n *\r\n * @param attributedString - Attributed string\r\n * @returns Attributed string with new glyph\r\n */\n\n\nconst dropLast = attributedString => {\n  const string = dropLast$2(attributedString.string);\n  const runs = adjust(-1, dropLast$1, attributedString.runs);\n  return Object.assign({}, attributedString, {\n    string,\n    runs\n  });\n};\n\nconst ALIGNMENT_FACTORS = {\n  center: 0.5,\n  right: 1\n};\n/**\r\n * Remove new line char at the end of line if present\r\n *\r\n * @param line\r\n * @returns Line\r\n */\n\nconst removeNewLine = line => {\n  return last(line.string) === '\\n' ? dropLast(line) : line;\n};\n\nconst getOverflowLeft = line => {\n  return leadingOffset(line) + (line.overflowLeft || 0);\n};\n\nconst getOverflowRight = line => {\n  return trailingOffset(line) + (line.overflowRight || 0);\n};\n/**\r\n * Ignore whitespace at the start and end of a line for alignment\r\n *\r\n * @param line\r\n * @returns Line\r\n */\n\n\nconst adjustOverflow = line => {\n  const overflowLeft = getOverflowLeft(line);\n  const overflowRight = getOverflowRight(line);\n  const x = line.box.x - overflowLeft;\n  const width = line.box.width + overflowLeft + overflowRight;\n  const box = Object.assign({}, line.box, {\n    x,\n    width\n  });\n  return Object.assign({}, line, {\n    box,\n    overflowLeft,\n    overflowRight\n  });\n};\n/**\r\n * Performs line justification by calling appropiate engine\r\n *\r\n * @param engines - Engines\r\n * @param options - Layout options\r\n * @param align - Text align\r\n */\n\n\nconst justifyLine$1 = (engines, options, align) => {\n  /**\r\n   * @param line - Line\r\n   * @returns Line\r\n   */\n  return line => {\n    const lineWidth = advanceWidth(line);\n    const alignFactor = ALIGNMENT_FACTORS[align] || 0;\n    const remainingWidth = Math.max(0, line.box.width - lineWidth);\n    const shouldJustify = align === 'justify' || lineWidth > line.box.width;\n    const x = line.box.x + remainingWidth * alignFactor;\n    const box = Object.assign({}, line.box, {\n      x\n    });\n    const newLine = Object.assign({}, line, {\n      box\n    });\n    return shouldJustify ? engines.justification(options)(newLine) : newLine;\n  };\n};\n\nconst finalizeLine = line => {\n  let lineAscent = 0;\n  let lineDescent = 0;\n  let lineHeight = 0;\n  let lineXAdvance = 0;\n  const runs = line.runs.map(run => {\n    const height = height$1(run);\n    const ascent = ascent$1(run);\n    const descent$1 = descent(run);\n    const xAdvance = advanceWidth$1(run);\n    lineHeight = Math.max(lineHeight, height);\n    lineAscent = Math.max(lineAscent, ascent);\n    lineDescent = Math.max(lineDescent, descent$1);\n    lineXAdvance += xAdvance;\n    return Object.assign({}, run, {\n      height,\n      ascent,\n      descent: descent$1,\n      xAdvance\n    });\n  });\n  return Object.assign({}, line, {\n    runs,\n    height: lineHeight,\n    ascent: lineAscent,\n    descent: lineDescent,\n    xAdvance: lineXAdvance\n  });\n};\n/**\r\n * Finalize line by performing line justification\r\n * and text decoration (using appropiate engines)\r\n *\r\n * @param engines - Engines\r\n * @param options - Layout options\r\n */\n\n\nconst finalizeBlock = (engines, options) => {\n  /**\r\n   * @param line - Line\r\n   * @param i - Line index\r\n   * @param lines - Total lines\r\n   * @returns Line\r\n   */\n  return (line, index, lines) => {\n    const isLastFragment = index === lines.length - 1;\n    const style = line.runs?.[0]?.attributes || {};\n    const align = isLastFragment ? style.alignLastLine : style.align;\n    return compose(finalizeLine, engines.textDecoration(), justifyLine$1(engines, options, align), adjustOverflow, removeNewLine)(line);\n  };\n};\n/**\r\n * Finalize line block by performing line justification\r\n * and text decoration (using appropiate engines)\r\n *\r\n * @param engines - Engines\r\n * @param options - Layout options\r\n */\n\n\nconst finalizeFragments = (engines, options) => {\n  /**\r\n   * @param paragraphs - Paragraphs\r\n   * @returns Paragraphs\r\n   */\n  return paragraphs => {\n    const blockFinalizer = finalizeBlock(engines, options);\n    return paragraphs.map(paragraph => paragraph.map(blockFinalizer));\n  };\n};\n\nconst ATTACHMENT_CODE = 0xfffc; // 65532\n\nconst isReplaceGlyph = glyph => glyph.codePoints.includes(ATTACHMENT_CODE);\n/**\r\n * Resolve attachments of run\r\n *\r\n * @param run\r\n * @returns Run\r\n */\n\n\nconst resolveRunAttachments = run => {\n  if (!run.positions) return run;\n  const glyphs = run.glyphs || [];\n  const attachment = run.attributes?.attachment;\n  if (!attachment) return run;\n  const positions = run.positions.map((position, i) => {\n    const glyph = glyphs[i];\n\n    if (attachment.width && isReplaceGlyph(glyph)) {\n      return Object.assign({}, position, {\n        xAdvance: attachment.width\n      });\n    }\n\n    return Object.assign({}, position);\n  });\n  return Object.assign({}, run, {\n    positions\n  });\n};\n/**\r\n * Resolve attachments for multiple paragraphs\r\n */\n\n\nconst resolveAttachments = () => {\n  /**\r\n   * @param attributedString - Attributed string\r\n   * @returns Attributed string\r\n   */\n  return attributedString => {\n    const runs = attributedString.runs.map(resolveRunAttachments);\n    const res = Object.assign({}, attributedString, {\n      runs\n    });\n    return res;\n  };\n};\n/**\r\n * @param attributes - Attributes\r\n * @returns Attributes with defaults\r\n */\n\n\nconst applyAttributes = a => {\n  return {\n    align: a.align || (a.direction === 'rtl' ? 'right' : 'left'),\n    alignLastLine: a.alignLastLine || (a.align === 'justify' ? 'left' : a.align || 'left'),\n    attachment: a.attachment || null,\n    backgroundColor: a.backgroundColor || null,\n    bullet: a.bullet || null,\n    characterSpacing: a.characterSpacing || 0,\n    color: a.color || 'black',\n    direction: a.direction || 'ltr',\n    features: a.features || [],\n    fill: a.fill !== false,\n    font: a.font || [],\n    fontSize: a.fontSize || 12,\n    hangingPunctuation: a.hangingPunctuation || false,\n    hyphenationFactor: a.hyphenationFactor || 0,\n    indent: a.indent || 0,\n    justificationFactor: a.justificationFactor || 1,\n    lineHeight: a.lineHeight || null,\n    lineSpacing: a.lineSpacing || 0,\n    link: a.link || null,\n    marginLeft: a.marginLeft || a.margin || 0,\n    marginRight: a.marginRight || a.margin || 0,\n    opacity: a.opacity,\n    paddingTop: a.paddingTop || a.padding || 0,\n    paragraphSpacing: a.paragraphSpacing || 0,\n    script: a.script || null,\n    shrinkFactor: a.shrinkFactor || 0,\n    strike: a.strike || false,\n    strikeColor: a.strikeColor || a.color || 'black',\n    strikeStyle: a.strikeStyle || 'solid',\n    stroke: a.stroke || false,\n    underline: a.underline || false,\n    underlineColor: a.underlineColor || a.color || 'black',\n    underlineStyle: a.underlineStyle || 'solid',\n    verticalAlign: a.verticalAlign || null,\n    wordSpacing: a.wordSpacing || 0,\n    yOffset: a.yOffset || 0\n  };\n};\n/**\r\n * Apply default style to run\r\n *\r\n * @param run - Run\r\n * @returns Run with default styles\r\n */\n\n\nconst applyRunStyles = run => {\n  const attributes = applyAttributes(run.attributes);\n  return Object.assign({}, run, {\n    attributes\n  });\n};\n/**\r\n * Apply default attributes for an attributed string\r\n */\n\n\nconst applyDefaultStyles = () => {\n  return attributedString => {\n    const string = attributedString.string || '';\n    const runs = (attributedString.runs || []).map(applyRunStyles);\n    return {\n      string,\n      runs\n    };\n  };\n};\n/**\r\n * Apply scaling and yOffset for verticalAlign 'sub' and 'super'.\r\n */\n\n\nconst verticalAlignment = () => {\n  /**\r\n   * @param attributedString - Attributed string\r\n   * @returns Attributed string\r\n   */\n  return attributedString => {\n    attributedString.runs.forEach(run => {\n      const {\n        attributes\n      } = run;\n      const {\n        verticalAlign\n      } = attributes;\n\n      if (verticalAlign === 'sub') {\n        attributes.yOffset = -0.2;\n      } else if (verticalAlign === 'super') {\n        attributes.yOffset = 0.4;\n      }\n    });\n    return attributedString;\n  };\n};\n\nconst bidi$1 = bidiFactory();\n/**\r\n * @param runs\r\n * @returns Bidi levels\r\n */\n\nconst getBidiLevels = runs => {\n  return runs.reduce((acc, run) => {\n    const length = run.end - run.start;\n    const levels = repeat(run.attributes.bidiLevel, length);\n    return acc.concat(levels);\n  }, []);\n};\n/**\r\n * Perform bidi mirroring\r\n */\n\n\nconst mirrorString = () => {\n  /**\r\n   * @param attributedString - Attributed string\r\n   * @returns Attributed string\r\n   */\n  return attributedString => {\n    const levels = getBidiLevels(attributedString.runs);\n    let updatedString = '';\n    attributedString.string.split('').forEach((char, index) => {\n      const isRTL = levels[index] % 2 === 1;\n      const mirroredChar = isRTL ? bidi$1.getMirroredCharacter(attributedString.string.charAt(index)) : null;\n      updatedString += mirroredChar || char;\n    });\n    const result = { ...attributedString,\n      string: updatedString\n    };\n    return result;\n  };\n};\n/**\r\n * A LayoutEngine is the main object that performs text layout.\r\n * It accepts an AttributedString and a Container object\r\n * to layout text into, and uses several helper objects to perform\r\n * various layout tasks. These objects can be overridden to customize\r\n * layout behavior.\r\n */\n\n\nconst layoutEngine = engines => {\n  return function (attributedString, container) {\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    const processParagraph = compose(resolveYOffset(), resolveAttachments(), verticalAlignment(), wrapWords(engines, options), generateGlyphs(), mirrorString(), preprocessRuns(engines));\n\n    const processParagraphs = paragraphs => paragraphs.map(processParagraph);\n\n    return compose(finalizeFragments(engines, options), bidiReordering(), typesetter(engines, options, container), processParagraphs, splitParagraphs(), applyDefaultStyles())(attributedString);\n  };\n};\n\nconst bidi = bidiFactory();\n\nconst bidiEngine = () => {\n  /**\r\n   * @param attributedString - Attributed string\r\n   * @returns Attributed string\r\n   */\n  return attributedString => {\n    const {\n      string\n    } = attributedString;\n    const direction = attributedString.runs[0]?.attributes.direction;\n    const {\n      levels\n    } = bidi.getEmbeddingLevels(string, direction);\n    let lastLevel = null;\n    let lastIndex = 0;\n    let index = 0;\n    const runs = [];\n\n    for (let i = 0; i < levels.length; i += 1) {\n      const level = levels[i];\n\n      if (level !== lastLevel) {\n        if (lastLevel !== null) {\n          runs.push({\n            start: lastIndex,\n            end: index,\n            attributes: {\n              bidiLevel: lastLevel\n            }\n          });\n        }\n\n        lastIndex = index;\n        lastLevel = level;\n      }\n\n      index += 1;\n    }\n\n    if (lastIndex < string.length) {\n      runs.push({\n        start: lastIndex,\n        end: string.length,\n        attributes: {\n          bidiLevel: lastLevel\n        }\n      });\n    }\n\n    const result = {\n      string,\n      runs\n    };\n    return result;\n  };\n};\n\nconst INFINITY = 10000;\n\nconst getNextBreakpoint = (subnodes, widths, lineNumber) => {\n  let position = null;\n  let minimumBadness = Infinity;\n  const sum = {\n    width: 0,\n    stretch: 0,\n    shrink: 0\n  };\n  const lineLength = widths[Math.min(lineNumber, widths.length - 1)];\n\n  const calculateRatio = node => {\n    const stretch = 'stretch' in node ? node.stretch : null;\n\n    if (sum.width < lineLength) {\n      if (!stretch) return INFINITY;\n      return sum.stretch - stretch > 0 ? (lineLength - sum.width) / sum.stretch : INFINITY;\n    }\n\n    const shrink = 'shrink' in node ? node.shrink : null;\n\n    if (sum.width > lineLength) {\n      if (!shrink) return INFINITY;\n      return sum.shrink - shrink > 0 ? (lineLength - sum.width) / sum.shrink : INFINITY;\n    }\n\n    return 0;\n  };\n\n  for (let i = 0; i < subnodes.length; i += 1) {\n    const node = subnodes[i];\n\n    if (node.type === 'box') {\n      sum.width += node.width;\n    }\n\n    if (node.type === 'glue') {\n      sum.width += node.width;\n      sum.stretch += node.stretch;\n      sum.shrink += node.shrink;\n    }\n\n    if (sum.width - sum.shrink > lineLength) {\n      if (position === null) {\n        let j = i === 0 ? i + 1 : i;\n\n        while (j < subnodes.length && (subnodes[j].type === 'glue' || subnodes[j].type === 'penalty')) {\n          j++;\n        }\n\n        position = j - 1;\n      }\n\n      break;\n    }\n\n    if (node.type === 'penalty' || node.type === 'glue') {\n      const ratio = calculateRatio(node);\n      const penalty = node.type === 'penalty' ? node.penalty : 0;\n      const badness = 100 * Math.abs(ratio) ** 3 + penalty;\n\n      if (minimumBadness >= badness) {\n        position = i;\n        minimumBadness = badness;\n      }\n    }\n  }\n\n  return sum.width - sum.shrink > lineLength ? position : null;\n};\n\nconst applyBestFit = (nodes, widths) => {\n  let count = 0;\n  let lineNumber = 0;\n  let subnodes = nodes;\n  const breakpoints = [0];\n\n  while (subnodes.length > 0) {\n    const breakpoint = getNextBreakpoint(subnodes, widths, lineNumber);\n\n    if (breakpoint !== null) {\n      count += breakpoint;\n      breakpoints.push(count);\n      subnodes = subnodes.slice(breakpoint + 1, subnodes.length);\n      count++;\n      lineNumber++;\n    } else {\n      subnodes = [];\n    }\n  }\n\n  return breakpoints;\n};\n/* eslint-disable max-classes-per-file */\n\n\nclass LinkedListNode {\n  data;\n  prev;\n  next;\n\n  constructor(data) {\n    this.data = data;\n    this.prev = null;\n    this.next = null;\n  }\n\n}\n\nclass LinkedList {\n  static Node = LinkedListNode;\n  head;\n  tail;\n  listSize;\n  listLength;\n\n  constructor() {\n    this.head = null;\n    this.tail = null;\n    this.listSize = 0;\n    this.listLength = 0;\n  }\n\n  isLinked(node) {\n    return !(node && node.prev === null && node.next === null && this.tail !== node && this.head !== node || this.isEmpty());\n  }\n\n  size() {\n    return this.listSize;\n  }\n\n  isEmpty() {\n    return this.listSize === 0;\n  }\n\n  first() {\n    return this.head;\n  }\n\n  last() {\n    return this.last;\n  }\n\n  forEach(callback) {\n    let node = this.head;\n\n    while (node !== null) {\n      callback(node);\n      node = node.next;\n    }\n  }\n\n  at(i) {\n    let node = this.head;\n    let index = 0;\n\n    if (i >= this.listLength || i < 0) {\n      return null;\n    }\n\n    while (node !== null) {\n      if (i === index) {\n        return node;\n      }\n\n      node = node.next;\n      index += 1;\n    }\n\n    return null;\n  }\n\n  insertAfter(node, newNode) {\n    if (!this.isLinked(node)) return this;\n    newNode.prev = node;\n    newNode.next = node.next;\n\n    if (node.next === null) {\n      this.tail = newNode;\n    } else {\n      node.next.prev = newNode;\n    }\n\n    node.next = newNode;\n    this.listSize += 1;\n    return this;\n  }\n\n  insertBefore(node, newNode) {\n    if (!this.isLinked(node)) return this;\n    newNode.prev = node.prev;\n    newNode.next = node;\n\n    if (node.prev === null) {\n      this.head = newNode;\n    } else {\n      node.prev.next = newNode;\n    }\n\n    node.prev = newNode;\n    this.listSize += 1;\n    return this;\n  }\n\n  push(node) {\n    if (this.head === null) {\n      this.unshift(node);\n    } else {\n      this.insertAfter(this.tail, node);\n    }\n\n    return this;\n  }\n\n  unshift(node) {\n    if (this.head === null) {\n      this.head = node;\n      this.tail = node;\n      node.prev = null;\n      node.next = null;\n      this.listSize += 1;\n    } else {\n      this.insertBefore(this.head, node);\n    }\n\n    return this;\n  }\n\n  remove(node) {\n    if (!this.isLinked(node)) return this;\n\n    if (node.prev === null) {\n      this.head = node.next;\n    } else {\n      node.prev.next = node.next;\n    }\n\n    if (node.next === null) {\n      this.tail = node.prev;\n    } else {\n      node.next.prev = node.prev;\n    }\n\n    this.listSize -= 1;\n    return this;\n  }\n\n}\n/**\r\n * Licensed under the new BSD License.\r\n * Copyright 2009-2010, Bram Stein\r\n * All rights reserved.\r\n */\n\n\nfunction breakpoint(position, demerits, line, fitnessClass, totals, previous) {\n  return {\n    position,\n    demerits,\n    line,\n    fitnessClass,\n    totals: totals || {\n      width: 0,\n      stretch: 0,\n      shrink: 0\n    },\n    previous\n  };\n}\n\nfunction computeCost(nodes, lineLengths, sum, end, active, currentLine) {\n  let width = sum.width - active.totals.width;\n  let stretch = 0;\n  let shrink = 0; // If the current line index is within the list of linelengths, use it, otherwise use\n  // the last line length of the list.\n\n  const lineLength = currentLine < lineLengths.length ? lineLengths[currentLine - 1] : lineLengths[lineLengths.length - 1];\n\n  if (nodes[end].type === 'penalty') {\n    width += nodes[end].width;\n  } // Calculate the stretch ratio\n\n\n  if (width < lineLength) {\n    stretch = sum.stretch - active.totals.stretch;\n\n    if (stretch > 0) {\n      return (lineLength - width) / stretch;\n    }\n\n    return linebreak.infinity;\n  } // Calculate the shrink ratio\n\n\n  if (width > lineLength) {\n    shrink = sum.shrink - active.totals.shrink;\n\n    if (shrink > 0) {\n      return (lineLength - width) / shrink;\n    }\n\n    return linebreak.infinity;\n  } // perfect match\n\n\n  return 0;\n} // Add width, stretch and shrink values from the current\n// break point up to the next box or forced penalty.\n\n\nfunction computeSum(nodes, sum, breakPointIndex) {\n  const result = {\n    width: sum.width,\n    stretch: sum.stretch,\n    shrink: sum.shrink\n  };\n\n  for (let i = breakPointIndex; i < nodes.length; i += 1) {\n    const node = nodes[i];\n\n    if (node.type === 'glue') {\n      result.width += node.width;\n      result.stretch += node.stretch;\n      result.shrink += node.shrink;\n    } else if (node.type === 'box' || node.type === 'penalty' && node.penalty === -linebreak.infinity && i > breakPointIndex) {\n      break;\n    }\n  }\n\n  return result;\n}\n\nfunction findBestBreakpoints(activeNodes) {\n  const breakpoints = [];\n  if (activeNodes.size() === 0) return [];\n  let tmp = {\n    data: {\n      demerits: Infinity\n    }\n  }; // Find the best active node (the one with the least total demerits.)\n\n  activeNodes.forEach(node => {\n    if (node.data.demerits < tmp.data.demerits) {\n      tmp = node;\n    }\n  });\n\n  while (tmp !== null) {\n    breakpoints.push(tmp.data.position);\n    tmp = tmp.data.previous;\n  }\n\n  return breakpoints.reverse();\n}\n/**\r\n * @param nodes\r\n * @param availableWidths\r\n * @param tolerance\r\n * @preserve Knuth and Plass line breaking algorithm in JavaScript\r\n */\n\n\nconst linebreak = (nodes, availableWidths, tolerance) => {\n  // Demerits are used as a way to penalize bad line breaks\n  //  - line: applied to each line, depending on how much spaces need to stretch or shrink\n  //  - flagged: applied when consecutive lines end in hyphenation\n  //  - fitness: algorithm groups lines into fitness classes based on how loose or tight the spacing is.\n  //             if a paragraph has consecutive lines from different fitness classes,\n  //             a fitness demerit is applied to maintain visual consistency.\n  const options = {\n    demerits: {\n      line: 10,\n      flagged: 100,\n      fitness: 3000\n    },\n    tolerance: tolerance || 3\n  };\n  const activeNodes = new LinkedList();\n  const sum = {\n    width: 0,\n    stretch: 0,\n    shrink: 0\n  };\n  const lineLengths = availableWidths; // Add an active node for the start of the paragraph.\n\n  activeNodes.push(new LinkedList.Node(breakpoint(0, 0, 0, 0, undefined, null))); // The main loop of the algorithm\n\n  function mainLoop(node, index, nodes) {\n    let active = activeNodes.first(); // The inner loop iterates through all the active nodes with line < currentLine and then\n    // breaks out to insert the new active node candidates before looking at the next active\n    // nodes for the next lines. The result of this is that the active node list is always\n    // sorted by line number.\n\n    while (active !== null) {\n      let currentLine = 0; // Candidates fo each fitness class\n\n      const candidates = [{\n        active: undefined,\n        demerits: Infinity\n      }, {\n        active: undefined,\n        demerits: Infinity\n      }, {\n        active: undefined,\n        demerits: Infinity\n      }, {\n        active: undefined,\n        demerits: Infinity\n      }]; // Iterate through the linked list of active nodes to find new potential active nodes and deactivate current active nodes.\n\n      while (active !== null) {\n        currentLine = active.data.line + 1;\n        const ratio = computeCost(nodes, lineLengths, sum, index, active.data, currentLine); // Deactive nodes when the distance between the current active node and the\n        // current node becomes too large (i.e. it exceeds the stretch limit and the stretch\n        // ratio becomes negative) or when the current node is a forced break (i.e. the end\n        // of the paragraph when we want to remove all active nodes, but possibly have a final\n        // candidate active node---if the paragraph can be set using the given tolerance value.)\n\n        if (ratio < -1 || node.type === 'penalty' && node.penalty === -linebreak.infinity) {\n          activeNodes.remove(active);\n        } // If the ratio is within the valid range of -1 <= ratio <= tolerance calculate the\n        // total demerits and record a candidate active node.\n\n\n        if (ratio >= -1 && ratio <= options.tolerance) {\n          const badness = 100 * Math.pow(Math.abs(ratio), 3);\n          let demerits = 0; // Positive penalty\n\n          if (node.type === 'penalty' && node.penalty >= 0) {\n            demerits = Math.pow(options.demerits.line + badness, 2) + Math.pow(node.penalty, 2); // Negative penalty but not a forced break\n          } else if (node.type === 'penalty' && node.penalty !== -linebreak.infinity) {\n            demerits = Math.pow(options.demerits.line + badness, 2) - Math.pow(node.penalty, 2); // All other cases\n          } else {\n            demerits = Math.pow(options.demerits.line + badness, 2);\n          }\n\n          if (node.type === 'penalty' && nodes[active.data.position].type === 'penalty') {\n            demerits += options.demerits.flagged * node.flagged * // @ts-expect-error node is penalty here\n            nodes[active.data.position].flagged;\n          } // Calculate the fitness class for this candidate active node.\n\n\n          let currentClass;\n\n          if (ratio < -0.5) {\n            currentClass = 0;\n          } else if (ratio <= 0.5) {\n            currentClass = 1;\n          } else if (ratio <= 1) {\n            currentClass = 2;\n          } else {\n            currentClass = 3;\n          } // Add a fitness penalty to the demerits if the fitness classes of two adjacent lines differ too much.\n\n\n          if (Math.abs(currentClass - active.data.fitnessClass) > 1) {\n            demerits += options.demerits.fitness;\n          } // Add the total demerits of the active node to get the total demerits of this candidate node.\n\n\n          demerits += active.data.demerits; // Only store the best candidate for each fitness class\n\n          if (demerits < candidates[currentClass].demerits) {\n            candidates[currentClass] = {\n              active,\n              demerits\n            };\n          }\n        }\n\n        active = active.next; // Stop iterating through active nodes to insert new candidate active nodes in the active list\n        // before moving on to the active nodes for the next line.\n        // TODO: The Knuth and Plass paper suggests a conditional for currentLine < j0. This means paragraphs\n        // with identical line lengths will not be sorted by line number. Find out if that is a desirable outcome.\n        // For now I left this out, as it only adds minimal overhead to the algorithm and keeping the active node\n        // list sorted has a higher priority.\n\n        if (active !== null && active.data.line >= currentLine) {\n          break;\n        }\n      }\n\n      const tmpSum = computeSum(nodes, sum, index);\n\n      for (let fitnessClass = 0; fitnessClass < candidates.length; fitnessClass += 1) {\n        const candidate = candidates[fitnessClass];\n        if (candidate.demerits === Infinity) continue;\n        const newNode = new LinkedList.Node(breakpoint(index, candidate.demerits, candidate.active.data.line + 1, fitnessClass, tmpSum, candidate.active));\n\n        if (active !== null) {\n          activeNodes.insertBefore(active, newNode);\n        } else {\n          activeNodes.push(newNode);\n        }\n      }\n    }\n  }\n\n  nodes.forEach((node, index, nodes) => {\n    if (node.type === 'box') {\n      sum.width += node.width;\n      return;\n    }\n\n    if (node.type === 'glue') {\n      const precedesBox = index > 0 && nodes[index - 1].type === 'box';\n      if (precedesBox) mainLoop(node, index, nodes);\n      sum.width += node.width;\n      sum.stretch += node.stretch;\n      sum.shrink += node.shrink;\n      return;\n    }\n\n    if (node.type === 'penalty' && node.penalty !== linebreak.infinity) {\n      mainLoop(node, index, nodes);\n    }\n  });\n  return findBestBreakpoints(activeNodes);\n};\n\nlinebreak.infinity = 10000;\n\nlinebreak.glue = (width, start, end, stretch, shrink) => ({\n  type: 'glue',\n  start,\n  end,\n  width,\n  stretch,\n  shrink\n});\n\nlinebreak.box = function (width, start, end) {\n  let hyphenated = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n  return {\n    type: 'box',\n    width,\n    start,\n    end,\n    hyphenated\n  };\n};\n\nlinebreak.penalty = (width, penalty, flagged) => ({\n  type: 'penalty',\n  width,\n  penalty,\n  flagged\n});\n/**\r\n * Add scalar to run\r\n *\r\n * @param index - Scalar\r\n * @param run - Run\r\n * @returns Added run\r\n */\n\n\nconst add = (index, run) => {\n  const start = run.start + index;\n  const end = run.end + index;\n  return Object.assign({}, run, {\n    start,\n    end\n  });\n};\n/**\r\n * Get run length\r\n *\r\n * @param run - Run\r\n * @returns Length\r\n */\n\n\nconst length = run => {\n  return run.end - run.start;\n};\n/**\r\n * Concats two runs into one\r\n *\r\n * @param runA - First run\r\n * @param runB - Second run\r\n * @returns Concatenated run\r\n */\n\n\nconst concat = (runA, runB) => {\n  const end = runA.end + length(runB);\n  const glyphs = (runA.glyphs || []).concat(runB.glyphs || []);\n  const positions = (runA.positions || []).concat(runB.positions || []);\n  const attributes = Object.assign({}, runA.attributes, runB.attributes);\n  const runAIndices = runA.glyphIndices || [];\n  const runALastIndex = last(runAIndices) || 0;\n  const runBIndices = (runB.glyphIndices || []).map(i => i + runALastIndex + 1);\n  const glyphIndices = normalize(runAIndices.concat(runBIndices));\n  return Object.assign({}, runA, {\n    end,\n    glyphs,\n    positions,\n    attributes,\n    glyphIndices\n  });\n};\n/**\r\n * Insert glyph to run in the given index\r\n *\r\n * @param index - Index\r\n * @param glyph - Glyph\r\n * @param run - Run\r\n * @returns Run with glyph\r\n */\n\n\nconst insertGlyph$1 = (index, glyph, run) => {\n  if (!glyph) return run; // Split resolves ligature splitting in case new glyph breaks some\n\n  const leadingRun = slice$1(0, index, run);\n  const trailingRun = slice$1(index, Infinity, run);\n  return concat(append$1(glyph, leadingRun), trailingRun);\n};\n/**\r\n * Insert either glyph or code point to run in the given index\r\n *\r\n * @param index - Index\r\n * @param value - Glyph or codePoint\r\n * @param run - Run\r\n * @returns Run with glyph\r\n */\n\n\nconst insert = (index, value, run) => {\n  const font = getFont(run);\n  const glyph = isNumber(value) ? fromCodePoint(value, font) : value;\n  return insertGlyph$1(index, glyph, run);\n};\n/**\r\n * Get run index at char index\r\n *\r\n * @param index - Char index\r\n * @param attributedString - Attributed string\r\n * @returns Run index\r\n */\n\n\nconst runIndexAt = (index, attributedString) => {\n  return runIndexAt$1(index, attributedString.runs);\n};\n/**\r\n * Insert glyph into attributed string\r\n *\r\n * @param index - Index\r\n * @param glyph - Glyph or code point\r\n * @param attributedString - Attributed string\r\n * @returns Attributed string with new glyph\r\n */\n\n\nconst insertGlyph = (index, glyph, attributedString) => {\n  const runIndex = runIndexAt(index, attributedString); // Add glyph to the end if run index invalid\n\n  if (runIndex === -1) return append(glyph, attributedString);\n  const codePoints = [glyph];\n  const string = attributedString.string.slice(0, index) + stringFromCodePoints(codePoints) + attributedString.string.slice(index);\n  const runs = attributedString.runs.map((run, i) => {\n    if (i === runIndex) return insert(index - run.start, glyph, run);\n    if (i > runIndex) return add(codePoints.length, run);\n    return run;\n  });\n  return Object.assign({}, attributedString, {\n    string,\n    runs\n  });\n};\n/**\r\n * Advance width between two string indices\r\n *\r\n * @param start - Glyph index\r\n * @param end - Glyph index\r\n * @param run - Run\r\n * @returns Advanced width run\r\n */\n\n\nconst advanceWidthBetween$1 = (start, end, run) => {\n  const runStart = run.start || 0;\n  const glyphStartIndex = Math.max(0, glyphIndexAt(start - runStart, run));\n  const glyphEndIndex = Math.max(0, glyphIndexAt(end - runStart, run));\n  const positions = (run.positions || []).slice(glyphStartIndex, glyphEndIndex);\n  return advanceWidth$2(positions);\n};\n/**\r\n * Advance width between start and end\r\n * Does not consider ligature splitting for the moment.\r\n * Check performance impact on supporting this\r\n *\r\n * @param start - Start offset\r\n * @param end - End offset\r\n * @param attributedString\r\n * @returns Advance width\r\n */\n\n\nconst advanceWidthBetween = (start, end, attributedString) => {\n  const runs = filter(start, end, attributedString.runs);\n  return runs.reduce((acc, run) => acc + advanceWidthBetween$1(start, end, run), 0);\n};\n\nconst HYPHEN = 0x002d;\nconst TOLERANCE_STEPS = 5;\nconst TOLERANCE_LIMIT = 50;\nconst opts = {\n  width: 3,\n  stretch: 6,\n  shrink: 9\n};\n/**\r\n * Slice attributed string to many lines\r\n *\r\n * @param attributedString - Attributed string\r\n * @param nodes\r\n * @param breaks\r\n * @returns Attributed strings\r\n */\n\nconst breakLines = (attributedString, nodes, breaks) => {\n  let start = 0;\n  let end = null;\n  const lines = breaks.reduce((acc, breakPoint) => {\n    const node = nodes[breakPoint];\n    const prevNode = nodes[breakPoint - 1]; // Last breakpoint corresponds to K&P mandatory final glue\n\n    if (breakPoint === nodes.length - 1) return acc;\n    let line;\n\n    if (node.type === 'penalty') {\n      // @ts-expect-error penalty node will always preceed box or glue node\n      end = prevNode.end;\n      line = slice(start, end, attributedString);\n      line = insertGlyph(line.string.length, HYPHEN, line);\n    } else {\n      end = node.end;\n      line = slice(start, end, attributedString);\n    }\n\n    start = end;\n    return [...acc, line];\n  }, []); // Last line\n\n  lines.push(slice(start, attributedString.string.length, attributedString));\n  return lines;\n};\n/**\r\n * Return Knuth & Plass nodes based on line and previously calculated syllables\r\n *\r\n * @param attributedString - Attributed string\r\n * @param attributes - Attributes\r\n * @param options - Layout options\r\n * @returns ?\r\n */\n\n\nconst getNodes = (attributedString, _ref2, options) => {\n  let {\n    align\n  } = _ref2;\n  let start = 0;\n  const hyphenWidth = 5;\n  const {\n    syllables\n  } = attributedString;\n  const hyphenPenalty = options.hyphenationPenalty || (align === 'justify' ? 100 : 600);\n  const result = syllables.reduce((acc, s, index) => {\n    const width = advanceWidthBetween(start, start + s.length, attributedString);\n\n    if (s.trim() === '') {\n      const stretch = width * opts.width / opts.stretch;\n      const shrink = width * opts.width / opts.shrink;\n      const end = start + s.length; // Add glue node. Glue nodes are used to fill the space between words.\n\n      acc.push(linebreak.glue(width, start, end, stretch, shrink));\n    } else {\n      const hyphenated = syllables[index + 1] !== ' ';\n      const end = start + s.length; // Add box node. Box nodes are used to represent words.\n\n      acc.push(linebreak.box(width, start, end, hyphenated));\n\n      if (syllables[index + 1] && hyphenated) {\n        // Add penalty node. Penalty nodes are used to represent hyphenation points.\n        acc.push(linebreak.penalty(hyphenWidth, hyphenPenalty, 1));\n      }\n    }\n\n    start += s.length;\n    return acc;\n  }, []); // Add mandatory final glue\n\n  result.push(linebreak.glue(0, start, start, linebreak.infinity, 0));\n  result.push(linebreak.penalty(0, -linebreak.infinity, 1));\n  return result;\n};\n/**\r\n * @param attributedString - Attributed string\r\n * @returns Attributes\r\n */\n\n\nconst getAttributes = attributedString => {\n  return attributedString.runs?.[0]?.attributes || {};\n};\n/**\r\n * Performs Knuth & Plass line breaking algorithm\r\n * Fallbacks to best fit algorithm if latter not successful\r\n *\r\n * @param options - Layout options\r\n */\n\n\nconst linebreaker = options => {\n  /**\r\n   * @param attributedString - Attributed string\r\n   * @param availableWidths - Available widths\r\n   * @returns Attributed string\r\n   */\n  return (attributedString, availableWidths) => {\n    let tolerance = options.tolerance || 4;\n    const attributes = getAttributes(attributedString);\n    const nodes = getNodes(attributedString, attributes, options);\n    let breaks = linebreak(nodes, availableWidths, tolerance); // Try again with a higher tolerance if the line breaking failed.\n\n    while (breaks.length === 0 && tolerance < TOLERANCE_LIMIT) {\n      tolerance += TOLERANCE_STEPS;\n      breaks = linebreak(nodes, availableWidths, tolerance);\n    }\n\n    if (breaks.length === 0 || breaks.length === 1 && breaks[0] === 0) {\n      breaks = applyBestFit(nodes, availableWidths);\n    }\n\n    return breakLines(attributedString, nodes, breaks.slice(1));\n  };\n};\n\nvar Direction;\n\n(function (Direction) {\n  Direction[Direction[\"GROW\"] = 0] = \"GROW\";\n  Direction[Direction[\"SHRINK\"] = 1] = \"SHRINK\";\n})(Direction || (Direction = {}));\n\nconst WHITESPACE_PRIORITY = 1;\nconst LETTER_PRIORITY = 2;\nconst EXPAND_WHITESPACE_FACTOR = {\n  before: 0.5,\n  after: 0.5,\n  priority: WHITESPACE_PRIORITY,\n  unconstrained: false\n};\nconst EXPAND_CHAR_FACTOR = {\n  before: 0.14453125,\n  // 37/256\n  after: 0.14453125,\n  priority: LETTER_PRIORITY,\n  unconstrained: false\n};\nconst SHRINK_WHITESPACE_FACTOR = {\n  before: -0.04296875,\n  // -11/256\n  after: -0.04296875,\n  priority: WHITESPACE_PRIORITY,\n  unconstrained: false\n};\nconst SHRINK_CHAR_FACTOR = {\n  before: -0.04296875,\n  after: -0.04296875,\n  priority: LETTER_PRIORITY,\n  unconstrained: false\n};\n\nconst getCharFactor = (direction, options) => {\n  const expandCharFactor = options.expandCharFactor || {};\n  const shrinkCharFactor = options.shrinkCharFactor || {};\n  return direction === Direction.GROW ? Object.assign({}, EXPAND_CHAR_FACTOR, expandCharFactor) : Object.assign({}, SHRINK_CHAR_FACTOR, shrinkCharFactor);\n};\n\nconst getWhitespaceFactor = (direction, options) => {\n  const expandWhitespaceFactor = options.expandWhitespaceFactor || {};\n  const shrinkWhitespaceFactor = options.shrinkWhitespaceFactor || {};\n  return direction === Direction.GROW ? Object.assign({}, EXPAND_WHITESPACE_FACTOR, expandWhitespaceFactor) : Object.assign({}, SHRINK_WHITESPACE_FACTOR, shrinkWhitespaceFactor);\n};\n\nconst factor = (direction, options) => glyphs => {\n  const charFactor = getCharFactor(direction, options);\n  const whitespaceFactor = getWhitespaceFactor(direction, options);\n  const factors = [];\n\n  for (let index = 0; index < glyphs.length; index += 1) {\n    let f;\n    const glyph = glyphs[index];\n\n    if (isWhiteSpace(glyph)) {\n      f = Object.assign({}, whitespaceFactor);\n\n      if (index === glyphs.length - 1) {\n        f.before = 0;\n\n        if (index > 0) {\n          factors[index - 1].after = 0;\n        }\n      }\n    } else if (glyph.isMark && index > 0) {\n      f = Object.assign({}, factors[index - 1]);\n      f.before = 0;\n      factors[index - 1].after = 0;\n    } else {\n      f = Object.assign({}, charFactor);\n    }\n\n    factors.push(f);\n  }\n\n  return factors;\n};\n\nconst getFactors = (gap, line, options) => {\n  const direction = gap > 0 ? Direction.GROW : Direction.SHRINK;\n  const getFactor = factor(direction, options);\n  const factors = line.runs.reduce((acc, run) => {\n    return acc.concat(getFactor(run.glyphs));\n  }, []);\n  factors[0].before = 0;\n  factors[factors.length - 1].after = 0;\n  return factors;\n};\n\nconst KASHIDA_PRIORITY = 0;\nconst NULL_PRIORITY = 3;\n\nconst getDistances = (gap, factors) => {\n  let total = 0;\n  const priorities = [];\n  const unconstrained = [];\n\n  for (let priority = KASHIDA_PRIORITY; priority <= NULL_PRIORITY; priority += 1) {\n    priorities[priority] = unconstrained[priority] = 0;\n  } // sum the factors at each priority\n\n\n  for (let j = 0; j < factors.length; j += 1) {\n    const f = factors[j];\n    const sum = f.before + f.after;\n    total += sum;\n    priorities[f.priority] += sum;\n\n    if (f.unconstrained) {\n      unconstrained[f.priority] += sum;\n    }\n  } // choose the priorities that need to be applied\n\n\n  let highestPriority = -1;\n  let highestPrioritySum = 0;\n  let remainingGap = gap;\n  let priority;\n\n  for (priority = KASHIDA_PRIORITY; priority <= NULL_PRIORITY; priority += 1) {\n    const prioritySum = priorities[priority];\n\n    if (prioritySum !== 0) {\n      if (highestPriority === -1) {\n        highestPriority = priority;\n        highestPrioritySum = prioritySum;\n      } // if this priority covers the remaining gap, we're done\n\n\n      if (Math.abs(remainingGap) <= Math.abs(prioritySum)) {\n        priorities[priority] = remainingGap / prioritySum;\n        unconstrained[priority] = 0;\n        remainingGap = 0;\n        break;\n      } // mark that we need to use 100% of the adjustment from\n      // this priority, and subtract the space that it consumes\n\n\n      priorities[priority] = 1;\n      remainingGap -= prioritySum; // if this priority has unconstrained glyphs, let them consume the remaining space\n\n      if (unconstrained[priority] !== 0) {\n        unconstrained[priority] = remainingGap / unconstrained[priority];\n        remainingGap = 0;\n        break;\n      }\n    }\n  } // zero out remaining priorities (if any)\n\n\n  for (let p = priority + 1; p <= NULL_PRIORITY; p += 1) {\n    priorities[p] = 0;\n    unconstrained[p] = 0;\n  } // if there is still space left over, assign it to the highest priority that we saw.\n  // this violates their factors, but it only happens in extreme cases\n\n\n  if (remainingGap > 0 && highestPriority > -1) {\n    priorities[highestPriority] = (highestPrioritySum + (gap - total)) / highestPrioritySum;\n  } // create and return an array of distances to add to each glyph's advance\n\n\n  const distances = [];\n\n  for (let index = 0; index < factors.length; index += 1) {\n    // the distance to add to this glyph is the sum of the space to add\n    // after this glyph, and the space to add before the next glyph\n    const f = factors[index];\n    const next = factors[index + 1];\n    let dist = f.after * priorities[f.priority];\n\n    if (next) {\n      dist += next.before * priorities[next.priority];\n    } // if this glyph is unconstrained, add the unconstrained distance as well\n\n\n    if (f.unconstrained) {\n      dist += f.after * unconstrained[f.priority];\n\n      if (next) {\n        dist += next.before * unconstrained[next.priority];\n      }\n    }\n\n    distances.push(dist);\n  }\n\n  return distances;\n};\n/**\r\n * Adjust run positions by given distances\r\n *\r\n * @param distances\r\n * @param line\r\n * @returns Line\r\n */\n\n\nconst justifyLine = (distances, line) => {\n  let index = 0;\n\n  for (const run of line.runs) {\n    for (const position of run.positions) {\n      position.xAdvance += distances[index++];\n    }\n  }\n\n  return line;\n};\n/**\r\n * A JustificationEngine is used by a Typesetter to perform line fragment\r\n * justification. This implementation is based on a description of Apple's\r\n * justification algorithm from a PDF in the Apple Font Tools package.\r\n *\r\n * @param options - Layout options\r\n */\n\n\nconst justification = options => {\n  /**\r\n   * @param line\r\n   * @returns Line\r\n   */\n  return line => {\n    const gap = line.box.width - advanceWidth(line);\n    if (gap === 0) return line; // Exact fit\n\n    const factors = getFactors(gap, line, options);\n    const distances = getDistances(gap, factors);\n    return justifyLine(distances, line);\n  };\n};\n/**\r\n * Returns attributed string ascent\r\n *\r\n * @param attributedString - Attributed string\r\n * @returns Ascent\r\n */\n\n\nconst ascent = attributedString => {\n  const reducer = (acc, run) => Math.max(acc, ascent$1(run));\n\n  return attributedString.runs.reduce(reducer, 0);\n}; // The base font size used for calculating underline thickness.\n\n\nconst BASE_FONT_SIZE = 12;\n/**\r\n * A TextDecorationEngine is used by a Typesetter to generate\r\n * DecorationLines for a line fragment, including underlines\r\n * and strikes.\r\n */\n\nconst textDecoration = () => line => {\n  let x = line.overflowLeft || 0;\n  const overflowRight = line.overflowRight || 0;\n  const maxX = advanceWidth(line) - overflowRight;\n  line.decorationLines = [];\n\n  for (let i = 0; i < line.runs.length; i += 1) {\n    const run = line.runs[i];\n    const width = Math.min(maxX - x, advanceWidth$1(run));\n    const thickness = Math.max(0.5, Math.floor(run.attributes.fontSize / BASE_FONT_SIZE));\n\n    if (run.attributes.underline) {\n      const rect = {\n        x,\n        y: ascent(line) + thickness * 2,\n        width,\n        height: thickness\n      };\n      const decorationLine = {\n        rect,\n        opacity: run.attributes.opacity,\n        color: run.attributes.underlineColor || 'black',\n        style: run.attributes.underlineStyle || 'solid'\n      };\n      line.decorationLines.push(decorationLine);\n    }\n\n    if (run.attributes.strike) {\n      const y = ascent(line) - ascent$1(run) / 3;\n      const rect = {\n        x,\n        y,\n        width,\n        height: thickness\n      };\n      const decorationLine = {\n        rect,\n        opacity: run.attributes.opacity,\n        color: run.attributes.strikeColor || 'black',\n        style: run.attributes.strikeStyle || 'solid'\n      };\n      line.decorationLines.push(decorationLine);\n    }\n\n    x += width;\n  }\n\n  return line;\n};\n\nconst ignoredScripts = ['Common', 'Inherited', 'Unknown'];\n/**\r\n * Resolves unicode script in runs, grouping equal runs together\r\n */\n\nconst scriptItemizer = () => {\n  /**\r\n   * @param attributedString - Attributed string\r\n   * @returns Attributed string\r\n   */\n  return attributedString => {\n    const {\n      string\n    } = attributedString;\n    let lastScript = 'Unknown';\n    let lastIndex = 0;\n    let index = 0;\n    const runs = [];\n    if (!string) return empty();\n\n    for (let i = 0; i < string.length; i += 1) {\n      const char = string[i];\n      const codePoint = char.codePointAt(0);\n      const script = unicode.getScript(codePoint);\n\n      if (script !== lastScript && !ignoredScripts.includes(script)) {\n        if (lastScript !== 'Unknown') {\n          runs.push({\n            start: lastIndex,\n            end: index,\n            attributes: {\n              script: lastScript\n            }\n          });\n        }\n\n        lastIndex = index;\n        lastScript = script;\n      }\n\n      index += char.length;\n    }\n\n    if (lastIndex < string.length) {\n      runs.push({\n        start: lastIndex,\n        end: string.length,\n        attributes: {\n          script: lastScript\n        }\n      });\n    }\n\n    const result = {\n      string,\n      runs: runs\n    };\n    return result;\n  };\n};\n\nconst SOFT_HYPHEN = '\\u00ad';\nconst hyphenator = hyphen(pattern);\n/**\r\n * @param word\r\n * @returns Word parts\r\n */\n\nconst splitHyphen = word => {\n  return word.split(SOFT_HYPHEN);\n};\n\nconst cache = {};\n/**\r\n * @param word\r\n * @returns Word parts\r\n */\n\nconst getParts = word => {\n  const base = word.includes(SOFT_HYPHEN) ? word : hyphenator(word);\n  return splitHyphen(base);\n};\n\nconst wordHyphenation = () => {\n  /**\r\n   * @param word - Word\r\n   * @returns Word parts\r\n   */\n  return word => {\n    const cacheKey = `_${word}`;\n    if (isNil(word)) return [];\n    if (cache[cacheKey]) return cache[cacheKey];\n    cache[cacheKey] = getParts(word);\n    return cache[cacheKey];\n  };\n};\n\nconst IGNORED_CODE_POINTS = [173];\n\nconst getFontSize = run => run.attributes.fontSize || 12;\n\nconst pickFontFromFontStack = (codePoint, fontStack, lastFont) => {\n  const fontStackWithFallback = [...fontStack, lastFont];\n\n  for (let i = 0; i < fontStackWithFallback.length; i += 1) {\n    const font = fontStackWithFallback[i];\n\n    if (!IGNORED_CODE_POINTS.includes(codePoint) && font && font.hasGlyphForCodePoint && font.hasGlyphForCodePoint(codePoint)) {\n      return font;\n    }\n  }\n\n  return fontStack.at(-1);\n};\n\nconst fontSubstitution = () => _ref3 => {\n  let {\n    string,\n    runs\n  } = _ref3;\n  let lastFont = null;\n  let lastFontSize = null;\n  let lastIndex = 0;\n  let index = 0;\n  const res = [];\n\n  for (let i = 0; i < runs.length; i += 1) {\n    const run = runs[i];\n\n    if (string.length === 0) {\n      res.push({\n        start: 0,\n        end: 0,\n        attributes: {\n          font: run.attributes.font\n        }\n      });\n      break;\n    }\n\n    const chars = string.slice(run.start, run.end);\n\n    for (let j = 0; j < chars.length; j += 1) {\n      const char = chars[j];\n      const codePoint = char.codePointAt(0); // If the default font does not have a glyph and the fallback font does, we use it\n\n      const font = pickFontFromFontStack(codePoint, run.attributes.font, lastFont);\n      const fontSize = getFontSize(run); // If anything that would impact res has changed, update it\n\n      if (font !== lastFont || fontSize !== lastFontSize || font.unitsPerEm !== lastFont.unitsPerEm) {\n        if (lastFont) {\n          res.push({\n            start: lastIndex,\n            end: index,\n            attributes: {\n              font: [lastFont],\n              scale: lastFontSize / lastFont.unitsPerEm\n            }\n          });\n        }\n\n        lastFont = font;\n        lastFontSize = fontSize;\n        lastIndex = index;\n      }\n\n      index += char.length;\n    }\n  }\n\n  if (lastIndex < string.length) {\n    const fontSize = getFontSize(last(runs));\n    res.push({\n      start: lastIndex,\n      end: string.length,\n      attributes: {\n        font: [lastFont],\n        scale: fontSize / lastFont.unitsPerEm\n      }\n    });\n  }\n\n  return {\n    string,\n    runs: res\n  };\n};\n\nexport { bidiEngine as bidi, layoutEngine as default, fontSubstitution, fromFragments, justification, linebreaker, scriptItemizer, textDecoration, wordHyphenation };","map":{"version":3,"sources":["C:/Users/PC/Documents/PROGRAMMING/New folder/MERN-BF/frontend/node_modules/@react-pdf/textkit/lib/textkit.js"],"names":["isNil","last","repeat","reverse","dropLast","dropLast$2","adjust","compose","bidiFactory","unicode","hyphen","pattern","fromFragments","fragments","offset","string","runs","forEach","fragment","push","start","end","length","attributes","defaultHyphenationEngine","word","wrapWords","engines","options","attributedString","syllables","hyphenateWord","hyphenationCallback","wordHyphenation","i","run","words","slice","split","filter","Boolean","j","parts","join","result","copy","rect","Object","assign","partition","height","a","b","y","crop","height$2","paragraph","reduce","acc","block","box","calculateScale","fontSize","font","unitsPerEm","scale","index","glyphIndices","value","getFont","slice$2","glyph","codePoints","String","fromCodePoint","layout","undefined","glyphs","glyphIndexAt","normalize","array","head","map","slice$1","runScale","startIndex","endIndex","startGlyph","endGlyph","startOffset","startGlyphs","Infinity","endOffset","endGlyphs","sliceStart","Math","min","glyphPosition","g","xAdvance","advanceWidth","yAdvance","xOffset","yOffset","startPositions","positions","endPositions","flat","runIndexAt$1","findIndex","max","subtract","sliceRuns","sliceFirstRun","sliceLastRun","isFirst","isLast","filteredRuns","slicedRuns","findCharIndex","search","findLastCharIndex","match","lastIndexOf","trim","empty$1","isNumber","appendIndices","indices","lastIndex","newIndices","Array","fill","concat","glyphForCodePoint","appendGlyph","glyphLength","append$1","stringFromCodePoints","append","codePointsString","firstRuns","lastRun","ELLIPSIS_UNICODE","ELLIPSIS_STRING","fromCharCode","getEllipsisCodePoint","encode","parseInt","truncate","codePoint","lastBlock","omit","ascent$1","attachment","attachmentHeight","fontAscent","ascent","descent","fontDescent","lineGap","height$1","lineHeight","reducer","intersects","x","num1","width","num2","getLineFragment","lineRect","excludeRect","eStart","eEnd","lStart","lEnd","r","getLineFragments","excludeRects","pieces","generateLineRects","container","lineRects","maxY","currentRect","rest","lineRectFragments","ATTACHMENT_CODE$1","purgeAttachments","line","shouldPurge","includes","layoutLines","rects","lines","indent","shift","currentY","lineIndent","style","newLine","layoutParagraph","availableWidths","unshift","linebreaker","sliceAtHeight","newBlock","counter","typesetter","attributedStrings","paragraphs","maxLines","truncateEllipsis","truncateMode","linesCount","paragraphRect","nextParagraph","slicedBlock","linesHeight","shouldTruncate","length$1","bidi$2","getBidiLevels$1","levels","bidiLevel","getReorderedIndices","segments","getItemAtIndex","objectName","updatedIndex","Error","reorderLine","direction","level","embeddingLevels","getReorderSegments","updatedString","getReorderedString","updatedRuns","selectedIndices","updatedGlyphs","updatedPositions","addedGlyphs","Set","has","id","isLigature","add","reorderParagraph","bidiReordering","DUMMY_CODEPOINT","resolve","next","getCharacterSpacing","characterSpacing","scalePositions","position","xSpacing","layoutRun","runString","glyphRun","generateGlyphs","res","resolveRunYOffset","p","resolveYOffset","sort","isEmpty","sortPoints","generatePoints","mergeRuns","groupEmptyRuns","groups","values","flattenEmptyRuns","flattenRegularRuns","points","attrs","stack","type","splice","flatten","emptyRuns","regularRuns","empty","omitFont","preprocessRuns","fontSubstitution","scriptItemizer","bidi","omittedFontRuns","itemizationRuns","substitutedRuns","bidiRuns","splitParagraphs","breakPoint","indexOf","advanceWidth$2","pos","advanceWidth$1","WHITE_SPACES_CODE","isWhiteSpace","leadingPositions","leadingWhitespaces","leadingOffset$1","leadingOffset","trailingPositions","trailingOffset$1","trailingOffset","dropLast$1","ALIGNMENT_FACTORS","center","right","removeNewLine","getOverflowLeft","overflowLeft","getOverflowRight","overflowRight","adjustOverflow","justifyLine$1","align","lineWidth","alignFactor","remainingWidth","shouldJustify","justification","finalizeLine","lineAscent","lineDescent","lineXAdvance","descent$1","finalizeBlock","isLastFragment","alignLastLine","textDecoration","finalizeFragments","blockFinalizer","ATTACHMENT_CODE","isReplaceGlyph","resolveRunAttachments","resolveAttachments","applyAttributes","backgroundColor","bullet","color","features","hangingPunctuation","hyphenationFactor","justificationFactor","lineSpacing","link","marginLeft","margin","marginRight","opacity","paddingTop","padding","paragraphSpacing","script","shrinkFactor","strike","strikeColor","strikeStyle","stroke","underline","underlineColor","underlineStyle","verticalAlign","wordSpacing","applyRunStyles","applyDefaultStyles","verticalAlignment","bidi$1","getBidiLevels","mirrorString","char","isRTL","mirroredChar","getMirroredCharacter","charAt","layoutEngine","processParagraph","processParagraphs","bidiEngine","getEmbeddingLevels","lastLevel","INFINITY","getNextBreakpoint","subnodes","widths","lineNumber","minimumBadness","sum","stretch","shrink","lineLength","calculateRatio","node","ratio","penalty","badness","abs","applyBestFit","nodes","count","breakpoints","breakpoint","LinkedListNode","data","prev","constructor","LinkedList","Node","tail","listSize","listLength","isLinked","size","first","callback","at","insertAfter","newNode","insertBefore","remove","demerits","fitnessClass","totals","previous","computeCost","lineLengths","active","currentLine","linebreak","infinity","computeSum","breakPointIndex","findBestBreakpoints","activeNodes","tmp","tolerance","flagged","fitness","mainLoop","candidates","pow","currentClass","tmpSum","candidate","precedesBox","glue","hyphenated","runA","runB","runAIndices","runALastIndex","runBIndices","insertGlyph$1","leadingRun","trailingRun","insert","runIndexAt","insertGlyph","runIndex","advanceWidthBetween$1","runStart","glyphStartIndex","glyphEndIndex","advanceWidthBetween","HYPHEN","TOLERANCE_STEPS","TOLERANCE_LIMIT","opts","breakLines","breaks","prevNode","getNodes","hyphenWidth","hyphenPenalty","hyphenationPenalty","s","getAttributes","Direction","WHITESPACE_PRIORITY","LETTER_PRIORITY","EXPAND_WHITESPACE_FACTOR","before","after","priority","unconstrained","EXPAND_CHAR_FACTOR","SHRINK_WHITESPACE_FACTOR","SHRINK_CHAR_FACTOR","getCharFactor","expandCharFactor","shrinkCharFactor","GROW","getWhitespaceFactor","expandWhitespaceFactor","shrinkWhitespaceFactor","factor","charFactor","whitespaceFactor","factors","f","isMark","getFactors","gap","SHRINK","getFactor","KASHIDA_PRIORITY","NULL_PRIORITY","getDistances","total","priorities","highestPriority","highestPrioritySum","remainingGap","prioritySum","distances","dist","justifyLine","BASE_FONT_SIZE","maxX","decorationLines","thickness","floor","decorationLine","ignoredScripts","lastScript","codePointAt","getScript","SOFT_HYPHEN","hyphenator","splitHyphen","cache","getParts","base","cacheKey","IGNORED_CODE_POINTS","getFontSize","pickFontFromFontStack","fontStack","lastFont","fontStackWithFallback","hasGlyphForCodePoint","lastFontSize","chars","default"],"mappings":"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","sourcesContent":["import { isNil, last, repeat, reverse, dropLast as dropLast$2, adjust, compose } from '@react-pdf/fns';\r\nimport bidiFactory from 'bidi-js';\r\nimport unicode from 'unicode-properties';\r\nimport hyphen from 'hyphen';\r\nimport pattern from 'hyphen/patterns/en-us.js';\r\n\r\n/**\r\n * Create attributed string from text fragments\r\n *\r\n * @param fragments - Fragments\r\n * @returns Attributed string\r\n */\r\nconst fromFragments = (fragments) => {\r\n    let offset = 0;\r\n    let string = '';\r\n    const runs = [];\r\n    fragments.forEach((fragment) => {\r\n        string += fragment.string;\r\n        runs.push({\r\n            ...fragment,\r\n            start: offset,\r\n            end: offset + fragment.string.length,\r\n            attributes: fragment.attributes || {},\r\n        });\r\n        offset += fragment.string.length;\r\n    });\r\n    return { string, runs };\r\n};\r\n\r\n/**\r\n * Default word hyphenation engine used when no one provided.\r\n * Does not perform word hyphenation at all\r\n *\r\n * @param word\r\n * @returns Same word\r\n */\r\nconst defaultHyphenationEngine = (word) => [word];\r\n/**\r\n * Wrap words of attribute string\r\n *\r\n * @param engines layout engines\r\n * @param options layout options\r\n */\r\nconst wrapWords = (engines = {}, options = {}) => {\r\n    /**\r\n     * @param attributedString - Attributed string\r\n     * @returns Attributed string including syllables\r\n     */\r\n    return (attributedString) => {\r\n        const syllables = [];\r\n        const fragments = [];\r\n        const hyphenateWord = options.hyphenationCallback ||\r\n            engines.wordHyphenation?.() ||\r\n            defaultHyphenationEngine;\r\n        for (let i = 0; i < attributedString.runs.length; i += 1) {\r\n            let string = '';\r\n            const run = attributedString.runs[i];\r\n            const words = attributedString.string\r\n                .slice(run.start, run.end)\r\n                .split(/([ ]+)/g)\r\n                .filter(Boolean);\r\n            for (let j = 0; j < words.length; j += 1) {\r\n                const word = words[j];\r\n                const parts = hyphenateWord(word);\r\n                syllables.push(...parts);\r\n                string += parts.join('');\r\n            }\r\n            fragments.push({ ...run, string });\r\n        }\r\n        const result = { ...fromFragments(fragments), syllables };\r\n        return result;\r\n    };\r\n};\r\n\r\n/**\r\n * Clone rect\r\n *\r\n * @param rect - Rect\r\n * @returns Cloned rect\r\n */\r\nconst copy = (rect) => {\r\n    return Object.assign({}, rect);\r\n};\r\n\r\n/**\r\n * Partition rect in two in the vertical direction\r\n *\r\n * @param rect - Rect\r\n * @param height - Height\r\n * @returns Partitioned rects\r\n */\r\nconst partition = (rect, height) => {\r\n    const a = Object.assign({}, rect, { height });\r\n    const b = Object.assign({}, rect, {\r\n        y: rect.y + height,\r\n        height: rect.height - height,\r\n    });\r\n    return [a, b];\r\n};\r\n\r\n/**\r\n * Crop upper section of rect\r\n *\r\n * @param height - Height\r\n * @param rect - Rect\r\n * @returns Cropped rect\r\n */\r\nconst crop = (height, rect) => {\r\n    const [, result] = partition(rect, height);\r\n    return result;\r\n};\r\n\r\n/**\r\n * Get paragraph block height\r\n *\r\n * @param paragraph - Paragraph\r\n * @returns Paragraph block height\r\n */\r\nconst height$2 = (paragraph) => {\r\n    return paragraph.reduce((acc, block) => acc + block.box.height, 0);\r\n};\r\n\r\n/**\r\n * Calculate run scale\r\n *\r\n * @param run - Run\r\n * @returns Scale\r\n */\r\nconst calculateScale = (run) => {\r\n    const attributes = run.attributes || {};\r\n    const fontSize = attributes.fontSize || 12;\r\n    const font = attributes.font;\r\n    const unitsPerEm = typeof font === 'string' ? null : font?.[0]?.unitsPerEm;\r\n    return unitsPerEm ? fontSize / unitsPerEm : 0;\r\n};\r\n/**\r\n * Get run scale\r\n *\r\n * @param  run\r\n * @returns Scale\r\n */\r\nconst scale = (run) => {\r\n    return run.attributes?.scale || calculateScale(run);\r\n};\r\n\r\n/**\r\n * Get ligature offset by index\r\n *\r\n * Ex. ffi ligature\r\n *\r\n *   glyphs:         l  o  f  f  i  m\r\n *   glyphIndices:   0  1  2  2  2  3\r\n *   offset:         0  0  0  1  2  0\r\n *\r\n * @param index\r\n * @param run - Run\r\n * @returns Ligature offset\r\n */\r\nconst offset = (index, run) => {\r\n    if (!run)\r\n        return 0;\r\n    const glyphIndices = run.glyphIndices || [];\r\n    const value = glyphIndices[index];\r\n    return glyphIndices.slice(0, index).filter((i) => i === value).length;\r\n};\r\n\r\n/**\r\n * Get run font\r\n *\r\n * @param run - Run\r\n * @returns Font\r\n */\r\nconst getFont = (run) => {\r\n    return run.attributes?.font?.[0] || null;\r\n};\r\n\r\n/**\r\n * Slice glyph between codePoints range\r\n * Util for breaking ligatures\r\n *\r\n * @param start - Start code point index\r\n * @param end - End code point index\r\n * @param font - Font to generate new glyph\r\n * @param glyph - Glyph to be sliced\r\n * @returns Sliced glyph parts\r\n */\r\nconst slice$2 = (start, end, font, glyph) => {\r\n    if (!glyph)\r\n        return [];\r\n    if (start === end)\r\n        return [];\r\n    if (start === 0 && end === glyph.codePoints.length)\r\n        return [glyph];\r\n    const codePoints = glyph.codePoints.slice(start, end);\r\n    const string = String.fromCodePoint(...codePoints);\r\n    // passing LTR To force fontkit to not reverse the string\r\n    return font\r\n        ? font.layout(string, undefined, undefined, undefined, 'ltr').glyphs\r\n        : [glyph];\r\n};\r\n\r\n/**\r\n * Return glyph index at string index, if glyph indices present.\r\n * Otherwise return string index\r\n *\r\n * @param index - Index\r\n * @param run - Run\r\n * @returns Glyph index\r\n */\r\nconst glyphIndexAt = (index, run) => {\r\n    const result = run?.glyphIndices?.[index];\r\n    return isNil(result) ? index : result;\r\n};\r\n\r\n/**\r\n * Returns new array starting with zero, and keeping same relation between consecutive values\r\n *\r\n * @param array - List\r\n * @returns Normalized array\r\n */\r\nconst normalize = (array) => {\r\n    const head = array[0];\r\n    return array.map((value) => value - head);\r\n};\r\n\r\n/**\r\n * Slice run between glyph indices range\r\n *\r\n * @param start - Glyph index\r\n * @param end - Glyph index\r\n * @param run - Run\r\n * @returns Sliced run\r\n */\r\nconst slice$1 = (start, end, run) => {\r\n    const runScale = scale(run);\r\n    const font = getFont(run);\r\n    // Get glyph start and end indices\r\n    const startIndex = glyphIndexAt(start, run);\r\n    const endIndex = glyphIndexAt(end, run);\r\n    // Get start and end glyph\r\n    const startGlyph = run.glyphs?.[startIndex];\r\n    const endGlyph = run.glyphs?.[endIndex];\r\n    // Get start ligature chunks (if any)\r\n    const startOffset = offset(start, run);\r\n    const startGlyphs = startOffset > 0 ? slice$2(startOffset, Infinity, font, startGlyph) : [];\r\n    // Get end ligature chunks (if any)\r\n    const endOffset = offset(end, run);\r\n    const endGlyphs = slice$2(0, endOffset, font, endGlyph);\r\n    // Compute new glyphs\r\n    const sliceStart = startIndex + Math.min(1, startOffset);\r\n    const glyphs = (run.glyphs || []).slice(sliceStart, endIndex);\r\n    // Compute new positions\r\n    const glyphPosition = (g) => ({\r\n        xAdvance: g.advanceWidth * runScale,\r\n        yAdvance: 0,\r\n        xOffset: 0,\r\n        yOffset: 0,\r\n    });\r\n    const startPositions = startGlyphs.map(glyphPosition);\r\n    const positions = (run.positions || []).slice(sliceStart, endIndex);\r\n    const endPositions = endGlyphs.map(glyphPosition);\r\n    return Object.assign({}, run, {\r\n        start: run.start + start,\r\n        end: Math.min(run.end, run.start + end),\r\n        glyphIndices: normalize((run.glyphIndices || []).slice(start, end)),\r\n        glyphs: [startGlyphs, glyphs, endGlyphs].flat(),\r\n        positions: [startPositions, positions, endPositions].flat(),\r\n    });\r\n};\r\n\r\n/**\r\n * Get run index that contains passed index\r\n *\r\n * @param index - Index\r\n * @param runs - Runs\r\n * @returns Run index\r\n */\r\nconst runIndexAt$1 = (index, runs) => {\r\n    if (!runs)\r\n        return -1;\r\n    return runs.findIndex((run) => run.start <= index && index < run.end);\r\n};\r\n\r\n/**\r\n * Filter runs contained between start and end\r\n *\r\n * @param start\r\n * @param end\r\n * @param runs\r\n * @returns Filtered runs\r\n */\r\nconst filter = (start, end, runs) => {\r\n    const startIndex = runIndexAt$1(start, runs);\r\n    const endIndex = Math.max(runIndexAt$1(end - 1, runs), startIndex);\r\n    return runs.slice(startIndex, endIndex + 1);\r\n};\r\n\r\n/**\r\n * Subtract scalar to run\r\n *\r\n * @param index - Scalar\r\n * @param run - Run\r\n * @returns Subtracted run\r\n */\r\nconst subtract = (index, run) => {\r\n    const start = run.start - index;\r\n    const end = run.end - index;\r\n    return Object.assign({}, run, { start, end });\r\n};\r\n\r\n/**\r\n * Slice array of runs\r\n *\r\n * @param start - Offset\r\n * @param end - Offset\r\n * @param runs\r\n * @returns Sliced runs\r\n */\r\nconst sliceRuns = (start, end, runs) => {\r\n    const sliceFirstRun = (a) => slice$1(start - a.start, end - a.start, a);\r\n    const sliceLastRun = (a) => slice$1(0, end - a.start, a);\r\n    return runs.map((run, i) => {\r\n        let result = run;\r\n        const isFirst = i === 0;\r\n        const isLast = !isFirst && i === runs.length - 1;\r\n        if (isFirst)\r\n            result = sliceFirstRun(run);\r\n        if (isLast)\r\n            result = sliceLastRun(run);\r\n        return subtract(start, result);\r\n    });\r\n};\r\n/**\r\n * Slice attributed string between two indices\r\n *\r\n * @param start - Offset\r\n * @param end - Offset\r\n * @param attributedString - Attributed string\r\n * @returns Attributed string\r\n */\r\nconst slice = (start, end, attributedString) => {\r\n    if (attributedString.string.length === 0)\r\n        return attributedString;\r\n    const string = attributedString.string.slice(start, end);\r\n    const filteredRuns = filter(start, end, attributedString.runs);\r\n    const slicedRuns = sliceRuns(start, end, filteredRuns);\r\n    return Object.assign({}, attributedString, { string, runs: slicedRuns });\r\n};\r\n\r\nconst findCharIndex = (string) => {\r\n    return string.search(/\\S/g);\r\n};\r\nconst findLastCharIndex = (string) => {\r\n    const match = string.match(/\\S/g);\r\n    return match ? string.lastIndexOf(match[match.length - 1]) : -1;\r\n};\r\n/**\r\n * Removes (strips) whitespace from both ends of the attributted string.\r\n *\r\n * @param attributedString - Attributed string\r\n * @returns Attributed string\r\n */\r\nconst trim = (attributedString) => {\r\n    const start = findCharIndex(attributedString.string);\r\n    const end = findLastCharIndex(attributedString.string);\r\n    return slice(start, end + 1, attributedString);\r\n};\r\n\r\n/**\r\n * Returns empty run\r\n *\r\n * @returns Empty run\r\n */\r\nconst empty$1 = () => {\r\n    return {\r\n        start: 0,\r\n        end: 0,\r\n        glyphIndices: [],\r\n        glyphs: [],\r\n        positions: [],\r\n        attributes: {},\r\n    };\r\n};\r\n\r\n/**\r\n * Check if value is a number\r\n *\r\n * @param value - Value to check\r\n * @returns Whether value is a number\r\n */\r\nconst isNumber = (value) => {\r\n    return typeof value === 'number';\r\n};\r\n\r\n/**\r\n * Append glyph indices with given length\r\n *\r\n * Ex. appendIndices(3, [0, 1, 2, 2]) => [0, 1, 2, 2, 3, 3, 3]\r\n *\r\n * @param length - Length\r\n * @param indices - Glyph indices\r\n * @returns Extended glyph indices\r\n */\r\nconst appendIndices = (length, indices) => {\r\n    const lastIndex = last(indices);\r\n    const value = isNil(lastIndex) ? 0 : lastIndex + 1;\r\n    const newIndices = Array(length).fill(value);\r\n    return indices.concat(newIndices);\r\n};\r\n\r\n/**\r\n * Get glyph for a given code point\r\n *\r\n * @param value - CodePoint\r\n * @param font - Font\r\n * @returns Glyph\r\n * */\r\nconst fromCodePoint = (value, font) => {\r\n    if (typeof font === 'string')\r\n        return null;\r\n    return font && value ? font.glyphForCodePoint(value) : null;\r\n};\r\n\r\n/**\r\n * Append glyph to run\r\n *\r\n * @param glyph - Glyph\r\n * @param run - Run\r\n * @returns Run with glyph\r\n */\r\nconst appendGlyph = (glyph, run) => {\r\n    const glyphLength = glyph.codePoints?.length || 0;\r\n    const end = run.end + glyphLength;\r\n    const glyphs = run.glyphs.concat(glyph);\r\n    const glyphIndices = appendIndices(glyphLength, run.glyphIndices);\r\n    if (!run.positions)\r\n        return Object.assign({}, run, { end, glyphs, glyphIndices });\r\n    const positions = run.positions.concat({\r\n        xAdvance: glyph.advanceWidth * scale(run),\r\n        yAdvance: 0,\r\n        xOffset: 0,\r\n        yOffset: 0,\r\n    });\r\n    return Object.assign({}, run, { end, glyphs, glyphIndices, positions });\r\n};\r\n/**\r\n * Append glyph or code point to run\r\n *\r\n * @param value - Glyph or codePoint\r\n * @param run - Run\r\n * @returns Run with glyph\r\n */\r\nconst append$1 = (value, run) => {\r\n    if (!value)\r\n        return run;\r\n    const font = getFont(run);\r\n    const glyph = isNumber(value) ? fromCodePoint(value, font) : value;\r\n    return appendGlyph(glyph, run);\r\n};\r\n\r\n/**\r\n * Get string from array of code points\r\n *\r\n * @param codePoints - Points\r\n * @returns String\r\n */\r\nconst stringFromCodePoints = (codePoints) => {\r\n    return String.fromCodePoint(...(codePoints || []));\r\n};\r\n\r\n/**\r\n * Append glyph into last run of attributed string\r\n *\r\n * @param glyph - Glyph or code point\r\n * @param attributedString - Attributed string\r\n * @returns Attributed string with new glyph\r\n */\r\nconst append = (glyph, attributedString) => {\r\n    const codePoints = typeof glyph === 'number' ? [glyph] : glyph?.codePoints;\r\n    const codePointsString = stringFromCodePoints(codePoints || []);\r\n    const string = attributedString.string + codePointsString;\r\n    const firstRuns = attributedString.runs.slice(0, -1);\r\n    const lastRun = last(attributedString.runs) || empty$1();\r\n    const runs = firstRuns.concat(append$1(glyph, lastRun));\r\n    return Object.assign({}, attributedString, { string, runs });\r\n};\r\n\r\nconst ELLIPSIS_UNICODE = 8230;\r\nconst ELLIPSIS_STRING = String.fromCharCode(ELLIPSIS_UNICODE);\r\n/**\r\n * Get ellipsis codepoint. This may be different in standard and embedded fonts\r\n *\r\n * @param font\r\n * @returns Ellipsis codepoint\r\n */\r\nconst getEllipsisCodePoint = (font) => {\r\n    if (!font.encode)\r\n        return ELLIPSIS_UNICODE;\r\n    const [codePoints] = font.encode(ELLIPSIS_STRING);\r\n    return parseInt(codePoints[0], 16);\r\n};\r\n/**\r\n * Trucante block with ellipsis\r\n *\r\n * @param paragraph - Paragraph\r\n * @returns Sliced paragraph\r\n */\r\nconst truncate = (paragraph) => {\r\n    const runs = last(paragraph)?.runs || [];\r\n    const font = last(runs)?.attributes?.font[0];\r\n    if (font) {\r\n        const index = paragraph.length - 1;\r\n        const codePoint = getEllipsisCodePoint(font);\r\n        const glyph = font.glyphForCodePoint(codePoint);\r\n        const lastBlock = append(glyph, trim(paragraph[index]));\r\n        return Object.assign([], paragraph, { [index]: lastBlock });\r\n    }\r\n    return paragraph;\r\n};\r\n\r\n/**\r\n * Omit attribute from run\r\n *\r\n * @param value - Attribute key\r\n * @param run - Run\r\n * @returns Run without ommited attribute\r\n */\r\nconst omit = (value, run) => {\r\n    const attributes = Object.assign({}, run.attributes);\r\n    delete attributes[value];\r\n    return Object.assign({}, run, { attributes });\r\n};\r\n\r\n/**\r\n * Get run ascent\r\n *\r\n * @param run - Run\r\n * @returns Ascent\r\n */\r\nconst ascent$1 = (run) => {\r\n    const { font, attachment } = run.attributes;\r\n    const attachmentHeight = attachment?.height || 0;\r\n    const fontAscent = typeof font === 'string' ? 0 : font?.[0]?.ascent || 0;\r\n    return Math.max(attachmentHeight, fontAscent * scale(run));\r\n};\r\n\r\n/**\r\n * Get run descent\r\n *\r\n * @param run - Run\r\n * @returns Descent\r\n */\r\nconst descent = (run) => {\r\n    const font = run.attributes?.font;\r\n    const fontDescent = typeof font === 'string' ? 0 : font?.[0]?.descent || 0;\r\n    return scale(run) * fontDescent;\r\n};\r\n\r\n/**\r\n * Get run lineGap\r\n *\r\n * @param run - Run\r\n * @returns LineGap\r\n */\r\nconst lineGap = (run) => {\r\n    const font = run.attributes?.font;\r\n    const lineGap = typeof font === 'string' ? 0 : font?.[0]?.lineGap || 0;\r\n    return lineGap * scale(run);\r\n};\r\n\r\n/**\r\n * Get run height\r\n *\r\n * @param run - Run\r\n * @returns Height\r\n */\r\nconst height$1 = (run) => {\r\n    const lineHeight = run.attributes?.lineHeight;\r\n    return lineHeight || lineGap(run) + ascent$1(run) - descent(run);\r\n};\r\n\r\n/**\r\n * Returns attributed string height\r\n *\r\n * @param attributedString - Attributed string\r\n * @returns Height\r\n */\r\nconst height = (attributedString) => {\r\n    const reducer = (acc, run) => Math.max(acc, height$1(run));\r\n    return attributedString.runs.reduce(reducer, 0);\r\n};\r\n\r\n/**\r\n * Checks if two rects intersect each other\r\n *\r\n * @param a - Rect A\r\n * @param b - Rect B\r\n * @returns Whether rects intersect\r\n */\r\nconst intersects = (a, b) => {\r\n    const x = Math.max(a.x, b.x);\r\n    const num1 = Math.min(a.x + a.width, b.x + b.width);\r\n    const y = Math.max(a.y, b.y);\r\n    const num2 = Math.min(a.y + a.height, b.y + b.height);\r\n    return num1 >= x && num2 >= y;\r\n};\r\n\r\nconst getLineFragment = (lineRect, excludeRect) => {\r\n    if (!intersects(excludeRect, lineRect))\r\n        return [lineRect];\r\n    const eStart = excludeRect.x;\r\n    const eEnd = excludeRect.x + excludeRect.width;\r\n    const lStart = lineRect.x;\r\n    const lEnd = lineRect.x + lineRect.width;\r\n    const a = Object.assign({}, lineRect, { width: eStart - lStart });\r\n    const b = Object.assign({}, lineRect, { x: eEnd, width: lEnd - eEnd });\r\n    return [a, b].filter((r) => r.width > 0);\r\n};\r\nconst getLineFragments = (rect, excludeRects) => {\r\n    let fragments = [rect];\r\n    for (let i = 0; i < excludeRects.length; i += 1) {\r\n        const excludeRect = excludeRects[i];\r\n        fragments = fragments.reduce((acc, fragment) => {\r\n            const pieces = getLineFragment(fragment, excludeRect);\r\n            return acc.concat(pieces);\r\n        }, []);\r\n    }\r\n    return fragments;\r\n};\r\nconst generateLineRects = (container, height) => {\r\n    const { excludeRects, ...rect } = container;\r\n    if (!excludeRects)\r\n        return [rect];\r\n    const lineRects = [];\r\n    const maxY = Math.max(...excludeRects.map((r) => r.y + r.height));\r\n    let currentRect = rect;\r\n    while (currentRect.y < maxY) {\r\n        const [lineRect, rest] = partition(currentRect, height);\r\n        const lineRectFragments = getLineFragments(lineRect, excludeRects);\r\n        currentRect = rest;\r\n        lineRects.push(...lineRectFragments);\r\n    }\r\n    return [...lineRects, currentRect];\r\n};\r\n\r\nconst ATTACHMENT_CODE$1 = '\\ufffc'; // 65532\r\n/**\r\n * Remove attachment attribute if no char present\r\n *\r\n * @param line - Line\r\n * @returns Line\r\n */\r\nconst purgeAttachments = (line) => {\r\n    const shouldPurge = !line.string.includes(ATTACHMENT_CODE$1);\r\n    if (!shouldPurge)\r\n        return line;\r\n    const runs = line.runs.map((run) => omit('attachment', run));\r\n    return Object.assign({}, line, { runs });\r\n};\r\n/**\r\n * Layout paragraphs inside rectangle\r\n *\r\n * @param rects - Rects\r\n * @param lines - Attributed strings\r\n * @param indent\r\n * @returns layout blocks\r\n */\r\nconst layoutLines = (rects, lines, indent) => {\r\n    let rect = rects.shift();\r\n    let currentY = rect.y;\r\n    return lines.map((line, i) => {\r\n        const lineIndent = i === 0 ? indent : 0;\r\n        const style = line.runs?.[0]?.attributes || {};\r\n        const height$1 = Math.max(height(line), style.lineHeight);\r\n        if (currentY + height$1 > rect.y + rect.height && rects.length > 0) {\r\n            rect = rects.shift();\r\n            currentY = rect.y;\r\n        }\r\n        const newLine = {\r\n            string: line.string,\r\n            runs: line.runs,\r\n            box: {\r\n                x: rect.x + lineIndent,\r\n                y: currentY,\r\n                width: rect.width - lineIndent,\r\n                height: height$1,\r\n            },\r\n        };\r\n        currentY += height$1;\r\n        return purgeAttachments(newLine);\r\n    });\r\n};\r\n/**\r\n * Performs line breaking and layout\r\n *\r\n * @param engines - Engines\r\n * @param options - Layout options\r\n */\r\nconst layoutParagraph = (engines, options = {}) => {\r\n    /**\r\n     * @param container - Container\r\n     * @param paragraph - Attributed string\r\n     * @returns Layout block\r\n     */\r\n    return (container, paragraph) => {\r\n        const height$1 = height(paragraph);\r\n        const indent = paragraph.runs?.[0]?.attributes?.indent || 0;\r\n        const rects = generateLineRects(container, height$1);\r\n        const availableWidths = rects.map((r) => r.width);\r\n        availableWidths.unshift(availableWidths[0] - indent);\r\n        const lines = engines.linebreaker(options)(paragraph, availableWidths);\r\n        return layoutLines(rects, lines, indent);\r\n    };\r\n};\r\n\r\n/**\r\n * Slice block at given height\r\n *\r\n * @param height - Height\r\n * @param paragraph - Paragraph\r\n * @returns Sliced paragraph\r\n */\r\nconst sliceAtHeight = (height, paragraph) => {\r\n    const newBlock = [];\r\n    let counter = 0;\r\n    for (let i = 0; i < paragraph.length; i += 1) {\r\n        const line = paragraph[i];\r\n        counter += line.box.height;\r\n        if (counter < height) {\r\n            newBlock.push(line);\r\n        }\r\n        else {\r\n            break;\r\n        }\r\n    }\r\n    return newBlock;\r\n};\r\n\r\n/**\r\n * Layout paragraphs inside container until it does not\r\n * fit anymore, performing line wrapping in the process.\r\n *\r\n * @param  engines - Engines\r\n * @param  options - Layout options\r\n * @param container - Container\r\n */\r\nconst typesetter = (engines, options, container) => {\r\n    /**\r\n     * @param attributedStrings - Attributed strings (paragraphs)\r\n     * @returns Paragraph blocks\r\n     */\r\n    return (attributedStrings) => {\r\n        const result = [];\r\n        const paragraphs = [...attributedStrings];\r\n        const layout = layoutParagraph(engines, options);\r\n        const maxLines = isNil(container.maxLines) ? Infinity : container.maxLines;\r\n        const truncateEllipsis = container.truncateMode === 'ellipsis';\r\n        let linesCount = maxLines;\r\n        let paragraphRect = copy(container);\r\n        let nextParagraph = paragraphs.shift();\r\n        while (linesCount > 0 && nextParagraph) {\r\n            const paragraph = layout(paragraphRect, nextParagraph);\r\n            const slicedBlock = paragraph.slice(0, linesCount);\r\n            const linesHeight = height$2(slicedBlock);\r\n            const shouldTruncate = truncateEllipsis && paragraph.length !== slicedBlock.length;\r\n            linesCount -= slicedBlock.length;\r\n            if (paragraphRect.height >= linesHeight) {\r\n                result.push(shouldTruncate ? truncate(slicedBlock) : slicedBlock);\r\n                paragraphRect = crop(linesHeight, paragraphRect);\r\n                nextParagraph = paragraphs.shift();\r\n            }\r\n            else {\r\n                result.push(truncate(sliceAtHeight(paragraphRect.height, slicedBlock)));\r\n                break;\r\n            }\r\n        }\r\n        return result;\r\n    };\r\n};\r\n\r\n/**\r\n * Get attributed string start value\r\n *\r\n * @param attributedString - Attributed string\r\n * @returns Start\r\n */\r\nconst start = (attributedString) => {\r\n    const { runs } = attributedString;\r\n    return runs.length === 0 ? 0 : runs[0].start;\r\n};\r\n\r\n/**\r\n * Get attributed string end value\r\n *\r\n * @param attributedString - Attributed string\r\n * @returns End\r\n */\r\nconst end = (attributedString) => {\r\n    const { runs } = attributedString;\r\n    return runs.length === 0 ? 0 : last(runs).end;\r\n};\r\n\r\n/**\r\n * Get attributed string length\r\n *\r\n * @param attributedString - Attributed string\r\n * @returns End\r\n */\r\nconst length$1 = (attributedString) => {\r\n    return end(attributedString) - start(attributedString);\r\n};\r\n\r\nconst bidi$2 = bidiFactory();\r\nconst getBidiLevels$1 = (runs) => {\r\n    return runs.reduce((acc, run) => {\r\n        const length = run.end - run.start;\r\n        const levels = repeat(run.attributes.bidiLevel, length);\r\n        return acc.concat(levels);\r\n    }, []);\r\n};\r\nconst getReorderedIndices = (string, segments) => {\r\n    // Fill an array with indices\r\n    const indices = [];\r\n    for (let i = 0; i < string.length; i += 1) {\r\n        indices[i] = i;\r\n    }\r\n    // Reverse each segment in order\r\n    segments.forEach(([start, end]) => {\r\n        const slice = indices.slice(start, end + 1);\r\n        for (let i = slice.length - 1; i >= 0; i -= 1) {\r\n            indices[end - i] = slice[i];\r\n        }\r\n    });\r\n    return indices;\r\n};\r\nconst getItemAtIndex = (runs, objectName, index) => {\r\n    for (let i = 0; i < runs.length; i += 1) {\r\n        const run = runs[i];\r\n        const updatedIndex = run.glyphIndices[index - run.start];\r\n        if (index >= run.start && index < run.end) {\r\n            return run[objectName][updatedIndex];\r\n        }\r\n    }\r\n    throw new Error(`index ${index} out of range`);\r\n};\r\nconst reorderLine = (line) => {\r\n    const levels = getBidiLevels$1(line.runs);\r\n    const direction = line.runs[0]?.attributes.direction;\r\n    const level = direction === 'rtl' ? 1 : 0;\r\n    const end = length$1(line) - 1;\r\n    const paragraphs = [{ start: 0, end, level }];\r\n    const embeddingLevels = { paragraphs, levels };\r\n    const segments = bidi$2.getReorderSegments(line.string, embeddingLevels);\r\n    // No need for bidi reordering\r\n    if (segments.length === 0)\r\n        return line;\r\n    const indices = getReorderedIndices(line.string, segments);\r\n    const updatedString = bidi$2.getReorderedString(line.string, embeddingLevels);\r\n    const updatedRuns = line.runs.map((run) => {\r\n        const selectedIndices = indices.slice(run.start, run.end);\r\n        const updatedGlyphs = [];\r\n        const updatedPositions = [];\r\n        const addedGlyphs = new Set();\r\n        for (let i = 0; i < selectedIndices.length; i += 1) {\r\n            const index = selectedIndices[i];\r\n            const glyph = getItemAtIndex(line.runs, 'glyphs', index);\r\n            if (addedGlyphs.has(glyph.id))\r\n                continue;\r\n            updatedGlyphs.push(glyph);\r\n            updatedPositions.push(getItemAtIndex(line.runs, 'positions', index));\r\n            if (glyph.isLigature) {\r\n                addedGlyphs.add(glyph.id);\r\n            }\r\n        }\r\n        return {\r\n            ...run,\r\n            glyphs: updatedGlyphs,\r\n            positions: updatedPositions,\r\n        };\r\n    });\r\n    return {\r\n        box: line.box,\r\n        runs: updatedRuns,\r\n        string: updatedString,\r\n    };\r\n};\r\nconst reorderParagraph = (paragraph) => paragraph.map(reorderLine);\r\n/**\r\n * Perform bidi reordering\r\n *\r\n * @returns Reordered paragraphs\r\n */\r\nconst bidiReordering = () => {\r\n    /**\r\n     * @param paragraphs - Paragraphs\r\n     * @returns Reordered paragraphs\r\n     */\r\n    return (paragraphs) => paragraphs.map(reorderParagraph);\r\n};\r\n\r\nconst DUMMY_CODEPOINT = 123;\r\n/**\r\n * Resolve string indices based on glyphs code points\r\n *\r\n * @param glyphs\r\n * @returns Glyph indices\r\n */\r\nconst resolve = (glyphs = []) => {\r\n    return glyphs.reduce((acc, glyph) => {\r\n        const codePoints = glyph?.codePoints || [DUMMY_CODEPOINT];\r\n        if (acc.length === 0)\r\n            return codePoints.map(() => 0);\r\n        const last = acc[acc.length - 1];\r\n        const next = codePoints.map(() => last + 1);\r\n        return [...acc, ...next];\r\n    }, []);\r\n};\r\n\r\nconst getCharacterSpacing = (run) => {\r\n    return run.attributes?.characterSpacing || 0;\r\n};\r\n/**\r\n * Scale run positions\r\n *\r\n * @param  run\r\n * @param  positions\r\n * @returns Scaled positions\r\n */\r\nconst scalePositions = (run, positions) => {\r\n    const runScale = scale(run);\r\n    const characterSpacing = getCharacterSpacing(run);\r\n    return positions.map((position, i) => {\r\n        const isLast = i === positions.length;\r\n        const xSpacing = isLast ? 0 : characterSpacing;\r\n        return Object.assign({}, position, {\r\n            xAdvance: position.xAdvance * runScale + xSpacing,\r\n            yAdvance: position.yAdvance * runScale,\r\n            xOffset: position.xOffset * runScale,\r\n            yOffset: position.yOffset * runScale,\r\n        });\r\n    });\r\n};\r\n/**\r\n * Create glyph run\r\n *\r\n * @param string string\r\n */\r\nconst layoutRun = (string) => {\r\n    /**\r\n     * @param run - Run\r\n     * @returns Glyph run\r\n     */\r\n    return (run) => {\r\n        const { start, end, attributes = {} } = run;\r\n        const { font } = attributes;\r\n        if (!font)\r\n            return { ...run, glyphs: [], glyphIndices: [], positions: [] };\r\n        const runString = string.slice(start, end);\r\n        if (typeof font === 'string')\r\n            throw new Error('Invalid font');\r\n        // passing LTR To force fontkit to not reverse the string\r\n        const glyphRun = font[0].layout(runString, undefined, undefined, undefined, 'ltr');\r\n        const positions = scalePositions(run, glyphRun.positions);\r\n        const glyphIndices = resolve(glyphRun.glyphs);\r\n        const result = {\r\n            ...run,\r\n            positions,\r\n            glyphIndices,\r\n            glyphs: glyphRun.glyphs,\r\n        };\r\n        return result;\r\n    };\r\n};\r\n/**\r\n * Generate glyphs for single attributed string\r\n */\r\nconst generateGlyphs = () => {\r\n    /**\r\n     * @param attributedString - Attributed string\r\n     * @returns Attributed string with glyphs\r\n     */\r\n    return (attributedString) => {\r\n        const runs = attributedString.runs.map(layoutRun(attributedString.string));\r\n        const res = Object.assign({}, attributedString, { runs });\r\n        return res;\r\n    };\r\n};\r\n\r\n/**\r\n * Resolves yOffset for run\r\n *\r\n * @param run - Run\r\n * @returns Run\r\n */\r\nconst resolveRunYOffset = (run) => {\r\n    if (!run.positions)\r\n        return run;\r\n    const unitsPerEm = run.attributes?.font?.[0]?.unitsPerEm || 0;\r\n    const yOffset = (run.attributes?.yOffset || 0) * unitsPerEm;\r\n    const positions = run.positions.map((p) => Object.assign({}, p, { yOffset }));\r\n    return Object.assign({}, run, { positions });\r\n};\r\n/**\r\n * Resolves yOffset for multiple paragraphs\r\n */\r\nconst resolveYOffset = () => {\r\n    /**\r\n     * @param attributedString - Attributed string\r\n     * @returns Attributed string\r\n     */\r\n    return (attributedString) => {\r\n        const runs = attributedString.runs.map(resolveRunYOffset);\r\n        const res = Object.assign({}, attributedString, { runs });\r\n        return res;\r\n    };\r\n};\r\n\r\n/**\r\n * Sort runs in ascending order\r\n *\r\n * @param runs\r\n * @returns Sorted runs\r\n */\r\nconst sort = (runs) => {\r\n    return runs.sort((a, b) => a.start - b.start || a.end - b.end);\r\n};\r\n\r\n/**\r\n * Is run empty (start === end)\r\n *\r\n * @param run - Run\r\n * @returns Is run empty\r\n */\r\nconst isEmpty = (run) => {\r\n    return run.start === run.end;\r\n};\r\n\r\n/**\r\n * Sort points in ascending order\r\n * @param a - First point\r\n * @param b - Second point\r\n * @returns Sort order\r\n */\r\nconst sortPoints = (a, b) => {\r\n    return a[1] - b[1] || a[3] - b[3];\r\n};\r\n/**\r\n * @param runs\r\n * @returns Points\r\n */\r\nconst generatePoints = (runs) => {\r\n    const result = runs.reduce((acc, run, i) => {\r\n        return acc.concat([\r\n            ['start', run.start, run.attributes, i],\r\n            ['end', run.end, run.attributes, i],\r\n        ]);\r\n    }, []);\r\n    return result.sort(sortPoints);\r\n};\r\n/**\r\n * @param runs\r\n * @returns Merged runs\r\n */\r\nconst mergeRuns = (runs) => {\r\n    return runs.reduce((acc, run) => {\r\n        const attributes = Object.assign({}, acc.attributes, run.attributes);\r\n        return Object.assign({}, run, { attributes });\r\n    }, {});\r\n};\r\n/**\r\n * @param runs\r\n * @returns Grouped runs\r\n */\r\nconst groupEmptyRuns = (runs) => {\r\n    const groups = runs.reduce((acc, run) => {\r\n        if (!acc[run.start])\r\n            acc[run.start] = [];\r\n        acc[run.start].push(run);\r\n        return acc;\r\n    }, []);\r\n    return Object.values(groups);\r\n};\r\n/**\r\n * @param runs\r\n * @returns Flattened runs\r\n */\r\nconst flattenEmptyRuns = (runs) => {\r\n    return groupEmptyRuns(runs).map(mergeRuns);\r\n};\r\n/**\r\n * @param runs\r\n * @returns Flattened runs\r\n */\r\nconst flattenRegularRuns = (runs) => {\r\n    const res = [];\r\n    const points = generatePoints(runs);\r\n    let start = -1;\r\n    let attrs = {};\r\n    const stack = [];\r\n    for (let i = 0; i < points.length; i += 1) {\r\n        const [type, offset, attributes] = points[i];\r\n        if (start !== -1 && start < offset) {\r\n            res.push({\r\n                start,\r\n                end: offset,\r\n                attributes: attrs,\r\n                glyphIndices: [],\r\n                glyphs: [],\r\n                positions: [],\r\n            });\r\n        }\r\n        if (type === 'start') {\r\n            stack.push(attributes);\r\n            attrs = Object.assign({}, attrs, attributes);\r\n        }\r\n        else {\r\n            attrs = {};\r\n            for (let j = 0; j < stack.length; j += 1) {\r\n                if (stack[j] === attributes) {\r\n                    stack.splice(j--, 1);\r\n                }\r\n                else {\r\n                    attrs = Object.assign({}, attrs, stack[j]);\r\n                }\r\n            }\r\n        }\r\n        start = offset;\r\n    }\r\n    return res;\r\n};\r\n/**\r\n * Flatten many runs\r\n *\r\n * @param runs\r\n * @returns Flattened runs\r\n */\r\nconst flatten = (runs = []) => {\r\n    const emptyRuns = flattenEmptyRuns(runs.filter((run) => isEmpty(run)));\r\n    const regularRuns = flattenRegularRuns(runs.filter((run) => !isEmpty(run)));\r\n    return sort(emptyRuns.concat(regularRuns));\r\n};\r\n\r\n/**\r\n * Returns empty attributed string\r\n *\r\n * @returns Empty attributed string\r\n */\r\nconst empty = () => ({ string: '', runs: [] });\r\n\r\n/**\r\n *\r\n * @param attributedString\r\n * @returns Attributed string without font\r\n */\r\nconst omitFont = (attributedString) => {\r\n    const runs = attributedString.runs.map((run) => omit('font', run));\r\n    return Object.assign({}, attributedString, { runs });\r\n};\r\n/**\r\n * Performs font substitution and script itemization on attributed string\r\n *\r\n * @param engines - engines\r\n */\r\nconst preprocessRuns = (engines) => {\r\n    /**\r\n     * @param attributedString - Attributed string\r\n     * @returns Processed attributed string\r\n     */\r\n    return (attributedString) => {\r\n        if (isNil(attributedString))\r\n            return empty();\r\n        const { string } = attributedString;\r\n        const { fontSubstitution, scriptItemizer, bidi } = engines;\r\n        const { runs: omittedFontRuns } = omitFont(attributedString);\r\n        const { runs: itemizationRuns } = scriptItemizer()(attributedString);\r\n        const { runs: substitutedRuns } = fontSubstitution()(attributedString);\r\n        const { runs: bidiRuns } = bidi()(attributedString);\r\n        const runs = bidiRuns\r\n            .concat(substitutedRuns)\r\n            .concat(itemizationRuns)\r\n            .concat(omittedFontRuns);\r\n        return { string, runs: flatten(runs) };\r\n    };\r\n};\r\n\r\n/**\r\n * Breaks attributed string into paragraphs\r\n */\r\nconst splitParagraphs = () => {\r\n    /**\r\n     * @param attributedString - Attributed string\r\n     * @returns Paragraphs attributed strings\r\n     */\r\n    return (attributedString) => {\r\n        const paragraphs = [];\r\n        let start = 0;\r\n        let breakPoint = attributedString.string.indexOf('\\n') + 1;\r\n        while (breakPoint > 0) {\r\n            paragraphs.push(slice(start, breakPoint, attributedString));\r\n            start = breakPoint;\r\n            breakPoint = attributedString.string.indexOf('\\n', breakPoint) + 1;\r\n        }\r\n        if (start === 0) {\r\n            paragraphs.push(attributedString);\r\n        }\r\n        else if (start < attributedString.string.length) {\r\n            paragraphs.push(slice(start, length$1(attributedString), attributedString));\r\n        }\r\n        return paragraphs;\r\n    };\r\n};\r\n\r\n/**\r\n * Return positions advance width\r\n *\r\n * @param positions - Positions\r\n * @returns {number} advance width\r\n */\r\nconst advanceWidth$2 = (positions) => {\r\n    return positions.reduce((acc, pos) => acc + (pos.xAdvance || 0), 0);\r\n};\r\n\r\n/**\r\n * Return run advance width\r\n *\r\n * @param run - Run\r\n * @returns Advance width\r\n */\r\nconst advanceWidth$1 = (run) => {\r\n    return advanceWidth$2(run.positions || []);\r\n};\r\n\r\n/**\r\n * Returns attributed string advancewidth\r\n *\r\n * @param attributedString - Attributed string\r\n * @returns Advance width\r\n */\r\nconst advanceWidth = (attributedString) => {\r\n    const reducer = (acc, run) => acc + advanceWidth$1(run);\r\n    return attributedString.runs.reduce(reducer, 0);\r\n};\r\n\r\nconst WHITE_SPACES_CODE = 32;\r\n/**\r\n * Check if glyph is white space\r\n *\r\n * @param glyph - Glyph\r\n * @returns Whether glyph is white space\r\n * */\r\nconst isWhiteSpace = (glyph) => {\r\n    const codePoints = glyph?.codePoints || [];\r\n    return codePoints.includes(WHITE_SPACES_CODE);\r\n};\r\n\r\n/**\r\n * Get white space leading positions\r\n *\r\n * @param run - Run\r\n * @returns White space leading positions\r\n */\r\nconst leadingPositions = (run) => {\r\n    const glyphs = run.glyphs || [];\r\n    const positions = run.positions || [];\r\n    const leadingWhitespaces = glyphs.findIndex((g) => !isWhiteSpace(g));\r\n    return positions.slice(0, leadingWhitespaces);\r\n};\r\n/**\r\n * Get run leading white space offset\r\n *\r\n * @param run - Run\r\n * @returns Leading white space offset\r\n */\r\nconst leadingOffset$1 = (run) => {\r\n    const positions = leadingPositions(run);\r\n    return positions.reduce((acc, pos) => acc + (pos.xAdvance || 0), 0);\r\n};\r\n\r\n/**\r\n * Get attributed string leading white space offset\r\n *\r\n * @param attributedString - Attributed string\r\n * @returns Leading white space offset\r\n */\r\nconst leadingOffset = (attributedString) => {\r\n    const runs = attributedString.runs || [];\r\n    return leadingOffset$1(runs[0]);\r\n};\r\n\r\n/**\r\n * Get white space trailing positions\r\n *\r\n * @param run run\r\n * @returns White space trailing positions\r\n */\r\nconst trailingPositions = (run) => {\r\n    const glyphs = reverse(run.glyphs || []);\r\n    const positions = reverse(run.positions || []);\r\n    const leadingWhitespaces = glyphs.findIndex((g) => !isWhiteSpace(g));\r\n    return positions.slice(0, leadingWhitespaces);\r\n};\r\n/**\r\n * Get run trailing white space offset\r\n *\r\n * @param run - Run\r\n * @returns Trailing white space offset\r\n */\r\nconst trailingOffset$1 = (run) => {\r\n    const positions = trailingPositions(run);\r\n    return positions.reduce((acc, pos) => acc + (pos.xAdvance || 0), 0);\r\n};\r\n\r\n/**\r\n * Get attributed string trailing white space offset\r\n *\r\n * @param attributedString - Attributed string\r\n * @returns Trailing white space offset\r\n */\r\nconst trailingOffset = (attributedString) => {\r\n    const runs = attributedString.runs || [];\r\n    return trailingOffset$1(last(runs));\r\n};\r\n\r\n/**\r\n * Drop last char of run\r\n *\r\n * @param run - Run\r\n * @returns Run without last char\r\n */\r\nconst dropLast$1 = (run) => {\r\n    return slice$1(0, run.end - run.start - 1, run);\r\n};\r\n\r\n/**\r\n * Drop last glyph\r\n *\r\n * @param attributedString - Attributed string\r\n * @returns Attributed string with new glyph\r\n */\r\nconst dropLast = (attributedString) => {\r\n    const string = dropLast$2(attributedString.string);\r\n    const runs = adjust(-1, dropLast$1, attributedString.runs);\r\n    return Object.assign({}, attributedString, { string, runs });\r\n};\r\n\r\nconst ALIGNMENT_FACTORS = { center: 0.5, right: 1 };\r\n/**\r\n * Remove new line char at the end of line if present\r\n *\r\n * @param line\r\n * @returns Line\r\n */\r\nconst removeNewLine = (line) => {\r\n    return last(line.string) === '\\n' ? dropLast(line) : line;\r\n};\r\nconst getOverflowLeft = (line) => {\r\n    return leadingOffset(line) + (line.overflowLeft || 0);\r\n};\r\nconst getOverflowRight = (line) => {\r\n    return trailingOffset(line) + (line.overflowRight || 0);\r\n};\r\n/**\r\n * Ignore whitespace at the start and end of a line for alignment\r\n *\r\n * @param line\r\n * @returns Line\r\n */\r\nconst adjustOverflow = (line) => {\r\n    const overflowLeft = getOverflowLeft(line);\r\n    const overflowRight = getOverflowRight(line);\r\n    const x = line.box.x - overflowLeft;\r\n    const width = line.box.width + overflowLeft + overflowRight;\r\n    const box = Object.assign({}, line.box, { x, width });\r\n    return Object.assign({}, line, { box, overflowLeft, overflowRight });\r\n};\r\n/**\r\n * Performs line justification by calling appropiate engine\r\n *\r\n * @param engines - Engines\r\n * @param options - Layout options\r\n * @param align - Text align\r\n */\r\nconst justifyLine$1 = (engines, options, align) => {\r\n    /**\r\n     * @param line - Line\r\n     * @returns Line\r\n     */\r\n    return (line) => {\r\n        const lineWidth = advanceWidth(line);\r\n        const alignFactor = ALIGNMENT_FACTORS[align] || 0;\r\n        const remainingWidth = Math.max(0, line.box.width - lineWidth);\r\n        const shouldJustify = align === 'justify' || lineWidth > line.box.width;\r\n        const x = line.box.x + remainingWidth * alignFactor;\r\n        const box = Object.assign({}, line.box, { x });\r\n        const newLine = Object.assign({}, line, { box });\r\n        return shouldJustify ? engines.justification(options)(newLine) : newLine;\r\n    };\r\n};\r\nconst finalizeLine = (line) => {\r\n    let lineAscent = 0;\r\n    let lineDescent = 0;\r\n    let lineHeight = 0;\r\n    let lineXAdvance = 0;\r\n    const runs = line.runs.map((run) => {\r\n        const height = height$1(run);\r\n        const ascent = ascent$1(run);\r\n        const descent$1 = descent(run);\r\n        const xAdvance = advanceWidth$1(run);\r\n        lineHeight = Math.max(lineHeight, height);\r\n        lineAscent = Math.max(lineAscent, ascent);\r\n        lineDescent = Math.max(lineDescent, descent$1);\r\n        lineXAdvance += xAdvance;\r\n        return Object.assign({}, run, { height, ascent, descent: descent$1, xAdvance });\r\n    });\r\n    return Object.assign({}, line, {\r\n        runs,\r\n        height: lineHeight,\r\n        ascent: lineAscent,\r\n        descent: lineDescent,\r\n        xAdvance: lineXAdvance,\r\n    });\r\n};\r\n/**\r\n * Finalize line by performing line justification\r\n * and text decoration (using appropiate engines)\r\n *\r\n * @param engines - Engines\r\n * @param options - Layout options\r\n */\r\nconst finalizeBlock = (engines, options) => {\r\n    /**\r\n     * @param line - Line\r\n     * @param i - Line index\r\n     * @param lines - Total lines\r\n     * @returns Line\r\n     */\r\n    return (line, index, lines) => {\r\n        const isLastFragment = index === lines.length - 1;\r\n        const style = line.runs?.[0]?.attributes || {};\r\n        const align = isLastFragment ? style.alignLastLine : style.align;\r\n        return compose(finalizeLine, engines.textDecoration(), justifyLine$1(engines, options, align), adjustOverflow, removeNewLine)(line);\r\n    };\r\n};\r\n/**\r\n * Finalize line block by performing line justification\r\n * and text decoration (using appropiate engines)\r\n *\r\n * @param engines - Engines\r\n * @param options - Layout options\r\n */\r\nconst finalizeFragments = (engines, options) => {\r\n    /**\r\n     * @param paragraphs - Paragraphs\r\n     * @returns Paragraphs\r\n     */\r\n    return (paragraphs) => {\r\n        const blockFinalizer = finalizeBlock(engines, options);\r\n        return paragraphs.map((paragraph) => paragraph.map(blockFinalizer));\r\n    };\r\n};\r\n\r\nconst ATTACHMENT_CODE = 0xfffc; // 65532\r\nconst isReplaceGlyph = (glyph) => glyph.codePoints.includes(ATTACHMENT_CODE);\r\n/**\r\n * Resolve attachments of run\r\n *\r\n * @param run\r\n * @returns Run\r\n */\r\nconst resolveRunAttachments = (run) => {\r\n    if (!run.positions)\r\n        return run;\r\n    const glyphs = run.glyphs || [];\r\n    const attachment = run.attributes?.attachment;\r\n    if (!attachment)\r\n        return run;\r\n    const positions = run.positions.map((position, i) => {\r\n        const glyph = glyphs[i];\r\n        if (attachment.width && isReplaceGlyph(glyph)) {\r\n            return Object.assign({}, position, { xAdvance: attachment.width });\r\n        }\r\n        return Object.assign({}, position);\r\n    });\r\n    return Object.assign({}, run, { positions });\r\n};\r\n/**\r\n * Resolve attachments for multiple paragraphs\r\n */\r\nconst resolveAttachments = () => {\r\n    /**\r\n     * @param attributedString - Attributed string\r\n     * @returns Attributed string\r\n     */\r\n    return (attributedString) => {\r\n        const runs = attributedString.runs.map(resolveRunAttachments);\r\n        const res = Object.assign({}, attributedString, { runs });\r\n        return res;\r\n    };\r\n};\r\n\r\n/**\r\n * @param attributes - Attributes\r\n * @returns Attributes with defaults\r\n */\r\nconst applyAttributes = (a) => {\r\n    return {\r\n        align: a.align || (a.direction === 'rtl' ? 'right' : 'left'),\r\n        alignLastLine: a.alignLastLine || (a.align === 'justify' ? 'left' : a.align || 'left'),\r\n        attachment: a.attachment || null,\r\n        backgroundColor: a.backgroundColor || null,\r\n        bullet: a.bullet || null,\r\n        characterSpacing: a.characterSpacing || 0,\r\n        color: a.color || 'black',\r\n        direction: a.direction || 'ltr',\r\n        features: a.features || [],\r\n        fill: a.fill !== false,\r\n        font: a.font || [],\r\n        fontSize: a.fontSize || 12,\r\n        hangingPunctuation: a.hangingPunctuation || false,\r\n        hyphenationFactor: a.hyphenationFactor || 0,\r\n        indent: a.indent || 0,\r\n        justificationFactor: a.justificationFactor || 1,\r\n        lineHeight: a.lineHeight || null,\r\n        lineSpacing: a.lineSpacing || 0,\r\n        link: a.link || null,\r\n        marginLeft: a.marginLeft || a.margin || 0,\r\n        marginRight: a.marginRight || a.margin || 0,\r\n        opacity: a.opacity,\r\n        paddingTop: a.paddingTop || a.padding || 0,\r\n        paragraphSpacing: a.paragraphSpacing || 0,\r\n        script: a.script || null,\r\n        shrinkFactor: a.shrinkFactor || 0,\r\n        strike: a.strike || false,\r\n        strikeColor: a.strikeColor || a.color || 'black',\r\n        strikeStyle: a.strikeStyle || 'solid',\r\n        stroke: a.stroke || false,\r\n        underline: a.underline || false,\r\n        underlineColor: a.underlineColor || a.color || 'black',\r\n        underlineStyle: a.underlineStyle || 'solid',\r\n        verticalAlign: a.verticalAlign || null,\r\n        wordSpacing: a.wordSpacing || 0,\r\n        yOffset: a.yOffset || 0,\r\n    };\r\n};\r\n/**\r\n * Apply default style to run\r\n *\r\n * @param run - Run\r\n * @returns Run with default styles\r\n */\r\nconst applyRunStyles = (run) => {\r\n    const attributes = applyAttributes(run.attributes);\r\n    return Object.assign({}, run, { attributes });\r\n};\r\n/**\r\n * Apply default attributes for an attributed string\r\n */\r\nconst applyDefaultStyles = () => {\r\n    return (attributedString) => {\r\n        const string = attributedString.string || '';\r\n        const runs = (attributedString.runs || []).map(applyRunStyles);\r\n        return { string, runs };\r\n    };\r\n};\r\n\r\n/**\r\n * Apply scaling and yOffset for verticalAlign 'sub' and 'super'.\r\n */\r\nconst verticalAlignment = () => {\r\n    /**\r\n     * @param attributedString - Attributed string\r\n     * @returns Attributed string\r\n     */\r\n    return (attributedString) => {\r\n        attributedString.runs.forEach((run) => {\r\n            const { attributes } = run;\r\n            const { verticalAlign } = attributes;\r\n            if (verticalAlign === 'sub') {\r\n                attributes.yOffset = -0.2;\r\n            }\r\n            else if (verticalAlign === 'super') {\r\n                attributes.yOffset = 0.4;\r\n            }\r\n        });\r\n        return attributedString;\r\n    };\r\n};\r\n\r\nconst bidi$1 = bidiFactory();\r\n/**\r\n * @param runs\r\n * @returns Bidi levels\r\n */\r\nconst getBidiLevels = (runs) => {\r\n    return runs.reduce((acc, run) => {\r\n        const length = run.end - run.start;\r\n        const levels = repeat(run.attributes.bidiLevel, length);\r\n        return acc.concat(levels);\r\n    }, []);\r\n};\r\n/**\r\n * Perform bidi mirroring\r\n */\r\nconst mirrorString = () => {\r\n    /**\r\n     * @param attributedString - Attributed string\r\n     * @returns Attributed string\r\n     */\r\n    return (attributedString) => {\r\n        const levels = getBidiLevels(attributedString.runs);\r\n        let updatedString = '';\r\n        attributedString.string.split('').forEach((char, index) => {\r\n            const isRTL = levels[index] % 2 === 1;\r\n            const mirroredChar = isRTL\r\n                ? bidi$1.getMirroredCharacter(attributedString.string.charAt(index))\r\n                : null;\r\n            updatedString += mirroredChar || char;\r\n        });\r\n        const result = {\r\n            ...attributedString,\r\n            string: updatedString,\r\n        };\r\n        return result;\r\n    };\r\n};\r\n\r\n/**\r\n * A LayoutEngine is the main object that performs text layout.\r\n * It accepts an AttributedString and a Container object\r\n * to layout text into, and uses several helper objects to perform\r\n * various layout tasks. These objects can be overridden to customize\r\n * layout behavior.\r\n */\r\nconst layoutEngine = (engines) => {\r\n    return (attributedString, container, options = {}) => {\r\n        const processParagraph = compose(resolveYOffset(), resolveAttachments(), verticalAlignment(), wrapWords(engines, options), generateGlyphs(), mirrorString(), preprocessRuns(engines));\r\n        const processParagraphs = (paragraphs) => paragraphs.map(processParagraph);\r\n        return compose(finalizeFragments(engines, options), bidiReordering(), typesetter(engines, options, container), processParagraphs, splitParagraphs(), applyDefaultStyles())(attributedString);\r\n    };\r\n};\r\n\r\nconst bidi = bidiFactory();\r\nconst bidiEngine = () => {\r\n    /**\r\n     * @param attributedString - Attributed string\r\n     * @returns Attributed string\r\n     */\r\n    return (attributedString) => {\r\n        const { string } = attributedString;\r\n        const direction = attributedString.runs[0]?.attributes.direction;\r\n        const { levels } = bidi.getEmbeddingLevels(string, direction);\r\n        let lastLevel = null;\r\n        let lastIndex = 0;\r\n        let index = 0;\r\n        const runs = [];\r\n        for (let i = 0; i < levels.length; i += 1) {\r\n            const level = levels[i];\r\n            if (level !== lastLevel) {\r\n                if (lastLevel !== null) {\r\n                    runs.push({\r\n                        start: lastIndex,\r\n                        end: index,\r\n                        attributes: { bidiLevel: lastLevel },\r\n                    });\r\n                }\r\n                lastIndex = index;\r\n                lastLevel = level;\r\n            }\r\n            index += 1;\r\n        }\r\n        if (lastIndex < string.length) {\r\n            runs.push({\r\n                start: lastIndex,\r\n                end: string.length,\r\n                attributes: { bidiLevel: lastLevel },\r\n            });\r\n        }\r\n        const result = { string, runs };\r\n        return result;\r\n    };\r\n};\r\n\r\nconst INFINITY = 10000;\r\nconst getNextBreakpoint = (subnodes, widths, lineNumber) => {\r\n    let position = null;\r\n    let minimumBadness = Infinity;\r\n    const sum = { width: 0, stretch: 0, shrink: 0 };\r\n    const lineLength = widths[Math.min(lineNumber, widths.length - 1)];\r\n    const calculateRatio = (node) => {\r\n        const stretch = 'stretch' in node ? node.stretch : null;\r\n        if (sum.width < lineLength) {\r\n            if (!stretch)\r\n                return INFINITY;\r\n            return sum.stretch - stretch > 0\r\n                ? (lineLength - sum.width) / sum.stretch\r\n                : INFINITY;\r\n        }\r\n        const shrink = 'shrink' in node ? node.shrink : null;\r\n        if (sum.width > lineLength) {\r\n            if (!shrink)\r\n                return INFINITY;\r\n            return sum.shrink - shrink > 0\r\n                ? (lineLength - sum.width) / sum.shrink\r\n                : INFINITY;\r\n        }\r\n        return 0;\r\n    };\r\n    for (let i = 0; i < subnodes.length; i += 1) {\r\n        const node = subnodes[i];\r\n        if (node.type === 'box') {\r\n            sum.width += node.width;\r\n        }\r\n        if (node.type === 'glue') {\r\n            sum.width += node.width;\r\n            sum.stretch += node.stretch;\r\n            sum.shrink += node.shrink;\r\n        }\r\n        if (sum.width - sum.shrink > lineLength) {\r\n            if (position === null) {\r\n                let j = i === 0 ? i + 1 : i;\r\n                while (j < subnodes.length &&\r\n                    (subnodes[j].type === 'glue' || subnodes[j].type === 'penalty')) {\r\n                    j++;\r\n                }\r\n                position = j - 1;\r\n            }\r\n            break;\r\n        }\r\n        if (node.type === 'penalty' || node.type === 'glue') {\r\n            const ratio = calculateRatio(node);\r\n            const penalty = node.type === 'penalty' ? node.penalty : 0;\r\n            const badness = 100 * Math.abs(ratio) ** 3 + penalty;\r\n            if (minimumBadness >= badness) {\r\n                position = i;\r\n                minimumBadness = badness;\r\n            }\r\n        }\r\n    }\r\n    return sum.width - sum.shrink > lineLength ? position : null;\r\n};\r\nconst applyBestFit = (nodes, widths) => {\r\n    let count = 0;\r\n    let lineNumber = 0;\r\n    let subnodes = nodes;\r\n    const breakpoints = [0];\r\n    while (subnodes.length > 0) {\r\n        const breakpoint = getNextBreakpoint(subnodes, widths, lineNumber);\r\n        if (breakpoint !== null) {\r\n            count += breakpoint;\r\n            breakpoints.push(count);\r\n            subnodes = subnodes.slice(breakpoint + 1, subnodes.length);\r\n            count++;\r\n            lineNumber++;\r\n        }\r\n        else {\r\n            subnodes = [];\r\n        }\r\n    }\r\n    return breakpoints;\r\n};\r\n\r\n/* eslint-disable max-classes-per-file */\r\nclass LinkedListNode {\r\n    data;\r\n    prev;\r\n    next;\r\n    constructor(data) {\r\n        this.data = data;\r\n        this.prev = null;\r\n        this.next = null;\r\n    }\r\n}\r\nclass LinkedList {\r\n    static Node = LinkedListNode;\r\n    head;\r\n    tail;\r\n    listSize;\r\n    listLength;\r\n    constructor() {\r\n        this.head = null;\r\n        this.tail = null;\r\n        this.listSize = 0;\r\n        this.listLength = 0;\r\n    }\r\n    isLinked(node) {\r\n        return !((node &&\r\n            node.prev === null &&\r\n            node.next === null &&\r\n            this.tail !== node &&\r\n            this.head !== node) ||\r\n            this.isEmpty());\r\n    }\r\n    size() {\r\n        return this.listSize;\r\n    }\r\n    isEmpty() {\r\n        return this.listSize === 0;\r\n    }\r\n    first() {\r\n        return this.head;\r\n    }\r\n    last() {\r\n        return this.last;\r\n    }\r\n    forEach(callback) {\r\n        let node = this.head;\r\n        while (node !== null) {\r\n            callback(node);\r\n            node = node.next;\r\n        }\r\n    }\r\n    at(i) {\r\n        let node = this.head;\r\n        let index = 0;\r\n        if (i >= this.listLength || i < 0) {\r\n            return null;\r\n        }\r\n        while (node !== null) {\r\n            if (i === index) {\r\n                return node;\r\n            }\r\n            node = node.next;\r\n            index += 1;\r\n        }\r\n        return null;\r\n    }\r\n    insertAfter(node, newNode) {\r\n        if (!this.isLinked(node))\r\n            return this;\r\n        newNode.prev = node;\r\n        newNode.next = node.next;\r\n        if (node.next === null) {\r\n            this.tail = newNode;\r\n        }\r\n        else {\r\n            node.next.prev = newNode;\r\n        }\r\n        node.next = newNode;\r\n        this.listSize += 1;\r\n        return this;\r\n    }\r\n    insertBefore(node, newNode) {\r\n        if (!this.isLinked(node))\r\n            return this;\r\n        newNode.prev = node.prev;\r\n        newNode.next = node;\r\n        if (node.prev === null) {\r\n            this.head = newNode;\r\n        }\r\n        else {\r\n            node.prev.next = newNode;\r\n        }\r\n        node.prev = newNode;\r\n        this.listSize += 1;\r\n        return this;\r\n    }\r\n    push(node) {\r\n        if (this.head === null) {\r\n            this.unshift(node);\r\n        }\r\n        else {\r\n            this.insertAfter(this.tail, node);\r\n        }\r\n        return this;\r\n    }\r\n    unshift(node) {\r\n        if (this.head === null) {\r\n            this.head = node;\r\n            this.tail = node;\r\n            node.prev = null;\r\n            node.next = null;\r\n            this.listSize += 1;\r\n        }\r\n        else {\r\n            this.insertBefore(this.head, node);\r\n        }\r\n        return this;\r\n    }\r\n    remove(node) {\r\n        if (!this.isLinked(node))\r\n            return this;\r\n        if (node.prev === null) {\r\n            this.head = node.next;\r\n        }\r\n        else {\r\n            node.prev.next = node.next;\r\n        }\r\n        if (node.next === null) {\r\n            this.tail = node.prev;\r\n        }\r\n        else {\r\n            node.next.prev = node.prev;\r\n        }\r\n        this.listSize -= 1;\r\n        return this;\r\n    }\r\n}\r\n\r\n/**\r\n * Licensed under the new BSD License.\r\n * Copyright 2009-2010, Bram Stein\r\n * All rights reserved.\r\n */\r\nfunction breakpoint(position, demerits, line, fitnessClass, totals, previous) {\r\n    return {\r\n        position,\r\n        demerits,\r\n        line,\r\n        fitnessClass,\r\n        totals: totals || {\r\n            width: 0,\r\n            stretch: 0,\r\n            shrink: 0,\r\n        },\r\n        previous,\r\n    };\r\n}\r\nfunction computeCost(nodes, lineLengths, sum, end, active, currentLine) {\r\n    let width = sum.width - active.totals.width;\r\n    let stretch = 0;\r\n    let shrink = 0;\r\n    // If the current line index is within the list of linelengths, use it, otherwise use\r\n    // the last line length of the list.\r\n    const lineLength = currentLine < lineLengths.length\r\n        ? lineLengths[currentLine - 1]\r\n        : lineLengths[lineLengths.length - 1];\r\n    if (nodes[end].type === 'penalty') {\r\n        width += nodes[end].width;\r\n    }\r\n    // Calculate the stretch ratio\r\n    if (width < lineLength) {\r\n        stretch = sum.stretch - active.totals.stretch;\r\n        if (stretch > 0) {\r\n            return (lineLength - width) / stretch;\r\n        }\r\n        return linebreak.infinity;\r\n    }\r\n    // Calculate the shrink ratio\r\n    if (width > lineLength) {\r\n        shrink = sum.shrink - active.totals.shrink;\r\n        if (shrink > 0) {\r\n            return (lineLength - width) / shrink;\r\n        }\r\n        return linebreak.infinity;\r\n    }\r\n    // perfect match\r\n    return 0;\r\n}\r\n// Add width, stretch and shrink values from the current\r\n// break point up to the next box or forced penalty.\r\nfunction computeSum(nodes, sum, breakPointIndex) {\r\n    const result = {\r\n        width: sum.width,\r\n        stretch: sum.stretch,\r\n        shrink: sum.shrink,\r\n    };\r\n    for (let i = breakPointIndex; i < nodes.length; i += 1) {\r\n        const node = nodes[i];\r\n        if (node.type === 'glue') {\r\n            result.width += node.width;\r\n            result.stretch += node.stretch;\r\n            result.shrink += node.shrink;\r\n        }\r\n        else if (node.type === 'box' ||\r\n            (node.type === 'penalty' &&\r\n                node.penalty === -linebreak.infinity &&\r\n                i > breakPointIndex)) {\r\n            break;\r\n        }\r\n    }\r\n    return result;\r\n}\r\nfunction findBestBreakpoints(activeNodes) {\r\n    const breakpoints = [];\r\n    if (activeNodes.size() === 0)\r\n        return [];\r\n    let tmp = { data: { demerits: Infinity } };\r\n    // Find the best active node (the one with the least total demerits.)\r\n    activeNodes.forEach((node) => {\r\n        if (node.data.demerits < tmp.data.demerits) {\r\n            tmp = node;\r\n        }\r\n    });\r\n    while (tmp !== null) {\r\n        breakpoints.push(tmp.data.position);\r\n        tmp = tmp.data.previous;\r\n    }\r\n    return breakpoints.reverse();\r\n}\r\n/**\r\n * @param nodes\r\n * @param availableWidths\r\n * @param tolerance\r\n * @preserve Knuth and Plass line breaking algorithm in JavaScript\r\n */\r\nconst linebreak = (nodes, availableWidths, tolerance) => {\r\n    // Demerits are used as a way to penalize bad line breaks\r\n    //  - line: applied to each line, depending on how much spaces need to stretch or shrink\r\n    //  - flagged: applied when consecutive lines end in hyphenation\r\n    //  - fitness: algorithm groups lines into fitness classes based on how loose or tight the spacing is.\r\n    //             if a paragraph has consecutive lines from different fitness classes,\r\n    //             a fitness demerit is applied to maintain visual consistency.\r\n    const options = {\r\n        demerits: { line: 10, flagged: 100, fitness: 3000 },\r\n        tolerance: tolerance || 3,\r\n    };\r\n    const activeNodes = new LinkedList();\r\n    const sum = { width: 0, stretch: 0, shrink: 0 };\r\n    const lineLengths = availableWidths;\r\n    // Add an active node for the start of the paragraph.\r\n    activeNodes.push(new LinkedList.Node(breakpoint(0, 0, 0, 0, undefined, null)));\r\n    // The main loop of the algorithm\r\n    function mainLoop(node, index, nodes) {\r\n        let active = activeNodes.first();\r\n        // The inner loop iterates through all the active nodes with line < currentLine and then\r\n        // breaks out to insert the new active node candidates before looking at the next active\r\n        // nodes for the next lines. The result of this is that the active node list is always\r\n        // sorted by line number.\r\n        while (active !== null) {\r\n            let currentLine = 0;\r\n            // Candidates fo each fitness class\r\n            const candidates = [\r\n                { active: undefined, demerits: Infinity },\r\n                { active: undefined, demerits: Infinity },\r\n                { active: undefined, demerits: Infinity },\r\n                { active: undefined, demerits: Infinity },\r\n            ];\r\n            // Iterate through the linked list of active nodes to find new potential active nodes and deactivate current active nodes.\r\n            while (active !== null) {\r\n                currentLine = active.data.line + 1;\r\n                const ratio = computeCost(nodes, lineLengths, sum, index, active.data, currentLine);\r\n                // Deactive nodes when the distance between the current active node and the\r\n                // current node becomes too large (i.e. it exceeds the stretch limit and the stretch\r\n                // ratio becomes negative) or when the current node is a forced break (i.e. the end\r\n                // of the paragraph when we want to remove all active nodes, but possibly have a final\r\n                // candidate active node---if the paragraph can be set using the given tolerance value.)\r\n                if (ratio < -1 ||\r\n                    (node.type === 'penalty' && node.penalty === -linebreak.infinity)) {\r\n                    activeNodes.remove(active);\r\n                }\r\n                // If the ratio is within the valid range of -1 <= ratio <= tolerance calculate the\r\n                // total demerits and record a candidate active node.\r\n                if (ratio >= -1 && ratio <= options.tolerance) {\r\n                    const badness = 100 * Math.pow(Math.abs(ratio), 3);\r\n                    let demerits = 0;\r\n                    // Positive penalty\r\n                    if (node.type === 'penalty' && node.penalty >= 0) {\r\n                        demerits =\r\n                            Math.pow(options.demerits.line + badness, 2) +\r\n                                Math.pow(node.penalty, 2);\r\n                        // Negative penalty but not a forced break\r\n                    }\r\n                    else if (node.type === 'penalty' &&\r\n                        node.penalty !== -linebreak.infinity) {\r\n                        demerits =\r\n                            Math.pow(options.demerits.line + badness, 2) -\r\n                                Math.pow(node.penalty, 2);\r\n                        // All other cases\r\n                    }\r\n                    else {\r\n                        demerits = Math.pow(options.demerits.line + badness, 2);\r\n                    }\r\n                    if (node.type === 'penalty' &&\r\n                        nodes[active.data.position].type === 'penalty') {\r\n                        demerits +=\r\n                            options.demerits.flagged *\r\n                                node.flagged *\r\n                                // @ts-expect-error node is penalty here\r\n                                nodes[active.data.position].flagged;\r\n                    }\r\n                    // Calculate the fitness class for this candidate active node.\r\n                    let currentClass;\r\n                    if (ratio < -0.5) {\r\n                        currentClass = 0;\r\n                    }\r\n                    else if (ratio <= 0.5) {\r\n                        currentClass = 1;\r\n                    }\r\n                    else if (ratio <= 1) {\r\n                        currentClass = 2;\r\n                    }\r\n                    else {\r\n                        currentClass = 3;\r\n                    }\r\n                    // Add a fitness penalty to the demerits if the fitness classes of two adjacent lines differ too much.\r\n                    if (Math.abs(currentClass - active.data.fitnessClass) > 1) {\r\n                        demerits += options.demerits.fitness;\r\n                    }\r\n                    // Add the total demerits of the active node to get the total demerits of this candidate node.\r\n                    demerits += active.data.demerits;\r\n                    // Only store the best candidate for each fitness class\r\n                    if (demerits < candidates[currentClass].demerits) {\r\n                        candidates[currentClass] = { active, demerits };\r\n                    }\r\n                }\r\n                active = active.next;\r\n                // Stop iterating through active nodes to insert new candidate active nodes in the active list\r\n                // before moving on to the active nodes for the next line.\r\n                // TODO: The Knuth and Plass paper suggests a conditional for currentLine < j0. This means paragraphs\r\n                // with identical line lengths will not be sorted by line number. Find out if that is a desirable outcome.\r\n                // For now I left this out, as it only adds minimal overhead to the algorithm and keeping the active node\r\n                // list sorted has a higher priority.\r\n                if (active !== null && active.data.line >= currentLine) {\r\n                    break;\r\n                }\r\n            }\r\n            const tmpSum = computeSum(nodes, sum, index);\r\n            for (let fitnessClass = 0; fitnessClass < candidates.length; fitnessClass += 1) {\r\n                const candidate = candidates[fitnessClass];\r\n                if (candidate.demerits === Infinity)\r\n                    continue;\r\n                const newNode = new LinkedList.Node(breakpoint(index, candidate.demerits, candidate.active.data.line + 1, fitnessClass, tmpSum, candidate.active));\r\n                if (active !== null) {\r\n                    activeNodes.insertBefore(active, newNode);\r\n                }\r\n                else {\r\n                    activeNodes.push(newNode);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    nodes.forEach((node, index, nodes) => {\r\n        if (node.type === 'box') {\r\n            sum.width += node.width;\r\n            return;\r\n        }\r\n        if (node.type === 'glue') {\r\n            const precedesBox = index > 0 && nodes[index - 1].type === 'box';\r\n            if (precedesBox)\r\n                mainLoop(node, index, nodes);\r\n            sum.width += node.width;\r\n            sum.stretch += node.stretch;\r\n            sum.shrink += node.shrink;\r\n            return;\r\n        }\r\n        if (node.type === 'penalty' && node.penalty !== linebreak.infinity) {\r\n            mainLoop(node, index, nodes);\r\n        }\r\n    });\r\n    return findBestBreakpoints(activeNodes);\r\n};\r\nlinebreak.infinity = 10000;\r\nlinebreak.glue = (width, start, end, stretch, shrink) => ({\r\n    type: 'glue',\r\n    start,\r\n    end,\r\n    width,\r\n    stretch,\r\n    shrink,\r\n});\r\nlinebreak.box = (width, start, end, hyphenated = false) => ({\r\n    type: 'box',\r\n    width,\r\n    start,\r\n    end,\r\n    hyphenated,\r\n});\r\nlinebreak.penalty = (width, penalty, flagged) => ({\r\n    type: 'penalty',\r\n    width,\r\n    penalty,\r\n    flagged,\r\n});\r\n\r\n/**\r\n * Add scalar to run\r\n *\r\n * @param index - Scalar\r\n * @param run - Run\r\n * @returns Added run\r\n */\r\nconst add = (index, run) => {\r\n    const start = run.start + index;\r\n    const end = run.end + index;\r\n    return Object.assign({}, run, { start, end });\r\n};\r\n\r\n/**\r\n * Get run length\r\n *\r\n * @param run - Run\r\n * @returns Length\r\n */\r\nconst length = (run) => {\r\n    return run.end - run.start;\r\n};\r\n\r\n/**\r\n * Concats two runs into one\r\n *\r\n * @param runA - First run\r\n * @param runB - Second run\r\n * @returns Concatenated run\r\n */\r\nconst concat = (runA, runB) => {\r\n    const end = runA.end + length(runB);\r\n    const glyphs = (runA.glyphs || []).concat(runB.glyphs || []);\r\n    const positions = (runA.positions || []).concat(runB.positions || []);\r\n    const attributes = Object.assign({}, runA.attributes, runB.attributes);\r\n    const runAIndices = runA.glyphIndices || [];\r\n    const runALastIndex = last(runAIndices) || 0;\r\n    const runBIndices = (runB.glyphIndices || []).map((i) => i + runALastIndex + 1);\r\n    const glyphIndices = normalize(runAIndices.concat(runBIndices));\r\n    return Object.assign({}, runA, {\r\n        end,\r\n        glyphs,\r\n        positions,\r\n        attributes,\r\n        glyphIndices,\r\n    });\r\n};\r\n\r\n/**\r\n * Insert glyph to run in the given index\r\n *\r\n * @param index - Index\r\n * @param glyph - Glyph\r\n * @param run - Run\r\n * @returns Run with glyph\r\n */\r\nconst insertGlyph$1 = (index, glyph, run) => {\r\n    if (!glyph)\r\n        return run;\r\n    // Split resolves ligature splitting in case new glyph breaks some\r\n    const leadingRun = slice$1(0, index, run);\r\n    const trailingRun = slice$1(index, Infinity, run);\r\n    return concat(append$1(glyph, leadingRun), trailingRun);\r\n};\r\n/**\r\n * Insert either glyph or code point to run in the given index\r\n *\r\n * @param index - Index\r\n * @param value - Glyph or codePoint\r\n * @param run - Run\r\n * @returns Run with glyph\r\n */\r\nconst insert = (index, value, run) => {\r\n    const font = getFont(run);\r\n    const glyph = isNumber(value) ? fromCodePoint(value, font) : value;\r\n    return insertGlyph$1(index, glyph, run);\r\n};\r\n\r\n/**\r\n * Get run index at char index\r\n *\r\n * @param index - Char index\r\n * @param attributedString - Attributed string\r\n * @returns Run index\r\n */\r\nconst runIndexAt = (index, attributedString) => {\r\n    return runIndexAt$1(index, attributedString.runs);\r\n};\r\n\r\n/**\r\n * Insert glyph into attributed string\r\n *\r\n * @param index - Index\r\n * @param glyph - Glyph or code point\r\n * @param attributedString - Attributed string\r\n * @returns Attributed string with new glyph\r\n */\r\nconst insertGlyph = (index, glyph, attributedString) => {\r\n    const runIndex = runIndexAt(index, attributedString);\r\n    // Add glyph to the end if run index invalid\r\n    if (runIndex === -1)\r\n        return append(glyph, attributedString);\r\n    const codePoints = [glyph] ;\r\n    const string = attributedString.string.slice(0, index) +\r\n        stringFromCodePoints(codePoints) +\r\n        attributedString.string.slice(index);\r\n    const runs = attributedString.runs.map((run, i) => {\r\n        if (i === runIndex)\r\n            return insert(index - run.start, glyph, run);\r\n        if (i > runIndex)\r\n            return add(codePoints.length, run);\r\n        return run;\r\n    });\r\n    return Object.assign({}, attributedString, { string, runs });\r\n};\r\n\r\n/**\r\n * Advance width between two string indices\r\n *\r\n * @param start - Glyph index\r\n * @param end - Glyph index\r\n * @param run - Run\r\n * @returns Advanced width run\r\n */\r\nconst advanceWidthBetween$1 = (start, end, run) => {\r\n    const runStart = run.start || 0;\r\n    const glyphStartIndex = Math.max(0, glyphIndexAt(start - runStart, run));\r\n    const glyphEndIndex = Math.max(0, glyphIndexAt(end - runStart, run));\r\n    const positions = (run.positions || []).slice(glyphStartIndex, glyphEndIndex);\r\n    return advanceWidth$2(positions);\r\n};\r\n\r\n/**\r\n * Advance width between start and end\r\n * Does not consider ligature splitting for the moment.\r\n * Check performance impact on supporting this\r\n *\r\n * @param start - Start offset\r\n * @param end - End offset\r\n * @param attributedString\r\n * @returns Advance width\r\n */\r\nconst advanceWidthBetween = (start, end, attributedString) => {\r\n    const runs = filter(start, end, attributedString.runs);\r\n    return runs.reduce((acc, run) => acc + advanceWidthBetween$1(start, end, run), 0);\r\n};\r\n\r\nconst HYPHEN = 0x002d;\r\nconst TOLERANCE_STEPS = 5;\r\nconst TOLERANCE_LIMIT = 50;\r\nconst opts = {\r\n    width: 3,\r\n    stretch: 6,\r\n    shrink: 9,\r\n};\r\n/**\r\n * Slice attributed string to many lines\r\n *\r\n * @param attributedString - Attributed string\r\n * @param nodes\r\n * @param breaks\r\n * @returns Attributed strings\r\n */\r\nconst breakLines = (attributedString, nodes, breaks) => {\r\n    let start = 0;\r\n    let end = null;\r\n    const lines = breaks.reduce((acc, breakPoint) => {\r\n        const node = nodes[breakPoint];\r\n        const prevNode = nodes[breakPoint - 1];\r\n        // Last breakpoint corresponds to K&P mandatory final glue\r\n        if (breakPoint === nodes.length - 1)\r\n            return acc;\r\n        let line;\r\n        if (node.type === 'penalty') {\r\n            // @ts-expect-error penalty node will always preceed box or glue node\r\n            end = prevNode.end;\r\n            line = slice(start, end, attributedString);\r\n            line = insertGlyph(line.string.length, HYPHEN, line);\r\n        }\r\n        else {\r\n            end = node.end;\r\n            line = slice(start, end, attributedString);\r\n        }\r\n        start = end;\r\n        return [...acc, line];\r\n    }, []);\r\n    // Last line\r\n    lines.push(slice(start, attributedString.string.length, attributedString));\r\n    return lines;\r\n};\r\n/**\r\n * Return Knuth & Plass nodes based on line and previously calculated syllables\r\n *\r\n * @param attributedString - Attributed string\r\n * @param attributes - Attributes\r\n * @param options - Layout options\r\n * @returns ?\r\n */\r\nconst getNodes = (attributedString, { align }, options) => {\r\n    let start = 0;\r\n    const hyphenWidth = 5;\r\n    const { syllables } = attributedString;\r\n    const hyphenPenalty = options.hyphenationPenalty || (align === 'justify' ? 100 : 600);\r\n    const result = syllables.reduce((acc, s, index) => {\r\n        const width = advanceWidthBetween(start, start + s.length, attributedString);\r\n        if (s.trim() === '') {\r\n            const stretch = (width * opts.width) / opts.stretch;\r\n            const shrink = (width * opts.width) / opts.shrink;\r\n            const end = start + s.length;\r\n            // Add glue node. Glue nodes are used to fill the space between words.\r\n            acc.push(linebreak.glue(width, start, end, stretch, shrink));\r\n        }\r\n        else {\r\n            const hyphenated = syllables[index + 1] !== ' ';\r\n            const end = start + s.length;\r\n            // Add box node. Box nodes are used to represent words.\r\n            acc.push(linebreak.box(width, start, end, hyphenated));\r\n            if (syllables[index + 1] && hyphenated) {\r\n                // Add penalty node. Penalty nodes are used to represent hyphenation points.\r\n                acc.push(linebreak.penalty(hyphenWidth, hyphenPenalty, 1));\r\n            }\r\n        }\r\n        start += s.length;\r\n        return acc;\r\n    }, []);\r\n    // Add mandatory final glue\r\n    result.push(linebreak.glue(0, start, start, linebreak.infinity, 0));\r\n    result.push(linebreak.penalty(0, -linebreak.infinity, 1));\r\n    return result;\r\n};\r\n/**\r\n * @param attributedString - Attributed string\r\n * @returns Attributes\r\n */\r\nconst getAttributes = (attributedString) => {\r\n    return attributedString.runs?.[0]?.attributes || {};\r\n};\r\n/**\r\n * Performs Knuth & Plass line breaking algorithm\r\n * Fallbacks to best fit algorithm if latter not successful\r\n *\r\n * @param options - Layout options\r\n */\r\nconst linebreaker = (options) => {\r\n    /**\r\n     * @param attributedString - Attributed string\r\n     * @param availableWidths - Available widths\r\n     * @returns Attributed string\r\n     */\r\n    return (attributedString, availableWidths) => {\r\n        let tolerance = options.tolerance || 4;\r\n        const attributes = getAttributes(attributedString);\r\n        const nodes = getNodes(attributedString, attributes, options);\r\n        let breaks = linebreak(nodes, availableWidths, tolerance);\r\n        // Try again with a higher tolerance if the line breaking failed.\r\n        while (breaks.length === 0 && tolerance < TOLERANCE_LIMIT) {\r\n            tolerance += TOLERANCE_STEPS;\r\n            breaks = linebreak(nodes, availableWidths, tolerance);\r\n        }\r\n        if (breaks.length === 0 || (breaks.length === 1 && breaks[0] === 0)) {\r\n            breaks = applyBestFit(nodes, availableWidths);\r\n        }\r\n        return breakLines(attributedString, nodes, breaks.slice(1));\r\n    };\r\n};\r\n\r\nvar Direction;\r\n(function (Direction) {\r\n    Direction[Direction[\"GROW\"] = 0] = \"GROW\";\r\n    Direction[Direction[\"SHRINK\"] = 1] = \"SHRINK\";\r\n})(Direction || (Direction = {}));\r\nconst WHITESPACE_PRIORITY = 1;\r\nconst LETTER_PRIORITY = 2;\r\nconst EXPAND_WHITESPACE_FACTOR = {\r\n    before: 0.5,\r\n    after: 0.5,\r\n    priority: WHITESPACE_PRIORITY,\r\n    unconstrained: false,\r\n};\r\nconst EXPAND_CHAR_FACTOR = {\r\n    before: 0.14453125, // 37/256\r\n    after: 0.14453125,\r\n    priority: LETTER_PRIORITY,\r\n    unconstrained: false,\r\n};\r\nconst SHRINK_WHITESPACE_FACTOR = {\r\n    before: -0.04296875, // -11/256\r\n    after: -0.04296875,\r\n    priority: WHITESPACE_PRIORITY,\r\n    unconstrained: false,\r\n};\r\nconst SHRINK_CHAR_FACTOR = {\r\n    before: -0.04296875,\r\n    after: -0.04296875,\r\n    priority: LETTER_PRIORITY,\r\n    unconstrained: false,\r\n};\r\nconst getCharFactor = (direction, options) => {\r\n    const expandCharFactor = options.expandCharFactor || {};\r\n    const shrinkCharFactor = options.shrinkCharFactor || {};\r\n    return direction === Direction.GROW\r\n        ? Object.assign({}, EXPAND_CHAR_FACTOR, expandCharFactor)\r\n        : Object.assign({}, SHRINK_CHAR_FACTOR, shrinkCharFactor);\r\n};\r\nconst getWhitespaceFactor = (direction, options) => {\r\n    const expandWhitespaceFactor = options.expandWhitespaceFactor || {};\r\n    const shrinkWhitespaceFactor = options.shrinkWhitespaceFactor || {};\r\n    return direction === Direction.GROW\r\n        ? Object.assign({}, EXPAND_WHITESPACE_FACTOR, expandWhitespaceFactor)\r\n        : Object.assign({}, SHRINK_WHITESPACE_FACTOR, shrinkWhitespaceFactor);\r\n};\r\nconst factor = (direction, options) => (glyphs) => {\r\n    const charFactor = getCharFactor(direction, options);\r\n    const whitespaceFactor = getWhitespaceFactor(direction, options);\r\n    const factors = [];\r\n    for (let index = 0; index < glyphs.length; index += 1) {\r\n        let f;\r\n        const glyph = glyphs[index];\r\n        if (isWhiteSpace(glyph)) {\r\n            f = Object.assign({}, whitespaceFactor);\r\n            if (index === glyphs.length - 1) {\r\n                f.before = 0;\r\n                if (index > 0) {\r\n                    factors[index - 1].after = 0;\r\n                }\r\n            }\r\n        }\r\n        else if (glyph.isMark && index > 0) {\r\n            f = Object.assign({}, factors[index - 1]);\r\n            f.before = 0;\r\n            factors[index - 1].after = 0;\r\n        }\r\n        else {\r\n            f = Object.assign({}, charFactor);\r\n        }\r\n        factors.push(f);\r\n    }\r\n    return factors;\r\n};\r\nconst getFactors = (gap, line, options) => {\r\n    const direction = gap > 0 ? Direction.GROW : Direction.SHRINK;\r\n    const getFactor = factor(direction, options);\r\n    const factors = line.runs.reduce((acc, run) => {\r\n        return acc.concat(getFactor(run.glyphs));\r\n    }, []);\r\n    factors[0].before = 0;\r\n    factors[factors.length - 1].after = 0;\r\n    return factors;\r\n};\r\n\r\nconst KASHIDA_PRIORITY = 0;\r\nconst NULL_PRIORITY = 3;\r\nconst getDistances = (gap, factors) => {\r\n    let total = 0;\r\n    const priorities = [];\r\n    const unconstrained = [];\r\n    for (let priority = KASHIDA_PRIORITY; priority <= NULL_PRIORITY; priority += 1) {\r\n        priorities[priority] = unconstrained[priority] = 0;\r\n    }\r\n    // sum the factors at each priority\r\n    for (let j = 0; j < factors.length; j += 1) {\r\n        const f = factors[j];\r\n        const sum = f.before + f.after;\r\n        total += sum;\r\n        priorities[f.priority] += sum;\r\n        if (f.unconstrained) {\r\n            unconstrained[f.priority] += sum;\r\n        }\r\n    }\r\n    // choose the priorities that need to be applied\r\n    let highestPriority = -1;\r\n    let highestPrioritySum = 0;\r\n    let remainingGap = gap;\r\n    let priority;\r\n    for (priority = KASHIDA_PRIORITY; priority <= NULL_PRIORITY; priority += 1) {\r\n        const prioritySum = priorities[priority];\r\n        if (prioritySum !== 0) {\r\n            if (highestPriority === -1) {\r\n                highestPriority = priority;\r\n                highestPrioritySum = prioritySum;\r\n            }\r\n            // if this priority covers the remaining gap, we're done\r\n            if (Math.abs(remainingGap) <= Math.abs(prioritySum)) {\r\n                priorities[priority] = remainingGap / prioritySum;\r\n                unconstrained[priority] = 0;\r\n                remainingGap = 0;\r\n                break;\r\n            }\r\n            // mark that we need to use 100% of the adjustment from\r\n            // this priority, and subtract the space that it consumes\r\n            priorities[priority] = 1;\r\n            remainingGap -= prioritySum;\r\n            // if this priority has unconstrained glyphs, let them consume the remaining space\r\n            if (unconstrained[priority] !== 0) {\r\n                unconstrained[priority] = remainingGap / unconstrained[priority];\r\n                remainingGap = 0;\r\n                break;\r\n            }\r\n        }\r\n    }\r\n    // zero out remaining priorities (if any)\r\n    for (let p = priority + 1; p <= NULL_PRIORITY; p += 1) {\r\n        priorities[p] = 0;\r\n        unconstrained[p] = 0;\r\n    }\r\n    // if there is still space left over, assign it to the highest priority that we saw.\r\n    // this violates their factors, but it only happens in extreme cases\r\n    if (remainingGap > 0 && highestPriority > -1) {\r\n        priorities[highestPriority] =\r\n            (highestPrioritySum + (gap - total)) / highestPrioritySum;\r\n    }\r\n    // create and return an array of distances to add to each glyph's advance\r\n    const distances = [];\r\n    for (let index = 0; index < factors.length; index += 1) {\r\n        // the distance to add to this glyph is the sum of the space to add\r\n        // after this glyph, and the space to add before the next glyph\r\n        const f = factors[index];\r\n        const next = factors[index + 1];\r\n        let dist = f.after * priorities[f.priority];\r\n        if (next) {\r\n            dist += next.before * priorities[next.priority];\r\n        }\r\n        // if this glyph is unconstrained, add the unconstrained distance as well\r\n        if (f.unconstrained) {\r\n            dist += f.after * unconstrained[f.priority];\r\n            if (next) {\r\n                dist += next.before * unconstrained[next.priority];\r\n            }\r\n        }\r\n        distances.push(dist);\r\n    }\r\n    return distances;\r\n};\r\n\r\n/**\r\n * Adjust run positions by given distances\r\n *\r\n * @param distances\r\n * @param line\r\n * @returns Line\r\n */\r\nconst justifyLine = (distances, line) => {\r\n    let index = 0;\r\n    for (const run of line.runs) {\r\n        for (const position of run.positions) {\r\n            position.xAdvance += distances[index++];\r\n        }\r\n    }\r\n    return line;\r\n};\r\n/**\r\n * A JustificationEngine is used by a Typesetter to perform line fragment\r\n * justification. This implementation is based on a description of Apple's\r\n * justification algorithm from a PDF in the Apple Font Tools package.\r\n *\r\n * @param options - Layout options\r\n */\r\nconst justification = (options) => {\r\n    /**\r\n     * @param line\r\n     * @returns Line\r\n     */\r\n    return (line) => {\r\n        const gap = line.box.width - advanceWidth(line);\r\n        if (gap === 0)\r\n            return line; // Exact fit\r\n        const factors = getFactors(gap, line, options);\r\n        const distances = getDistances(gap, factors);\r\n        return justifyLine(distances, line);\r\n    };\r\n};\r\n\r\n/**\r\n * Returns attributed string ascent\r\n *\r\n * @param attributedString - Attributed string\r\n * @returns Ascent\r\n */\r\nconst ascent = (attributedString) => {\r\n    const reducer = (acc, run) => Math.max(acc, ascent$1(run));\r\n    return attributedString.runs.reduce(reducer, 0);\r\n};\r\n\r\n// The base font size used for calculating underline thickness.\r\nconst BASE_FONT_SIZE = 12;\r\n/**\r\n * A TextDecorationEngine is used by a Typesetter to generate\r\n * DecorationLines for a line fragment, including underlines\r\n * and strikes.\r\n */\r\nconst textDecoration = () => (line) => {\r\n    let x = line.overflowLeft || 0;\r\n    const overflowRight = line.overflowRight || 0;\r\n    const maxX = advanceWidth(line) - overflowRight;\r\n    line.decorationLines = [];\r\n    for (let i = 0; i < line.runs.length; i += 1) {\r\n        const run = line.runs[i];\r\n        const width = Math.min(maxX - x, advanceWidth$1(run));\r\n        const thickness = Math.max(0.5, Math.floor(run.attributes.fontSize / BASE_FONT_SIZE));\r\n        if (run.attributes.underline) {\r\n            const rect = {\r\n                x,\r\n                y: ascent(line) + thickness * 2,\r\n                width,\r\n                height: thickness,\r\n            };\r\n            const decorationLine = {\r\n                rect,\r\n                opacity: run.attributes.opacity,\r\n                color: run.attributes.underlineColor || 'black',\r\n                style: run.attributes.underlineStyle || 'solid',\r\n            };\r\n            line.decorationLines.push(decorationLine);\r\n        }\r\n        if (run.attributes.strike) {\r\n            const y = ascent(line) - ascent$1(run) / 3;\r\n            const rect = { x, y, width, height: thickness };\r\n            const decorationLine = {\r\n                rect,\r\n                opacity: run.attributes.opacity,\r\n                color: run.attributes.strikeColor || 'black',\r\n                style: run.attributes.strikeStyle || 'solid',\r\n            };\r\n            line.decorationLines.push(decorationLine);\r\n        }\r\n        x += width;\r\n    }\r\n    return line;\r\n};\r\n\r\nconst ignoredScripts = ['Common', 'Inherited', 'Unknown'];\r\n/**\r\n * Resolves unicode script in runs, grouping equal runs together\r\n */\r\nconst scriptItemizer = () => {\r\n    /**\r\n     * @param attributedString - Attributed string\r\n     * @returns Attributed string\r\n     */\r\n    return (attributedString) => {\r\n        const { string } = attributedString;\r\n        let lastScript = 'Unknown';\r\n        let lastIndex = 0;\r\n        let index = 0;\r\n        const runs = [];\r\n        if (!string)\r\n            return empty();\r\n        for (let i = 0; i < string.length; i += 1) {\r\n            const char = string[i];\r\n            const codePoint = char.codePointAt(0);\r\n            const script = unicode.getScript(codePoint);\r\n            if (script !== lastScript && !ignoredScripts.includes(script)) {\r\n                if (lastScript !== 'Unknown') {\r\n                    runs.push({\r\n                        start: lastIndex,\r\n                        end: index,\r\n                        attributes: { script: lastScript },\r\n                    });\r\n                }\r\n                lastIndex = index;\r\n                lastScript = script;\r\n            }\r\n            index += char.length;\r\n        }\r\n        if (lastIndex < string.length) {\r\n            runs.push({\r\n                start: lastIndex,\r\n                end: string.length,\r\n                attributes: { script: lastScript },\r\n            });\r\n        }\r\n        const result = { string, runs: runs };\r\n        return result;\r\n    };\r\n};\r\n\r\nconst SOFT_HYPHEN = '\\u00ad';\r\nconst hyphenator = hyphen(pattern);\r\n/**\r\n * @param word\r\n * @returns Word parts\r\n */\r\nconst splitHyphen = (word) => {\r\n    return word.split(SOFT_HYPHEN);\r\n};\r\nconst cache = {};\r\n/**\r\n * @param word\r\n * @returns Word parts\r\n */\r\nconst getParts = (word) => {\r\n    const base = word.includes(SOFT_HYPHEN) ? word : hyphenator(word);\r\n    return splitHyphen(base);\r\n};\r\nconst wordHyphenation = () => {\r\n    /**\r\n     * @param word - Word\r\n     * @returns Word parts\r\n     */\r\n    return (word) => {\r\n        const cacheKey = `_${word}`;\r\n        if (isNil(word))\r\n            return [];\r\n        if (cache[cacheKey])\r\n            return cache[cacheKey];\r\n        cache[cacheKey] = getParts(word);\r\n        return cache[cacheKey];\r\n    };\r\n};\r\n\r\nconst IGNORED_CODE_POINTS = [173];\r\nconst getFontSize = (run) => run.attributes.fontSize || 12;\r\nconst pickFontFromFontStack = (codePoint, fontStack, lastFont) => {\r\n    const fontStackWithFallback = [...fontStack, lastFont];\r\n    for (let i = 0; i < fontStackWithFallback.length; i += 1) {\r\n        const font = fontStackWithFallback[i];\r\n        if (!IGNORED_CODE_POINTS.includes(codePoint) &&\r\n            font &&\r\n            font.hasGlyphForCodePoint &&\r\n            font.hasGlyphForCodePoint(codePoint)) {\r\n            return font;\r\n        }\r\n    }\r\n    return fontStack.at(-1);\r\n};\r\nconst fontSubstitution = () => ({ string, runs }) => {\r\n    let lastFont = null;\r\n    let lastFontSize = null;\r\n    let lastIndex = 0;\r\n    let index = 0;\r\n    const res = [];\r\n    for (let i = 0; i < runs.length; i += 1) {\r\n        const run = runs[i];\r\n        if (string.length === 0) {\r\n            res.push({\r\n                start: 0,\r\n                end: 0,\r\n                attributes: { font: run.attributes.font },\r\n            });\r\n            break;\r\n        }\r\n        const chars = string.slice(run.start, run.end);\r\n        for (let j = 0; j < chars.length; j += 1) {\r\n            const char = chars[j];\r\n            const codePoint = char.codePointAt(0);\r\n            // If the default font does not have a glyph and the fallback font does, we use it\r\n            const font = pickFontFromFontStack(codePoint, run.attributes.font, lastFont);\r\n            const fontSize = getFontSize(run);\r\n            // If anything that would impact res has changed, update it\r\n            if (font !== lastFont ||\r\n                fontSize !== lastFontSize ||\r\n                font.unitsPerEm !== lastFont.unitsPerEm) {\r\n                if (lastFont) {\r\n                    res.push({\r\n                        start: lastIndex,\r\n                        end: index,\r\n                        attributes: {\r\n                            font: [lastFont],\r\n                            scale: lastFontSize / lastFont.unitsPerEm,\r\n                        },\r\n                    });\r\n                }\r\n                lastFont = font;\r\n                lastFontSize = fontSize;\r\n                lastIndex = index;\r\n            }\r\n            index += char.length;\r\n        }\r\n    }\r\n    if (lastIndex < string.length) {\r\n        const fontSize = getFontSize(last(runs));\r\n        res.push({\r\n            start: lastIndex,\r\n            end: string.length,\r\n            attributes: {\r\n                font: [lastFont],\r\n                scale: fontSize / lastFont.unitsPerEm,\r\n            },\r\n        });\r\n    }\r\n    return { string, runs: res };\r\n};\r\n\r\nexport { bidiEngine as bidi, layoutEngine as default, fontSubstitution, fromFragments, justification, linebreaker, scriptItemizer, textDecoration, wordHyphenation };\r\n"]},"metadata":{},"sourceType":"module"}